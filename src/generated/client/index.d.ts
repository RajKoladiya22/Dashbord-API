
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SuperAdmin
 * 
 */
export type SuperAdmin = $Result.DefaultSelection<Prisma.$SuperAdminPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model LoginCredential
 * 
 */
export type LoginCredential = $Result.DefaultSelection<Prisma.$LoginCredentialPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model PlanOffer
 * 
 */
export type PlanOffer = $Result.DefaultSelection<Prisma.$PlanOfferPayload>
/**
 * Model PlanSpec
 * 
 */
export type PlanSpec = $Result.DefaultSelection<Prisma.$PlanSpecPayload>
/**
 * Model PlanDescription
 * 
 */
export type PlanDescription = $Result.DefaultSelection<Prisma.$PlanDescriptionPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model SubscriptionPayment
 * 
 */
export type SubscriptionPayment = $Result.DefaultSelection<Prisma.$SubscriptionPaymentPayload>
/**
 * Model SubscriptionEvent
 * 
 */
export type SubscriptionEvent = $Result.DefaultSelection<Prisma.$SubscriptionEventPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductRenewalHistory
 * 
 */
export type ProductRenewalHistory = $Result.DefaultSelection<Prisma.$ProductRenewalHistoryPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerProductHistory
 * 
 */
export type CustomerProductHistory = $Result.DefaultSelection<Prisma.$CustomerProductHistoryPayload>
/**
 * Model AdminCustomField
 * 
 */
export type AdminCustomField = $Result.DefaultSelection<Prisma.$AdminCustomFieldPayload>
/**
 * Model LoginAudit
 * 
 */
export type LoginAudit = $Result.DefaultSelection<Prisma.$LoginAuditPayload>
/**
 * Model PasswordOtp
 * 
 */
export type PasswordOtp = $Result.DefaultSelection<Prisma.$PasswordOtpPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  team_member: 'team_member',
  partner: 'partner',
  super_admin: 'super_admin',
  sub_admin: 'sub_admin'
};

export type Role = (typeof Role)[keyof typeof Role]


export const OfferType: {
  percentage: 'percentage',
  fixed: 'fixed',
  free_trial: 'free_trial'
};

export type OfferType = (typeof OfferType)[keyof typeof OfferType]


export const SubscriptionStatus: {
  active: 'active',
  canceled: 'canceled',
  past_due: 'past_due',
  free_trial: 'free_trial',
  suspended: 'suspended',
  pending: 'pending',
  expired: 'expired',
  inactive: 'inactive',
  under_review: 'under_review',
  blocked: 'blocked'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const renewPeriod: {
  monthly: 'monthly',
  quarterly: 'quarterly',
  yearly: 'yearly',
  half_yearly: 'half_yearly',
  custom: 'custom'
};

export type renewPeriod = (typeof renewPeriod)[keyof typeof renewPeriod]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type OfferType = $Enums.OfferType

export const OfferType: typeof $Enums.OfferType

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type renewPeriod = $Enums.renewPeriod

export const renewPeriod: typeof $Enums.renewPeriod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SuperAdmins
 * const superAdmins = await prisma.superAdmin.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SuperAdmins
   * const superAdmins = await prisma.superAdmin.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.superAdmin`: Exposes CRUD operations for the **SuperAdmin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SuperAdmins
    * const superAdmins = await prisma.superAdmin.findMany()
    * ```
    */
  get superAdmin(): Prisma.SuperAdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginCredential`: Exposes CRUD operations for the **LoginCredential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginCredentials
    * const loginCredentials = await prisma.loginCredential.findMany()
    * ```
    */
  get loginCredential(): Prisma.LoginCredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planOffer`: Exposes CRUD operations for the **PlanOffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanOffers
    * const planOffers = await prisma.planOffer.findMany()
    * ```
    */
  get planOffer(): Prisma.PlanOfferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planSpec`: Exposes CRUD operations for the **PlanSpec** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanSpecs
    * const planSpecs = await prisma.planSpec.findMany()
    * ```
    */
  get planSpec(): Prisma.PlanSpecDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planDescription`: Exposes CRUD operations for the **PlanDescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlanDescriptions
    * const planDescriptions = await prisma.planDescription.findMany()
    * ```
    */
  get planDescription(): Prisma.PlanDescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPayment`: Exposes CRUD operations for the **SubscriptionPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionPayments
    * const subscriptionPayments = await prisma.subscriptionPayment.findMany()
    * ```
    */
  get subscriptionPayment(): Prisma.SubscriptionPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionEvent`: Exposes CRUD operations for the **SubscriptionEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubscriptionEvents
    * const subscriptionEvents = await prisma.subscriptionEvent.findMany()
    * ```
    */
  get subscriptionEvent(): Prisma.SubscriptionEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productRenewalHistory`: Exposes CRUD operations for the **ProductRenewalHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductRenewalHistories
    * const productRenewalHistories = await prisma.productRenewalHistory.findMany()
    * ```
    */
  get productRenewalHistory(): Prisma.ProductRenewalHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerProductHistory`: Exposes CRUD operations for the **CustomerProductHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerProductHistories
    * const customerProductHistories = await prisma.customerProductHistory.findMany()
    * ```
    */
  get customerProductHistory(): Prisma.CustomerProductHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminCustomField`: Exposes CRUD operations for the **AdminCustomField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminCustomFields
    * const adminCustomFields = await prisma.adminCustomField.findMany()
    * ```
    */
  get adminCustomField(): Prisma.AdminCustomFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.loginAudit`: Exposes CRUD operations for the **LoginAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginAudits
    * const loginAudits = await prisma.loginAudit.findMany()
    * ```
    */
  get loginAudit(): Prisma.LoginAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordOtp`: Exposes CRUD operations for the **PasswordOtp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordOtps
    * const passwordOtps = await prisma.passwordOtp.findMany()
    * ```
    */
  get passwordOtp(): Prisma.PasswordOtpDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SuperAdmin: 'SuperAdmin',
    Admin: 'Admin',
    TeamMember: 'TeamMember',
    Partner: 'Partner',
    LoginCredential: 'LoginCredential',
    Plan: 'Plan',
    PlanOffer: 'PlanOffer',
    PlanSpec: 'PlanSpec',
    PlanDescription: 'PlanDescription',
    Subscription: 'Subscription',
    SubscriptionPayment: 'SubscriptionPayment',
    SubscriptionEvent: 'SubscriptionEvent',
    Product: 'Product',
    ProductRenewalHistory: 'ProductRenewalHistory',
    Customer: 'Customer',
    CustomerProductHistory: 'CustomerProductHistory',
    AdminCustomField: 'AdminCustomField',
    LoginAudit: 'LoginAudit',
    PasswordOtp: 'PasswordOtp'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "superAdmin" | "admin" | "teamMember" | "partner" | "loginCredential" | "plan" | "planOffer" | "planSpec" | "planDescription" | "subscription" | "subscriptionPayment" | "subscriptionEvent" | "product" | "productRenewalHistory" | "customer" | "customerProductHistory" | "adminCustomField" | "loginAudit" | "passwordOtp"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SuperAdmin: {
        payload: Prisma.$SuperAdminPayload<ExtArgs>
        fields: Prisma.SuperAdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SuperAdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SuperAdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findFirst: {
            args: Prisma.SuperAdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SuperAdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          findMany: {
            args: Prisma.SuperAdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          create: {
            args: Prisma.SuperAdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          createMany: {
            args: Prisma.SuperAdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SuperAdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          delete: {
            args: Prisma.SuperAdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          update: {
            args: Prisma.SuperAdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          deleteMany: {
            args: Prisma.SuperAdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SuperAdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SuperAdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>[]
          }
          upsert: {
            args: Prisma.SuperAdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SuperAdminPayload>
          }
          aggregate: {
            args: Prisma.SuperAdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSuperAdmin>
          }
          groupBy: {
            args: Prisma.SuperAdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.SuperAdminCountArgs<ExtArgs>
            result: $Utils.Optional<SuperAdminCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PartnerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      LoginCredential: {
        payload: Prisma.$LoginCredentialPayload<ExtArgs>
        fields: Prisma.LoginCredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginCredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginCredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          findFirst: {
            args: Prisma.LoginCredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginCredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          findMany: {
            args: Prisma.LoginCredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>[]
          }
          create: {
            args: Prisma.LoginCredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          createMany: {
            args: Prisma.LoginCredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginCredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>[]
          }
          delete: {
            args: Prisma.LoginCredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          update: {
            args: Prisma.LoginCredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          deleteMany: {
            args: Prisma.LoginCredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginCredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginCredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>[]
          }
          upsert: {
            args: Prisma.LoginCredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginCredentialPayload>
          }
          aggregate: {
            args: Prisma.LoginCredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginCredential>
          }
          groupBy: {
            args: Prisma.LoginCredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginCredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginCredentialCountArgs<ExtArgs>
            result: $Utils.Optional<LoginCredentialCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      PlanOffer: {
        payload: Prisma.$PlanOfferPayload<ExtArgs>
        fields: Prisma.PlanOfferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanOfferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanOfferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          findFirst: {
            args: Prisma.PlanOfferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanOfferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          findMany: {
            args: Prisma.PlanOfferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>[]
          }
          create: {
            args: Prisma.PlanOfferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          createMany: {
            args: Prisma.PlanOfferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanOfferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>[]
          }
          delete: {
            args: Prisma.PlanOfferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          update: {
            args: Prisma.PlanOfferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          deleteMany: {
            args: Prisma.PlanOfferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanOfferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanOfferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>[]
          }
          upsert: {
            args: Prisma.PlanOfferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanOfferPayload>
          }
          aggregate: {
            args: Prisma.PlanOfferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanOffer>
          }
          groupBy: {
            args: Prisma.PlanOfferGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanOfferGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanOfferCountArgs<ExtArgs>
            result: $Utils.Optional<PlanOfferCountAggregateOutputType> | number
          }
        }
      }
      PlanSpec: {
        payload: Prisma.$PlanSpecPayload<ExtArgs>
        fields: Prisma.PlanSpecFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanSpecFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanSpecFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          findFirst: {
            args: Prisma.PlanSpecFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanSpecFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          findMany: {
            args: Prisma.PlanSpecFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>[]
          }
          create: {
            args: Prisma.PlanSpecCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          createMany: {
            args: Prisma.PlanSpecCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanSpecCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>[]
          }
          delete: {
            args: Prisma.PlanSpecDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          update: {
            args: Prisma.PlanSpecUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          deleteMany: {
            args: Prisma.PlanSpecDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanSpecUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanSpecUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>[]
          }
          upsert: {
            args: Prisma.PlanSpecUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanSpecPayload>
          }
          aggregate: {
            args: Prisma.PlanSpecAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanSpec>
          }
          groupBy: {
            args: Prisma.PlanSpecGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanSpecGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanSpecCountArgs<ExtArgs>
            result: $Utils.Optional<PlanSpecCountAggregateOutputType> | number
          }
        }
      }
      PlanDescription: {
        payload: Prisma.$PlanDescriptionPayload<ExtArgs>
        fields: Prisma.PlanDescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanDescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanDescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          findFirst: {
            args: Prisma.PlanDescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanDescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          findMany: {
            args: Prisma.PlanDescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>[]
          }
          create: {
            args: Prisma.PlanDescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          createMany: {
            args: Prisma.PlanDescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanDescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>[]
          }
          delete: {
            args: Prisma.PlanDescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          update: {
            args: Prisma.PlanDescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PlanDescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanDescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanDescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PlanDescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanDescriptionPayload>
          }
          aggregate: {
            args: Prisma.PlanDescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlanDescription>
          }
          groupBy: {
            args: Prisma.PlanDescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanDescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanDescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PlanDescriptionCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionPayment: {
        payload: Prisma.$SubscriptionPaymentPayload<ExtArgs>
        fields: Prisma.SubscriptionPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          findMany: {
            args: Prisma.SubscriptionPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          create: {
            args: Prisma.SubscriptionPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          createMany: {
            args: Prisma.SubscriptionPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          update: {
            args: Prisma.SubscriptionPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPaymentPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionPayment>
          }
          groupBy: {
            args: Prisma.SubscriptionPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionPaymentCountAggregateOutputType> | number
          }
        }
      }
      SubscriptionEvent: {
        payload: Prisma.$SubscriptionEventPayload<ExtArgs>
        fields: Prisma.SubscriptionEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          findMany: {
            args: Prisma.SubscriptionEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>[]
          }
          create: {
            args: Prisma.SubscriptionEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          createMany: {
            args: Prisma.SubscriptionEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          update: {
            args: Prisma.SubscriptionEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionEventPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptionEvent>
          }
          groupBy: {
            args: Prisma.SubscriptionEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionEventCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionEventCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductRenewalHistory: {
        payload: Prisma.$ProductRenewalHistoryPayload<ExtArgs>
        fields: Prisma.ProductRenewalHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductRenewalHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductRenewalHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          findFirst: {
            args: Prisma.ProductRenewalHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductRenewalHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          findMany: {
            args: Prisma.ProductRenewalHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>[]
          }
          create: {
            args: Prisma.ProductRenewalHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          createMany: {
            args: Prisma.ProductRenewalHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductRenewalHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>[]
          }
          delete: {
            args: Prisma.ProductRenewalHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          update: {
            args: Prisma.ProductRenewalHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ProductRenewalHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductRenewalHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductRenewalHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ProductRenewalHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductRenewalHistoryPayload>
          }
          aggregate: {
            args: Prisma.ProductRenewalHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductRenewalHistory>
          }
          groupBy: {
            args: Prisma.ProductRenewalHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductRenewalHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductRenewalHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ProductRenewalHistoryCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerProductHistory: {
        payload: Prisma.$CustomerProductHistoryPayload<ExtArgs>
        fields: Prisma.CustomerProductHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerProductHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerProductHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          findFirst: {
            args: Prisma.CustomerProductHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerProductHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          findMany: {
            args: Prisma.CustomerProductHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>[]
          }
          create: {
            args: Prisma.CustomerProductHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          createMany: {
            args: Prisma.CustomerProductHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerProductHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>[]
          }
          delete: {
            args: Prisma.CustomerProductHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          update: {
            args: Prisma.CustomerProductHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CustomerProductHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerProductHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerProductHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>[]
          }
          upsert: {
            args: Prisma.CustomerProductHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerProductHistoryPayload>
          }
          aggregate: {
            args: Prisma.CustomerProductHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerProductHistory>
          }
          groupBy: {
            args: Prisma.CustomerProductHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerProductHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerProductHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerProductHistoryCountAggregateOutputType> | number
          }
        }
      }
      AdminCustomField: {
        payload: Prisma.$AdminCustomFieldPayload<ExtArgs>
        fields: Prisma.AdminCustomFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminCustomFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminCustomFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          findFirst: {
            args: Prisma.AdminCustomFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminCustomFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          findMany: {
            args: Prisma.AdminCustomFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>[]
          }
          create: {
            args: Prisma.AdminCustomFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          createMany: {
            args: Prisma.AdminCustomFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminCustomFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>[]
          }
          delete: {
            args: Prisma.AdminCustomFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          update: {
            args: Prisma.AdminCustomFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          deleteMany: {
            args: Prisma.AdminCustomFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminCustomFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminCustomFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>[]
          }
          upsert: {
            args: Prisma.AdminCustomFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminCustomFieldPayload>
          }
          aggregate: {
            args: Prisma.AdminCustomFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminCustomField>
          }
          groupBy: {
            args: Prisma.AdminCustomFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminCustomFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminCustomFieldCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCustomFieldCountAggregateOutputType> | number
          }
        }
      }
      LoginAudit: {
        payload: Prisma.$LoginAuditPayload<ExtArgs>
        fields: Prisma.LoginAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          findFirst: {
            args: Prisma.LoginAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          findMany: {
            args: Prisma.LoginAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>[]
          }
          create: {
            args: Prisma.LoginAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          createMany: {
            args: Prisma.LoginAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>[]
          }
          delete: {
            args: Prisma.LoginAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          update: {
            args: Prisma.LoginAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          deleteMany: {
            args: Prisma.LoginAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LoginAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>[]
          }
          upsert: {
            args: Prisma.LoginAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          aggregate: {
            args: Prisma.LoginAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginAudit>
          }
          groupBy: {
            args: Prisma.LoginAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginAuditCountArgs<ExtArgs>
            result: $Utils.Optional<LoginAuditCountAggregateOutputType> | number
          }
        }
      }
      PasswordOtp: {
        payload: Prisma.$PasswordOtpPayload<ExtArgs>
        fields: Prisma.PasswordOtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordOtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordOtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          findFirst: {
            args: Prisma.PasswordOtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordOtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          findMany: {
            args: Prisma.PasswordOtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>[]
          }
          create: {
            args: Prisma.PasswordOtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          createMany: {
            args: Prisma.PasswordOtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordOtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>[]
          }
          delete: {
            args: Prisma.PasswordOtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          update: {
            args: Prisma.PasswordOtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          deleteMany: {
            args: Prisma.PasswordOtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordOtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordOtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>[]
          }
          upsert: {
            args: Prisma.PasswordOtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordOtpPayload>
          }
          aggregate: {
            args: Prisma.PasswordOtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordOtp>
          }
          groupBy: {
            args: Prisma.PasswordOtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordOtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordOtpCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordOtpCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    superAdmin?: SuperAdminOmit
    admin?: AdminOmit
    teamMember?: TeamMemberOmit
    partner?: PartnerOmit
    loginCredential?: LoginCredentialOmit
    plan?: PlanOmit
    planOffer?: PlanOfferOmit
    planSpec?: PlanSpecOmit
    planDescription?: PlanDescriptionOmit
    subscription?: SubscriptionOmit
    subscriptionPayment?: SubscriptionPaymentOmit
    subscriptionEvent?: SubscriptionEventOmit
    product?: ProductOmit
    productRenewalHistory?: ProductRenewalHistoryOmit
    customer?: CustomerOmit
    customerProductHistory?: CustomerProductHistoryOmit
    adminCustomField?: AdminCustomFieldOmit
    loginAudit?: LoginAuditOmit
    passwordOtp?: PasswordOtpOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SuperAdminCountOutputType
   */

  export type SuperAdminCountOutputType = {
    loginCreds: number
  }

  export type SuperAdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginCreds?: boolean | SuperAdminCountOutputTypeCountLoginCredsArgs
  }

  // Custom InputTypes
  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdminCountOutputType
     */
    select?: SuperAdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SuperAdminCountOutputType without action
   */
  export type SuperAdminCountOutputTypeCountLoginCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginCredentialWhereInput
  }


  /**
   * Count Type AdminCountOutputType
   */

  export type AdminCountOutputType = {
    teamMembers: number
    partners: number
    customers: number
    customFields: number
    products: number
    subscriptions: number
    loginCreds: number
    productHistories: number
  }

  export type AdminCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | AdminCountOutputTypeCountTeamMembersArgs
    partners?: boolean | AdminCountOutputTypeCountPartnersArgs
    customers?: boolean | AdminCountOutputTypeCountCustomersArgs
    customFields?: boolean | AdminCountOutputTypeCountCustomFieldsArgs
    products?: boolean | AdminCountOutputTypeCountProductsArgs
    subscriptions?: boolean | AdminCountOutputTypeCountSubscriptionsArgs
    loginCreds?: boolean | AdminCountOutputTypeCountLoginCredsArgs
    productHistories?: boolean | AdminCountOutputTypeCountProductHistoriesArgs
  }

  // Custom InputTypes
  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCountOutputType
     */
    select?: AdminCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountTeamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountPartnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountCustomFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminCustomFieldWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountLoginCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginCredentialWhereInput
  }

  /**
   * AdminCountOutputType without action
   */
  export type AdminCountOutputTypeCountProductHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductHistoryWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    customers: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | PartnerCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type LoginCredentialCountOutputType
   */

  export type LoginCredentialCountOutputType = {
    loginAudits: number
  }

  export type LoginCredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginAudits?: boolean | LoginCredentialCountOutputTypeCountLoginAuditsArgs
  }

  // Custom InputTypes
  /**
   * LoginCredentialCountOutputType without action
   */
  export type LoginCredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredentialCountOutputType
     */
    select?: LoginCredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LoginCredentialCountOutputType without action
   */
  export type LoginCredentialCountOutputTypeCountLoginAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginAuditWhereInput
  }


  /**
   * Count Type PlanCountOutputType
   */

  export type PlanCountOutputType = {
    offers: number
    specs: number
    descriptions: number
    subscriptions: number
  }

  export type PlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | PlanCountOutputTypeCountOffersArgs
    specs?: boolean | PlanCountOutputTypeCountSpecsArgs
    descriptions?: boolean | PlanCountOutputTypeCountDescriptionsArgs
    subscriptions?: boolean | PlanCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanCountOutputType
     */
    select?: PlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanOfferWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSpecsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSpecWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountDescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanDescriptionWhereInput
  }

  /**
   * PlanCountOutputType without action
   */
  export type PlanCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
    events: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
    events?: boolean | SubscriptionCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPaymentWhereInput
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionEventWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    customerProductHistory: number
    renewalHistory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProductHistory?: boolean | ProductCountOutputTypeCountCustomerProductHistoryArgs
    renewalHistory?: boolean | ProductCountOutputTypeCountRenewalHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCustomerProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductHistoryWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRenewalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRenewalHistoryWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    product: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | CustomerCountOutputTypeCountProductArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductHistoryWhereInput
  }


  /**
   * Count Type CustomerProductHistoryCountOutputType
   */

  export type CustomerProductHistoryCountOutputType = {
    renewals: number
  }

  export type CustomerProductHistoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    renewals?: boolean | CustomerProductHistoryCountOutputTypeCountRenewalsArgs
  }

  // Custom InputTypes
  /**
   * CustomerProductHistoryCountOutputType without action
   */
  export type CustomerProductHistoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistoryCountOutputType
     */
    select?: CustomerProductHistoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerProductHistoryCountOutputType without action
   */
  export type CustomerProductHistoryCountOutputTypeCountRenewalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRenewalHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SuperAdmin
   */

  export type AggregateSuperAdmin = {
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  export type SuperAdminMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SuperAdminCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    passwordHash: number
    contactInfo: number
    address: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SuperAdminMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SuperAdminCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    contactInfo?: true
    address?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SuperAdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmin to aggregate.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SuperAdmins
    **/
    _count?: true | SuperAdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SuperAdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SuperAdminMaxAggregateInputType
  }

  export type GetSuperAdminAggregateType<T extends SuperAdminAggregateArgs> = {
        [P in keyof T & keyof AggregateSuperAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSuperAdmin[P]>
      : GetScalarType<T[P], AggregateSuperAdmin[P]>
  }




  export type SuperAdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SuperAdminWhereInput
    orderBy?: SuperAdminOrderByWithAggregationInput | SuperAdminOrderByWithAggregationInput[]
    by: SuperAdminScalarFieldEnum[] | SuperAdminScalarFieldEnum
    having?: SuperAdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SuperAdminCountAggregateInputType | true
    _min?: SuperAdminMinAggregateInputType
    _max?: SuperAdminMaxAggregateInputType
  }

  export type SuperAdminGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo: JsonValue | null
    address: JsonValue | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: SuperAdminCountAggregateOutputType | null
    _min: SuperAdminMinAggregateOutputType | null
    _max: SuperAdminMaxAggregateOutputType | null
  }

  type GetSuperAdminGroupByPayload<T extends SuperAdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SuperAdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SuperAdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
            : GetScalarType<T[P], SuperAdminGroupByOutputType[P]>
        }
      >
    >


  export type SuperAdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    contactInfo?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    loginCreds?: boolean | SuperAdmin$loginCredsArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    contactInfo?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    contactInfo?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["superAdmin"]>

  export type SuperAdminSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    contactInfo?: boolean
    address?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SuperAdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "email" | "passwordHash" | "contactInfo" | "address" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["superAdmin"]>
  export type SuperAdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginCreds?: boolean | SuperAdmin$loginCredsArgs<ExtArgs>
    _count?: boolean | SuperAdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SuperAdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SuperAdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SuperAdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SuperAdmin"
    objects: {
      loginCreds: Prisma.$LoginCredentialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      passwordHash: string
      contactInfo: Prisma.JsonValue | null
      address: Prisma.JsonValue | null
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["superAdmin"]>
    composites: {}
  }

  type SuperAdminGetPayload<S extends boolean | null | undefined | SuperAdminDefaultArgs> = $Result.GetResult<Prisma.$SuperAdminPayload, S>

  type SuperAdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SuperAdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SuperAdminCountAggregateInputType | true
    }

  export interface SuperAdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SuperAdmin'], meta: { name: 'SuperAdmin' } }
    /**
     * Find zero or one SuperAdmin that matches the filter.
     * @param {SuperAdminFindUniqueArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SuperAdminFindUniqueArgs>(args: SelectSubset<T, SuperAdminFindUniqueArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SuperAdmin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SuperAdminFindUniqueOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SuperAdminFindUniqueOrThrowArgs>(args: SelectSubset<T, SuperAdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SuperAdminFindFirstArgs>(args?: SelectSubset<T, SuperAdminFindFirstArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SuperAdmin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindFirstOrThrowArgs} args - Arguments to find a SuperAdmin
     * @example
     * // Get one SuperAdmin
     * const superAdmin = await prisma.superAdmin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SuperAdminFindFirstOrThrowArgs>(args?: SelectSubset<T, SuperAdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SuperAdmins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany()
     * 
     * // Get first 10 SuperAdmins
     * const superAdmins = await prisma.superAdmin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SuperAdminFindManyArgs>(args?: SelectSubset<T, SuperAdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SuperAdmin.
     * @param {SuperAdminCreateArgs} args - Arguments to create a SuperAdmin.
     * @example
     * // Create one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.create({
     *   data: {
     *     // ... data to create a SuperAdmin
     *   }
     * })
     * 
     */
    create<T extends SuperAdminCreateArgs>(args: SelectSubset<T, SuperAdminCreateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SuperAdmins.
     * @param {SuperAdminCreateManyArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SuperAdminCreateManyArgs>(args?: SelectSubset<T, SuperAdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SuperAdmins and returns the data saved in the database.
     * @param {SuperAdminCreateManyAndReturnArgs} args - Arguments to create many SuperAdmins.
     * @example
     * // Create many SuperAdmins
     * const superAdmin = await prisma.superAdmin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SuperAdminCreateManyAndReturnArgs>(args?: SelectSubset<T, SuperAdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SuperAdmin.
     * @param {SuperAdminDeleteArgs} args - Arguments to delete one SuperAdmin.
     * @example
     * // Delete one SuperAdmin
     * const SuperAdmin = await prisma.superAdmin.delete({
     *   where: {
     *     // ... filter to delete one SuperAdmin
     *   }
     * })
     * 
     */
    delete<T extends SuperAdminDeleteArgs>(args: SelectSubset<T, SuperAdminDeleteArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SuperAdmin.
     * @param {SuperAdminUpdateArgs} args - Arguments to update one SuperAdmin.
     * @example
     * // Update one SuperAdmin
     * const superAdmin = await prisma.superAdmin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SuperAdminUpdateArgs>(args: SelectSubset<T, SuperAdminUpdateArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SuperAdmins.
     * @param {SuperAdminDeleteManyArgs} args - Arguments to filter SuperAdmins to delete.
     * @example
     * // Delete a few SuperAdmins
     * const { count } = await prisma.superAdmin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SuperAdminDeleteManyArgs>(args?: SelectSubset<T, SuperAdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SuperAdminUpdateManyArgs>(args: SelectSubset<T, SuperAdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SuperAdmins and returns the data updated in the database.
     * @param {SuperAdminUpdateManyAndReturnArgs} args - Arguments to update many SuperAdmins.
     * @example
     * // Update many SuperAdmins
     * const superAdmin = await prisma.superAdmin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SuperAdmins and only return the `id`
     * const superAdminWithIdOnly = await prisma.superAdmin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SuperAdminUpdateManyAndReturnArgs>(args: SelectSubset<T, SuperAdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SuperAdmin.
     * @param {SuperAdminUpsertArgs} args - Arguments to update or create a SuperAdmin.
     * @example
     * // Update or create a SuperAdmin
     * const superAdmin = await prisma.superAdmin.upsert({
     *   create: {
     *     // ... data to create a SuperAdmin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SuperAdmin we want to update
     *   }
     * })
     */
    upsert<T extends SuperAdminUpsertArgs>(args: SelectSubset<T, SuperAdminUpsertArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SuperAdmins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminCountArgs} args - Arguments to filter SuperAdmins to count.
     * @example
     * // Count the number of SuperAdmins
     * const count = await prisma.superAdmin.count({
     *   where: {
     *     // ... the filter for the SuperAdmins we want to count
     *   }
     * })
    **/
    count<T extends SuperAdminCountArgs>(
      args?: Subset<T, SuperAdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SuperAdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SuperAdminAggregateArgs>(args: Subset<T, SuperAdminAggregateArgs>): Prisma.PrismaPromise<GetSuperAdminAggregateType<T>>

    /**
     * Group by SuperAdmin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SuperAdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SuperAdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SuperAdminGroupByArgs['orderBy'] }
        : { orderBy?: SuperAdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SuperAdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSuperAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SuperAdmin model
   */
  readonly fields: SuperAdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SuperAdmin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SuperAdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loginCreds<T extends SuperAdmin$loginCredsArgs<ExtArgs> = {}>(args?: Subset<T, SuperAdmin$loginCredsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SuperAdmin model
   */
  interface SuperAdminFieldRefs {
    readonly id: FieldRef<"SuperAdmin", 'String'>
    readonly firstName: FieldRef<"SuperAdmin", 'String'>
    readonly lastName: FieldRef<"SuperAdmin", 'String'>
    readonly email: FieldRef<"SuperAdmin", 'String'>
    readonly passwordHash: FieldRef<"SuperAdmin", 'String'>
    readonly contactInfo: FieldRef<"SuperAdmin", 'Json'>
    readonly address: FieldRef<"SuperAdmin", 'Json'>
    readonly status: FieldRef<"SuperAdmin", 'Boolean'>
    readonly createdAt: FieldRef<"SuperAdmin", 'DateTime'>
    readonly updatedAt: FieldRef<"SuperAdmin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SuperAdmin findUnique
   */
  export type SuperAdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findUniqueOrThrow
   */
  export type SuperAdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin findFirst
   */
  export type SuperAdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findFirstOrThrow
   */
  export type SuperAdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmin to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SuperAdmins.
     */
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin findMany
   */
  export type SuperAdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter, which SuperAdmins to fetch.
     */
    where?: SuperAdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SuperAdmins to fetch.
     */
    orderBy?: SuperAdminOrderByWithRelationInput | SuperAdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SuperAdmins.
     */
    cursor?: SuperAdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SuperAdmins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SuperAdmins.
     */
    skip?: number
    distinct?: SuperAdminScalarFieldEnum | SuperAdminScalarFieldEnum[]
  }

  /**
   * SuperAdmin create
   */
  export type SuperAdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to create a SuperAdmin.
     */
    data: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
  }

  /**
   * SuperAdmin createMany
   */
  export type SuperAdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin createManyAndReturn
   */
  export type SuperAdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to create many SuperAdmins.
     */
    data: SuperAdminCreateManyInput | SuperAdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SuperAdmin update
   */
  export type SuperAdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The data needed to update a SuperAdmin.
     */
    data: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
    /**
     * Choose, which SuperAdmin to update.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin updateMany
   */
  export type SuperAdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin updateManyAndReturn
   */
  export type SuperAdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * The data used to update SuperAdmins.
     */
    data: XOR<SuperAdminUpdateManyMutationInput, SuperAdminUncheckedUpdateManyInput>
    /**
     * Filter which SuperAdmins to update
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to update.
     */
    limit?: number
  }

  /**
   * SuperAdmin upsert
   */
  export type SuperAdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * The filter to search for the SuperAdmin to update in case it exists.
     */
    where: SuperAdminWhereUniqueInput
    /**
     * In case the SuperAdmin found by the `where` argument doesn't exist, create a new SuperAdmin with this data.
     */
    create: XOR<SuperAdminCreateInput, SuperAdminUncheckedCreateInput>
    /**
     * In case the SuperAdmin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SuperAdminUpdateInput, SuperAdminUncheckedUpdateInput>
  }

  /**
   * SuperAdmin delete
   */
  export type SuperAdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    /**
     * Filter which SuperAdmin to delete.
     */
    where: SuperAdminWhereUniqueInput
  }

  /**
   * SuperAdmin deleteMany
   */
  export type SuperAdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SuperAdmins to delete
     */
    where?: SuperAdminWhereInput
    /**
     * Limit how many SuperAdmins to delete.
     */
    limit?: number
  }

  /**
   * SuperAdmin.loginCreds
   */
  export type SuperAdmin$loginCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    where?: LoginCredentialWhereInput
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    cursor?: LoginCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginCredentialScalarFieldEnum | LoginCredentialScalarFieldEnum[]
  }

  /**
   * SuperAdmin without action
   */
  export type SuperAdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    companyName: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    companyName: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    role: number
    firstName: number
    lastName: number
    email: number
    passwordHash: number
    companyName: number
    address: number
    contactInfo: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    companyName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    companyName?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    companyName?: true
    address?: true
    contactInfo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    role: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address: JsonValue | null
    contactInfo: JsonValue | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    address?: boolean
    contactInfo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teamMembers?: boolean | Admin$teamMembersArgs<ExtArgs>
    partners?: boolean | Admin$partnersArgs<ExtArgs>
    customers?: boolean | Admin$customersArgs<ExtArgs>
    customFields?: boolean | Admin$customFieldsArgs<ExtArgs>
    products?: boolean | Admin$productsArgs<ExtArgs>
    subscriptions?: boolean | Admin$subscriptionsArgs<ExtArgs>
    loginCreds?: boolean | Admin$loginCredsArgs<ExtArgs>
    productHistories?: boolean | Admin$productHistoriesArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    address?: boolean
    contactInfo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    address?: boolean
    contactInfo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    companyName?: boolean
    address?: boolean
    contactInfo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "firstName" | "lastName" | "email" | "passwordHash" | "companyName" | "address" | "contactInfo" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMembers?: boolean | Admin$teamMembersArgs<ExtArgs>
    partners?: boolean | Admin$partnersArgs<ExtArgs>
    customers?: boolean | Admin$customersArgs<ExtArgs>
    customFields?: boolean | Admin$customFieldsArgs<ExtArgs>
    products?: boolean | Admin$productsArgs<ExtArgs>
    subscriptions?: boolean | Admin$subscriptionsArgs<ExtArgs>
    loginCreds?: boolean | Admin$loginCredsArgs<ExtArgs>
    productHistories?: boolean | Admin$productHistoriesArgs<ExtArgs>
    _count?: boolean | AdminCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdminIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdminIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      teamMembers: Prisma.$TeamMemberPayload<ExtArgs>[]
      partners: Prisma.$PartnerPayload<ExtArgs>[]
      customers: Prisma.$CustomerPayload<ExtArgs>[]
      customFields: Prisma.$AdminCustomFieldPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      loginCreds: Prisma.$LoginCredentialPayload<ExtArgs>[]
      productHistories: Prisma.$CustomerProductHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      firstName: string
      lastName: string
      email: string
      passwordHash: string
      companyName: string
      address: Prisma.JsonValue | null
      contactInfo: Prisma.JsonValue | null
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admins and returns the data saved in the database.
     * @param {AdminCreateManyAndReturnArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins and returns the data updated in the database.
     * @param {AdminUpdateManyAndReturnArgs} args - Arguments to update many Admins.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admins and only return the `id`
     * const adminWithIdOnly = await prisma.admin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamMembers<T extends Admin$teamMembersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$teamMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    partners<T extends Admin$partnersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$partnersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends Admin$customersArgs<ExtArgs> = {}>(args?: Subset<T, Admin$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customFields<T extends Admin$customFieldsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$customFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Admin$productsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Admin$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    loginCreds<T extends Admin$loginCredsArgs<ExtArgs> = {}>(args?: Subset<T, Admin$loginCredsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    productHistories<T extends Admin$productHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Admin$productHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly role: FieldRef<"Admin", 'Role'>
    readonly firstName: FieldRef<"Admin", 'String'>
    readonly lastName: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly passwordHash: FieldRef<"Admin", 'String'>
    readonly companyName: FieldRef<"Admin", 'String'>
    readonly address: FieldRef<"Admin", 'Json'>
    readonly contactInfo: FieldRef<"Admin", 'Json'>
    readonly status: FieldRef<"Admin", 'Boolean'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin createManyAndReturn
   */
  export type AdminCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin updateManyAndReturn
   */
  export type AdminUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin.teamMembers
   */
  export type Admin$teamMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Admin.partners
   */
  export type Admin$partnersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    cursor?: PartnerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Admin.customers
   */
  export type Admin$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Admin.customFields
   */
  export type Admin$customFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    where?: AdminCustomFieldWhereInput
    orderBy?: AdminCustomFieldOrderByWithRelationInput | AdminCustomFieldOrderByWithRelationInput[]
    cursor?: AdminCustomFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminCustomFieldScalarFieldEnum | AdminCustomFieldScalarFieldEnum[]
  }

  /**
   * Admin.products
   */
  export type Admin$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Admin.subscriptions
   */
  export type Admin$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Admin.loginCreds
   */
  export type Admin$loginCredsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    where?: LoginCredentialWhereInput
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    cursor?: LoginCredentialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginCredentialScalarFieldEnum | LoginCredentialScalarFieldEnum[]
  }

  /**
   * Admin.productHistories
   */
  export type Admin$productHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    where?: CustomerProductHistoryWhereInput
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    cursor?: CustomerProductHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    department: string | null
    position: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    role: $Enums.Role | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    department: string | null
    position: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    adminId: number
    role: number
    firstName: number
    lastName: number
    email: number
    passwordHash: number
    department: number
    position: number
    status: number
    contactInfo: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    department?: true
    position?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    department?: true
    position?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    department?: true
    position?: true
    status?: true
    contactInfo?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    adminId: string
    role: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department: string | null
    position: string | null
    status: boolean
    contactInfo: JsonValue | null
    address: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    department?: boolean
    position?: boolean
    status?: boolean
    contactInfo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    department?: boolean
    position?: boolean
    status?: boolean
    contactInfo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    department?: boolean
    position?: boolean
    status?: boolean
    contactInfo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    adminId?: boolean
    role?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    department?: boolean
    position?: boolean
    status?: boolean
    contactInfo?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "role" | "firstName" | "lastName" | "email" | "passwordHash" | "department" | "position" | "status" | "contactInfo" | "address" | "createdAt" | "updatedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      role: $Enums.Role
      firstName: string
      lastName: string
      email: string
      passwordHash: string
      department: string | null
      position: string | null
      status: boolean
      contactInfo: Prisma.JsonValue | null
      address: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly adminId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'Role'>
    readonly firstName: FieldRef<"TeamMember", 'String'>
    readonly lastName: FieldRef<"TeamMember", 'String'>
    readonly email: FieldRef<"TeamMember", 'String'>
    readonly passwordHash: FieldRef<"TeamMember", 'String'>
    readonly department: FieldRef<"TeamMember", 'String'>
    readonly position: FieldRef<"TeamMember", 'String'>
    readonly status: FieldRef<"TeamMember", 'Boolean'>
    readonly contactInfo: FieldRef<"TeamMember", 'Json'>
    readonly address: FieldRef<"TeamMember", 'Json'>
    readonly createdAt: FieldRef<"TeamMember", 'DateTime'>
    readonly updatedAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    role: $Enums.Role | null
    companyName: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    role: $Enums.Role | null
    companyName: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    adminId: number
    role: number
    companyName: number
    firstName: number
    lastName: number
    contactInfo: number
    address: number
    email: number
    passwordHash: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    companyName?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    companyName?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    adminId?: true
    role?: true
    companyName?: true
    firstName?: true
    lastName?: true
    contactInfo?: true
    address?: true
    email?: true
    passwordHash?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    adminId: string
    role: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo: JsonValue | null
    address: JsonValue | null
    email: string
    passwordHash: string
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    contactInfo?: boolean
    address?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    customers?: boolean | Partner$customersArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    contactInfo?: boolean
    address?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    role?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    contactInfo?: boolean
    address?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    adminId?: boolean
    role?: boolean
    companyName?: boolean
    firstName?: boolean
    lastName?: boolean
    contactInfo?: boolean
    address?: boolean
    email?: boolean
    passwordHash?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PartnerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "role" | "companyName" | "firstName" | "lastName" | "contactInfo" | "address" | "email" | "passwordHash" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["partner"]>
  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    customers?: boolean | Partner$customersArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      role: $Enums.Role
      companyName: string
      firstName: string
      lastName: string
      contactInfo: Prisma.JsonValue | null
      address: Prisma.JsonValue | null
      email: string
      passwordHash: string
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners and returns the data updated in the database.
     * @param {PartnerUpdateManyAndReturnArgs} args - Arguments to update many Partners.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PartnerUpdateManyAndReturnArgs>(args: SelectSubset<T, PartnerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends Partner$customersArgs<ExtArgs> = {}>(args?: Subset<T, Partner$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly adminId: FieldRef<"Partner", 'String'>
    readonly role: FieldRef<"Partner", 'Role'>
    readonly companyName: FieldRef<"Partner", 'String'>
    readonly firstName: FieldRef<"Partner", 'String'>
    readonly lastName: FieldRef<"Partner", 'String'>
    readonly contactInfo: FieldRef<"Partner", 'Json'>
    readonly address: FieldRef<"Partner", 'Json'>
    readonly email: FieldRef<"Partner", 'String'>
    readonly passwordHash: FieldRef<"Partner", 'String'>
    readonly status: FieldRef<"Partner", 'Boolean'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
    readonly updatedAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
  }

  /**
   * Partner updateManyAndReturn
   */
  export type PartnerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
    /**
     * Limit how many Partners to delete.
     */
    limit?: number
  }

  /**
   * Partner.customers
   */
  export type Partner$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model LoginCredential
   */

  export type AggregateLoginCredential = {
    _count: LoginCredentialCountAggregateOutputType | null
    _min: LoginCredentialMinAggregateOutputType | null
    _max: LoginCredentialMaxAggregateOutputType | null
  }

  export type LoginCredentialMinAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    email: string | null
    passwordHash: string | null
    userProfileId: string | null
    adminId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type LoginCredentialMaxAggregateOutputType = {
    id: string | null
    role: $Enums.Role | null
    email: string | null
    passwordHash: string | null
    userProfileId: string | null
    adminId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    superAdminId: string | null
  }

  export type LoginCredentialCountAggregateOutputType = {
    id: number
    role: number
    email: number
    passwordHash: number
    userProfileId: number
    adminId: number
    status: number
    createdAt: number
    updatedAt: number
    superAdminId: number
    _all: number
  }


  export type LoginCredentialMinAggregateInputType = {
    id?: true
    role?: true
    email?: true
    passwordHash?: true
    userProfileId?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type LoginCredentialMaxAggregateInputType = {
    id?: true
    role?: true
    email?: true
    passwordHash?: true
    userProfileId?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
  }

  export type LoginCredentialCountAggregateInputType = {
    id?: true
    role?: true
    email?: true
    passwordHash?: true
    userProfileId?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    superAdminId?: true
    _all?: true
  }

  export type LoginCredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginCredential to aggregate.
     */
    where?: LoginCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginCredentials to fetch.
     */
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginCredentials
    **/
    _count?: true | LoginCredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginCredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginCredentialMaxAggregateInputType
  }

  export type GetLoginCredentialAggregateType<T extends LoginCredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginCredential[P]>
      : GetScalarType<T[P], AggregateLoginCredential[P]>
  }




  export type LoginCredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginCredentialWhereInput
    orderBy?: LoginCredentialOrderByWithAggregationInput | LoginCredentialOrderByWithAggregationInput[]
    by: LoginCredentialScalarFieldEnum[] | LoginCredentialScalarFieldEnum
    having?: LoginCredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginCredentialCountAggregateInputType | true
    _min?: LoginCredentialMinAggregateInputType
    _max?: LoginCredentialMaxAggregateInputType
  }

  export type LoginCredentialGroupByOutputType = {
    id: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId: string | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    superAdminId: string | null
    _count: LoginCredentialCountAggregateOutputType | null
    _min: LoginCredentialMinAggregateOutputType | null
    _max: LoginCredentialMaxAggregateOutputType | null
  }

  type GetLoginCredentialGroupByPayload<T extends LoginCredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginCredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginCredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginCredentialGroupByOutputType[P]>
            : GetScalarType<T[P], LoginCredentialGroupByOutputType[P]>
        }
      >
    >


  export type LoginCredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    passwordHash?: boolean
    userProfileId?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
    loginAudits?: boolean | LoginCredential$loginAuditsArgs<ExtArgs>
    _count?: boolean | LoginCredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginCredential"]>

  export type LoginCredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    passwordHash?: boolean
    userProfileId?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
  }, ExtArgs["result"]["loginCredential"]>

  export type LoginCredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    email?: boolean
    passwordHash?: boolean
    userProfileId?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
  }, ExtArgs["result"]["loginCredential"]>

  export type LoginCredentialSelectScalar = {
    id?: boolean
    role?: boolean
    email?: boolean
    passwordHash?: boolean
    userProfileId?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    superAdminId?: boolean
  }

  export type LoginCredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "email" | "passwordHash" | "userProfileId" | "adminId" | "status" | "createdAt" | "updatedAt" | "superAdminId", ExtArgs["result"]["loginCredential"]>
  export type LoginCredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
    loginAudits?: boolean | LoginCredential$loginAuditsArgs<ExtArgs>
    _count?: boolean | LoginCredentialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LoginCredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
  }
  export type LoginCredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | LoginCredential$adminArgs<ExtArgs>
    superadmin?: boolean | LoginCredential$superadminArgs<ExtArgs>
  }

  export type $LoginCredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginCredential"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs> | null
      superadmin: Prisma.$SuperAdminPayload<ExtArgs> | null
      loginAudits: Prisma.$LoginAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: $Enums.Role
      email: string
      passwordHash: string
      userProfileId: string
      adminId: string | null
      status: boolean
      createdAt: Date
      updatedAt: Date
      superAdminId: string | null
    }, ExtArgs["result"]["loginCredential"]>
    composites: {}
  }

  type LoginCredentialGetPayload<S extends boolean | null | undefined | LoginCredentialDefaultArgs> = $Result.GetResult<Prisma.$LoginCredentialPayload, S>

  type LoginCredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginCredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginCredentialCountAggregateInputType | true
    }

  export interface LoginCredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginCredential'], meta: { name: 'LoginCredential' } }
    /**
     * Find zero or one LoginCredential that matches the filter.
     * @param {LoginCredentialFindUniqueArgs} args - Arguments to find a LoginCredential
     * @example
     * // Get one LoginCredential
     * const loginCredential = await prisma.loginCredential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginCredentialFindUniqueArgs>(args: SelectSubset<T, LoginCredentialFindUniqueArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginCredential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginCredentialFindUniqueOrThrowArgs} args - Arguments to find a LoginCredential
     * @example
     * // Get one LoginCredential
     * const loginCredential = await prisma.loginCredential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginCredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginCredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginCredential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialFindFirstArgs} args - Arguments to find a LoginCredential
     * @example
     * // Get one LoginCredential
     * const loginCredential = await prisma.loginCredential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginCredentialFindFirstArgs>(args?: SelectSubset<T, LoginCredentialFindFirstArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginCredential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialFindFirstOrThrowArgs} args - Arguments to find a LoginCredential
     * @example
     * // Get one LoginCredential
     * const loginCredential = await prisma.loginCredential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginCredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginCredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginCredentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginCredentials
     * const loginCredentials = await prisma.loginCredential.findMany()
     * 
     * // Get first 10 LoginCredentials
     * const loginCredentials = await prisma.loginCredential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginCredentialWithIdOnly = await prisma.loginCredential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginCredentialFindManyArgs>(args?: SelectSubset<T, LoginCredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginCredential.
     * @param {LoginCredentialCreateArgs} args - Arguments to create a LoginCredential.
     * @example
     * // Create one LoginCredential
     * const LoginCredential = await prisma.loginCredential.create({
     *   data: {
     *     // ... data to create a LoginCredential
     *   }
     * })
     * 
     */
    create<T extends LoginCredentialCreateArgs>(args: SelectSubset<T, LoginCredentialCreateArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginCredentials.
     * @param {LoginCredentialCreateManyArgs} args - Arguments to create many LoginCredentials.
     * @example
     * // Create many LoginCredentials
     * const loginCredential = await prisma.loginCredential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginCredentialCreateManyArgs>(args?: SelectSubset<T, LoginCredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginCredentials and returns the data saved in the database.
     * @param {LoginCredentialCreateManyAndReturnArgs} args - Arguments to create many LoginCredentials.
     * @example
     * // Create many LoginCredentials
     * const loginCredential = await prisma.loginCredential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginCredentials and only return the `id`
     * const loginCredentialWithIdOnly = await prisma.loginCredential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginCredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginCredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginCredential.
     * @param {LoginCredentialDeleteArgs} args - Arguments to delete one LoginCredential.
     * @example
     * // Delete one LoginCredential
     * const LoginCredential = await prisma.loginCredential.delete({
     *   where: {
     *     // ... filter to delete one LoginCredential
     *   }
     * })
     * 
     */
    delete<T extends LoginCredentialDeleteArgs>(args: SelectSubset<T, LoginCredentialDeleteArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginCredential.
     * @param {LoginCredentialUpdateArgs} args - Arguments to update one LoginCredential.
     * @example
     * // Update one LoginCredential
     * const loginCredential = await prisma.loginCredential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginCredentialUpdateArgs>(args: SelectSubset<T, LoginCredentialUpdateArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginCredentials.
     * @param {LoginCredentialDeleteManyArgs} args - Arguments to filter LoginCredentials to delete.
     * @example
     * // Delete a few LoginCredentials
     * const { count } = await prisma.loginCredential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginCredentialDeleteManyArgs>(args?: SelectSubset<T, LoginCredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginCredentials
     * const loginCredential = await prisma.loginCredential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginCredentialUpdateManyArgs>(args: SelectSubset<T, LoginCredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginCredentials and returns the data updated in the database.
     * @param {LoginCredentialUpdateManyAndReturnArgs} args - Arguments to update many LoginCredentials.
     * @example
     * // Update many LoginCredentials
     * const loginCredential = await prisma.loginCredential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginCredentials and only return the `id`
     * const loginCredentialWithIdOnly = await prisma.loginCredential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginCredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginCredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginCredential.
     * @param {LoginCredentialUpsertArgs} args - Arguments to update or create a LoginCredential.
     * @example
     * // Update or create a LoginCredential
     * const loginCredential = await prisma.loginCredential.upsert({
     *   create: {
     *     // ... data to create a LoginCredential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginCredential we want to update
     *   }
     * })
     */
    upsert<T extends LoginCredentialUpsertArgs>(args: SelectSubset<T, LoginCredentialUpsertArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginCredentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialCountArgs} args - Arguments to filter LoginCredentials to count.
     * @example
     * // Count the number of LoginCredentials
     * const count = await prisma.loginCredential.count({
     *   where: {
     *     // ... the filter for the LoginCredentials we want to count
     *   }
     * })
    **/
    count<T extends LoginCredentialCountArgs>(
      args?: Subset<T, LoginCredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginCredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginCredentialAggregateArgs>(args: Subset<T, LoginCredentialAggregateArgs>): Prisma.PrismaPromise<GetLoginCredentialAggregateType<T>>

    /**
     * Group by LoginCredential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginCredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginCredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginCredentialGroupByArgs['orderBy'] }
        : { orderBy?: LoginCredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginCredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginCredential model
   */
  readonly fields: LoginCredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginCredential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginCredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends LoginCredential$adminArgs<ExtArgs> = {}>(args?: Subset<T, LoginCredential$adminArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    superadmin<T extends LoginCredential$superadminArgs<ExtArgs> = {}>(args?: Subset<T, LoginCredential$superadminArgs<ExtArgs>>): Prisma__SuperAdminClient<$Result.GetResult<Prisma.$SuperAdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    loginAudits<T extends LoginCredential$loginAuditsArgs<ExtArgs> = {}>(args?: Subset<T, LoginCredential$loginAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginCredential model
   */
  interface LoginCredentialFieldRefs {
    readonly id: FieldRef<"LoginCredential", 'String'>
    readonly role: FieldRef<"LoginCredential", 'Role'>
    readonly email: FieldRef<"LoginCredential", 'String'>
    readonly passwordHash: FieldRef<"LoginCredential", 'String'>
    readonly userProfileId: FieldRef<"LoginCredential", 'String'>
    readonly adminId: FieldRef<"LoginCredential", 'String'>
    readonly status: FieldRef<"LoginCredential", 'Boolean'>
    readonly createdAt: FieldRef<"LoginCredential", 'DateTime'>
    readonly updatedAt: FieldRef<"LoginCredential", 'DateTime'>
    readonly superAdminId: FieldRef<"LoginCredential", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LoginCredential findUnique
   */
  export type LoginCredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LoginCredential to fetch.
     */
    where: LoginCredentialWhereUniqueInput
  }

  /**
   * LoginCredential findUniqueOrThrow
   */
  export type LoginCredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LoginCredential to fetch.
     */
    where: LoginCredentialWhereUniqueInput
  }

  /**
   * LoginCredential findFirst
   */
  export type LoginCredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LoginCredential to fetch.
     */
    where?: LoginCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginCredentials to fetch.
     */
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginCredentials.
     */
    cursor?: LoginCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginCredentials.
     */
    distinct?: LoginCredentialScalarFieldEnum | LoginCredentialScalarFieldEnum[]
  }

  /**
   * LoginCredential findFirstOrThrow
   */
  export type LoginCredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LoginCredential to fetch.
     */
    where?: LoginCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginCredentials to fetch.
     */
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginCredentials.
     */
    cursor?: LoginCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginCredentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginCredentials.
     */
    distinct?: LoginCredentialScalarFieldEnum | LoginCredentialScalarFieldEnum[]
  }

  /**
   * LoginCredential findMany
   */
  export type LoginCredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter, which LoginCredentials to fetch.
     */
    where?: LoginCredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginCredentials to fetch.
     */
    orderBy?: LoginCredentialOrderByWithRelationInput | LoginCredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginCredentials.
     */
    cursor?: LoginCredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginCredentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginCredentials.
     */
    skip?: number
    distinct?: LoginCredentialScalarFieldEnum | LoginCredentialScalarFieldEnum[]
  }

  /**
   * LoginCredential create
   */
  export type LoginCredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginCredential.
     */
    data: XOR<LoginCredentialCreateInput, LoginCredentialUncheckedCreateInput>
  }

  /**
   * LoginCredential createMany
   */
  export type LoginCredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginCredentials.
     */
    data: LoginCredentialCreateManyInput | LoginCredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginCredential createManyAndReturn
   */
  export type LoginCredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * The data used to create many LoginCredentials.
     */
    data: LoginCredentialCreateManyInput | LoginCredentialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginCredential update
   */
  export type LoginCredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginCredential.
     */
    data: XOR<LoginCredentialUpdateInput, LoginCredentialUncheckedUpdateInput>
    /**
     * Choose, which LoginCredential to update.
     */
    where: LoginCredentialWhereUniqueInput
  }

  /**
   * LoginCredential updateMany
   */
  export type LoginCredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginCredentials.
     */
    data: XOR<LoginCredentialUpdateManyMutationInput, LoginCredentialUncheckedUpdateManyInput>
    /**
     * Filter which LoginCredentials to update
     */
    where?: LoginCredentialWhereInput
    /**
     * Limit how many LoginCredentials to update.
     */
    limit?: number
  }

  /**
   * LoginCredential updateManyAndReturn
   */
  export type LoginCredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * The data used to update LoginCredentials.
     */
    data: XOR<LoginCredentialUpdateManyMutationInput, LoginCredentialUncheckedUpdateManyInput>
    /**
     * Filter which LoginCredentials to update
     */
    where?: LoginCredentialWhereInput
    /**
     * Limit how many LoginCredentials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginCredential upsert
   */
  export type LoginCredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginCredential to update in case it exists.
     */
    where: LoginCredentialWhereUniqueInput
    /**
     * In case the LoginCredential found by the `where` argument doesn't exist, create a new LoginCredential with this data.
     */
    create: XOR<LoginCredentialCreateInput, LoginCredentialUncheckedCreateInput>
    /**
     * In case the LoginCredential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginCredentialUpdateInput, LoginCredentialUncheckedUpdateInput>
  }

  /**
   * LoginCredential delete
   */
  export type LoginCredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
    /**
     * Filter which LoginCredential to delete.
     */
    where: LoginCredentialWhereUniqueInput
  }

  /**
   * LoginCredential deleteMany
   */
  export type LoginCredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginCredentials to delete
     */
    where?: LoginCredentialWhereInput
    /**
     * Limit how many LoginCredentials to delete.
     */
    limit?: number
  }

  /**
   * LoginCredential.admin
   */
  export type LoginCredential$adminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * LoginCredential.superadmin
   */
  export type LoginCredential$superadminArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SuperAdmin
     */
    select?: SuperAdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SuperAdmin
     */
    omit?: SuperAdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SuperAdminInclude<ExtArgs> | null
    where?: SuperAdminWhereInput
  }

  /**
   * LoginCredential.loginAudits
   */
  export type LoginCredential$loginAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    where?: LoginAuditWhereInput
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    cursor?: LoginAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginCredential without action
   */
  export type LoginCredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginCredential
     */
    select?: LoginCredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginCredential
     */
    omit?: LoginCredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginCredentialInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    duration: string | null
    price: number | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    duration: string | null
    price: number | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    duration: number
    price: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    duration?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    duration?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    duration?: true
    price?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    duration: string
    price: number
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    duration?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    offers?: boolean | Plan$offersArgs<ExtArgs>
    specs?: boolean | Plan$specsArgs<ExtArgs>
    descriptions?: boolean | Plan$descriptionsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    duration?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    duration?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    duration?: boolean
    price?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "duration" | "price" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>
  export type PlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | Plan$offersArgs<ExtArgs>
    specs?: boolean | Plan$specsArgs<ExtArgs>
    descriptions?: boolean | Plan$descriptionsArgs<ExtArgs>
    subscriptions?: boolean | Plan$subscriptionsArgs<ExtArgs>
    _count?: boolean | PlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {
      offers: Prisma.$PlanOfferPayload<ExtArgs>[]
      specs: Prisma.$PlanSpecPayload<ExtArgs>[]
      descriptions: Prisma.$PlanDescriptionPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      duration: string
      price: number
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offers<T extends Plan$offersArgs<ExtArgs> = {}>(args?: Subset<T, Plan$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    specs<T extends Plan$specsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$specsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    descriptions<T extends Plan$descriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$descriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Plan$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Plan$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly duration: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Float'>
    readonly status: FieldRef<"Plan", 'Boolean'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan.offers
   */
  export type Plan$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    where?: PlanOfferWhereInput
    orderBy?: PlanOfferOrderByWithRelationInput | PlanOfferOrderByWithRelationInput[]
    cursor?: PlanOfferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanOfferScalarFieldEnum | PlanOfferScalarFieldEnum[]
  }

  /**
   * Plan.specs
   */
  export type Plan$specsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    where?: PlanSpecWhereInput
    orderBy?: PlanSpecOrderByWithRelationInput | PlanSpecOrderByWithRelationInput[]
    cursor?: PlanSpecWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanSpecScalarFieldEnum | PlanSpecScalarFieldEnum[]
  }

  /**
   * Plan.descriptions
   */
  export type Plan$descriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    where?: PlanDescriptionWhereInput
    orderBy?: PlanDescriptionOrderByWithRelationInput | PlanDescriptionOrderByWithRelationInput[]
    cursor?: PlanDescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlanDescriptionScalarFieldEnum | PlanDescriptionScalarFieldEnum[]
  }

  /**
   * Plan.subscriptions
   */
  export type Plan$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanInclude<ExtArgs> | null
  }


  /**
   * Model PlanOffer
   */

  export type AggregatePlanOffer = {
    _count: PlanOfferCountAggregateOutputType | null
    _avg: PlanOfferAvgAggregateOutputType | null
    _sum: PlanOfferSumAggregateOutputType | null
    _min: PlanOfferMinAggregateOutputType | null
    _max: PlanOfferMaxAggregateOutputType | null
  }

  export type PlanOfferAvgAggregateOutputType = {
    value: number | null
  }

  export type PlanOfferSumAggregateOutputType = {
    value: number | null
  }

  export type PlanOfferMinAggregateOutputType = {
    id: string | null
    planId: string | null
    offerType: $Enums.OfferType | null
    value: number | null
    startsAt: Date | null
    endsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanOfferMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    offerType: $Enums.OfferType | null
    value: number | null
    startsAt: Date | null
    endsAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanOfferCountAggregateOutputType = {
    id: number
    planId: number
    offerType: number
    value: number
    startsAt: number
    endsAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanOfferAvgAggregateInputType = {
    value?: true
  }

  export type PlanOfferSumAggregateInputType = {
    value?: true
  }

  export type PlanOfferMinAggregateInputType = {
    id?: true
    planId?: true
    offerType?: true
    value?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanOfferMaxAggregateInputType = {
    id?: true
    planId?: true
    offerType?: true
    value?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanOfferCountAggregateInputType = {
    id?: true
    planId?: true
    offerType?: true
    value?: true
    startsAt?: true
    endsAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanOfferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanOffer to aggregate.
     */
    where?: PlanOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOffers to fetch.
     */
    orderBy?: PlanOfferOrderByWithRelationInput | PlanOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanOffers
    **/
    _count?: true | PlanOfferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanOfferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanOfferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanOfferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanOfferMaxAggregateInputType
  }

  export type GetPlanOfferAggregateType<T extends PlanOfferAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanOffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanOffer[P]>
      : GetScalarType<T[P], AggregatePlanOffer[P]>
  }




  export type PlanOfferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanOfferWhereInput
    orderBy?: PlanOfferOrderByWithAggregationInput | PlanOfferOrderByWithAggregationInput[]
    by: PlanOfferScalarFieldEnum[] | PlanOfferScalarFieldEnum
    having?: PlanOfferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanOfferCountAggregateInputType | true
    _avg?: PlanOfferAvgAggregateInputType
    _sum?: PlanOfferSumAggregateInputType
    _min?: PlanOfferMinAggregateInputType
    _max?: PlanOfferMaxAggregateInputType
  }

  export type PlanOfferGroupByOutputType = {
    id: string
    planId: string
    offerType: $Enums.OfferType
    value: number | null
    startsAt: Date | null
    endsAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PlanOfferCountAggregateOutputType | null
    _avg: PlanOfferAvgAggregateOutputType | null
    _sum: PlanOfferSumAggregateOutputType | null
    _min: PlanOfferMinAggregateOutputType | null
    _max: PlanOfferMaxAggregateOutputType | null
  }

  type GetPlanOfferGroupByPayload<T extends PlanOfferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanOfferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanOfferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanOfferGroupByOutputType[P]>
            : GetScalarType<T[P], PlanOfferGroupByOutputType[P]>
        }
      >
    >


  export type PlanOfferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    offerType?: boolean
    value?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planOffer"]>

  export type PlanOfferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    offerType?: boolean
    value?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planOffer"]>

  export type PlanOfferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    offerType?: boolean
    value?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planOffer"]>

  export type PlanOfferSelectScalar = {
    id?: boolean
    planId?: boolean
    offerType?: boolean
    value?: boolean
    startsAt?: boolean
    endsAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOfferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "offerType" | "value" | "startsAt" | "endsAt" | "createdAt" | "updatedAt", ExtArgs["result"]["planOffer"]>
  export type PlanOfferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanOfferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanOfferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanOfferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanOffer"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      offerType: $Enums.OfferType
      value: number | null
      startsAt: Date | null
      endsAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planOffer"]>
    composites: {}
  }

  type PlanOfferGetPayload<S extends boolean | null | undefined | PlanOfferDefaultArgs> = $Result.GetResult<Prisma.$PlanOfferPayload, S>

  type PlanOfferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanOfferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanOfferCountAggregateInputType | true
    }

  export interface PlanOfferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanOffer'], meta: { name: 'PlanOffer' } }
    /**
     * Find zero or one PlanOffer that matches the filter.
     * @param {PlanOfferFindUniqueArgs} args - Arguments to find a PlanOffer
     * @example
     * // Get one PlanOffer
     * const planOffer = await prisma.planOffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanOfferFindUniqueArgs>(args: SelectSubset<T, PlanOfferFindUniqueArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanOffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanOfferFindUniqueOrThrowArgs} args - Arguments to find a PlanOffer
     * @example
     * // Get one PlanOffer
     * const planOffer = await prisma.planOffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanOfferFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanOfferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanOffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferFindFirstArgs} args - Arguments to find a PlanOffer
     * @example
     * // Get one PlanOffer
     * const planOffer = await prisma.planOffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanOfferFindFirstArgs>(args?: SelectSubset<T, PlanOfferFindFirstArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanOffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferFindFirstOrThrowArgs} args - Arguments to find a PlanOffer
     * @example
     * // Get one PlanOffer
     * const planOffer = await prisma.planOffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanOfferFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanOfferFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanOffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanOffers
     * const planOffers = await prisma.planOffer.findMany()
     * 
     * // Get first 10 PlanOffers
     * const planOffers = await prisma.planOffer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planOfferWithIdOnly = await prisma.planOffer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanOfferFindManyArgs>(args?: SelectSubset<T, PlanOfferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanOffer.
     * @param {PlanOfferCreateArgs} args - Arguments to create a PlanOffer.
     * @example
     * // Create one PlanOffer
     * const PlanOffer = await prisma.planOffer.create({
     *   data: {
     *     // ... data to create a PlanOffer
     *   }
     * })
     * 
     */
    create<T extends PlanOfferCreateArgs>(args: SelectSubset<T, PlanOfferCreateArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanOffers.
     * @param {PlanOfferCreateManyArgs} args - Arguments to create many PlanOffers.
     * @example
     * // Create many PlanOffers
     * const planOffer = await prisma.planOffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanOfferCreateManyArgs>(args?: SelectSubset<T, PlanOfferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanOffers and returns the data saved in the database.
     * @param {PlanOfferCreateManyAndReturnArgs} args - Arguments to create many PlanOffers.
     * @example
     * // Create many PlanOffers
     * const planOffer = await prisma.planOffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanOffers and only return the `id`
     * const planOfferWithIdOnly = await prisma.planOffer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanOfferCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanOfferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanOffer.
     * @param {PlanOfferDeleteArgs} args - Arguments to delete one PlanOffer.
     * @example
     * // Delete one PlanOffer
     * const PlanOffer = await prisma.planOffer.delete({
     *   where: {
     *     // ... filter to delete one PlanOffer
     *   }
     * })
     * 
     */
    delete<T extends PlanOfferDeleteArgs>(args: SelectSubset<T, PlanOfferDeleteArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanOffer.
     * @param {PlanOfferUpdateArgs} args - Arguments to update one PlanOffer.
     * @example
     * // Update one PlanOffer
     * const planOffer = await prisma.planOffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanOfferUpdateArgs>(args: SelectSubset<T, PlanOfferUpdateArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanOffers.
     * @param {PlanOfferDeleteManyArgs} args - Arguments to filter PlanOffers to delete.
     * @example
     * // Delete a few PlanOffers
     * const { count } = await prisma.planOffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanOfferDeleteManyArgs>(args?: SelectSubset<T, PlanOfferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanOffers
     * const planOffer = await prisma.planOffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanOfferUpdateManyArgs>(args: SelectSubset<T, PlanOfferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanOffers and returns the data updated in the database.
     * @param {PlanOfferUpdateManyAndReturnArgs} args - Arguments to update many PlanOffers.
     * @example
     * // Update many PlanOffers
     * const planOffer = await prisma.planOffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanOffers and only return the `id`
     * const planOfferWithIdOnly = await prisma.planOffer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanOfferUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanOfferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanOffer.
     * @param {PlanOfferUpsertArgs} args - Arguments to update or create a PlanOffer.
     * @example
     * // Update or create a PlanOffer
     * const planOffer = await prisma.planOffer.upsert({
     *   create: {
     *     // ... data to create a PlanOffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanOffer we want to update
     *   }
     * })
     */
    upsert<T extends PlanOfferUpsertArgs>(args: SelectSubset<T, PlanOfferUpsertArgs<ExtArgs>>): Prisma__PlanOfferClient<$Result.GetResult<Prisma.$PlanOfferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanOffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferCountArgs} args - Arguments to filter PlanOffers to count.
     * @example
     * // Count the number of PlanOffers
     * const count = await prisma.planOffer.count({
     *   where: {
     *     // ... the filter for the PlanOffers we want to count
     *   }
     * })
    **/
    count<T extends PlanOfferCountArgs>(
      args?: Subset<T, PlanOfferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanOfferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanOfferAggregateArgs>(args: Subset<T, PlanOfferAggregateArgs>): Prisma.PrismaPromise<GetPlanOfferAggregateType<T>>

    /**
     * Group by PlanOffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanOfferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanOfferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanOfferGroupByArgs['orderBy'] }
        : { orderBy?: PlanOfferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanOfferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanOfferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanOffer model
   */
  readonly fields: PlanOfferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanOffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanOfferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanOffer model
   */
  interface PlanOfferFieldRefs {
    readonly id: FieldRef<"PlanOffer", 'String'>
    readonly planId: FieldRef<"PlanOffer", 'String'>
    readonly offerType: FieldRef<"PlanOffer", 'OfferType'>
    readonly value: FieldRef<"PlanOffer", 'Float'>
    readonly startsAt: FieldRef<"PlanOffer", 'DateTime'>
    readonly endsAt: FieldRef<"PlanOffer", 'DateTime'>
    readonly createdAt: FieldRef<"PlanOffer", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanOffer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanOffer findUnique
   */
  export type PlanOfferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter, which PlanOffer to fetch.
     */
    where: PlanOfferWhereUniqueInput
  }

  /**
   * PlanOffer findUniqueOrThrow
   */
  export type PlanOfferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter, which PlanOffer to fetch.
     */
    where: PlanOfferWhereUniqueInput
  }

  /**
   * PlanOffer findFirst
   */
  export type PlanOfferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter, which PlanOffer to fetch.
     */
    where?: PlanOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOffers to fetch.
     */
    orderBy?: PlanOfferOrderByWithRelationInput | PlanOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanOffers.
     */
    cursor?: PlanOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanOffers.
     */
    distinct?: PlanOfferScalarFieldEnum | PlanOfferScalarFieldEnum[]
  }

  /**
   * PlanOffer findFirstOrThrow
   */
  export type PlanOfferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter, which PlanOffer to fetch.
     */
    where?: PlanOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOffers to fetch.
     */
    orderBy?: PlanOfferOrderByWithRelationInput | PlanOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanOffers.
     */
    cursor?: PlanOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanOffers.
     */
    distinct?: PlanOfferScalarFieldEnum | PlanOfferScalarFieldEnum[]
  }

  /**
   * PlanOffer findMany
   */
  export type PlanOfferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter, which PlanOffers to fetch.
     */
    where?: PlanOfferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanOffers to fetch.
     */
    orderBy?: PlanOfferOrderByWithRelationInput | PlanOfferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanOffers.
     */
    cursor?: PlanOfferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanOffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanOffers.
     */
    skip?: number
    distinct?: PlanOfferScalarFieldEnum | PlanOfferScalarFieldEnum[]
  }

  /**
   * PlanOffer create
   */
  export type PlanOfferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanOffer.
     */
    data: XOR<PlanOfferCreateInput, PlanOfferUncheckedCreateInput>
  }

  /**
   * PlanOffer createMany
   */
  export type PlanOfferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanOffers.
     */
    data: PlanOfferCreateManyInput | PlanOfferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanOffer createManyAndReturn
   */
  export type PlanOfferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * The data used to create many PlanOffers.
     */
    data: PlanOfferCreateManyInput | PlanOfferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanOffer update
   */
  export type PlanOfferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanOffer.
     */
    data: XOR<PlanOfferUpdateInput, PlanOfferUncheckedUpdateInput>
    /**
     * Choose, which PlanOffer to update.
     */
    where: PlanOfferWhereUniqueInput
  }

  /**
   * PlanOffer updateMany
   */
  export type PlanOfferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanOffers.
     */
    data: XOR<PlanOfferUpdateManyMutationInput, PlanOfferUncheckedUpdateManyInput>
    /**
     * Filter which PlanOffers to update
     */
    where?: PlanOfferWhereInput
    /**
     * Limit how many PlanOffers to update.
     */
    limit?: number
  }

  /**
   * PlanOffer updateManyAndReturn
   */
  export type PlanOfferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * The data used to update PlanOffers.
     */
    data: XOR<PlanOfferUpdateManyMutationInput, PlanOfferUncheckedUpdateManyInput>
    /**
     * Filter which PlanOffers to update
     */
    where?: PlanOfferWhereInput
    /**
     * Limit how many PlanOffers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanOffer upsert
   */
  export type PlanOfferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanOffer to update in case it exists.
     */
    where: PlanOfferWhereUniqueInput
    /**
     * In case the PlanOffer found by the `where` argument doesn't exist, create a new PlanOffer with this data.
     */
    create: XOR<PlanOfferCreateInput, PlanOfferUncheckedCreateInput>
    /**
     * In case the PlanOffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanOfferUpdateInput, PlanOfferUncheckedUpdateInput>
  }

  /**
   * PlanOffer delete
   */
  export type PlanOfferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
    /**
     * Filter which PlanOffer to delete.
     */
    where: PlanOfferWhereUniqueInput
  }

  /**
   * PlanOffer deleteMany
   */
  export type PlanOfferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanOffers to delete
     */
    where?: PlanOfferWhereInput
    /**
     * Limit how many PlanOffers to delete.
     */
    limit?: number
  }

  /**
   * PlanOffer without action
   */
  export type PlanOfferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanOffer
     */
    select?: PlanOfferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanOffer
     */
    omit?: PlanOfferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanOfferInclude<ExtArgs> | null
  }


  /**
   * Model PlanSpec
   */

  export type AggregatePlanSpec = {
    _count: PlanSpecCountAggregateOutputType | null
    _min: PlanSpecMinAggregateOutputType | null
    _max: PlanSpecMaxAggregateOutputType | null
  }

  export type PlanSpecMinAggregateOutputType = {
    id: string | null
    planId: string | null
    specName: string | null
    specValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanSpecMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    specName: string | null
    specValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanSpecCountAggregateOutputType = {
    id: number
    planId: number
    specName: number
    specValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanSpecMinAggregateInputType = {
    id?: true
    planId?: true
    specName?: true
    specValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanSpecMaxAggregateInputType = {
    id?: true
    planId?: true
    specName?: true
    specValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanSpecCountAggregateInputType = {
    id?: true
    planId?: true
    specName?: true
    specValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanSpecAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSpec to aggregate.
     */
    where?: PlanSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSpecs to fetch.
     */
    orderBy?: PlanSpecOrderByWithRelationInput | PlanSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanSpecs
    **/
    _count?: true | PlanSpecCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanSpecMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanSpecMaxAggregateInputType
  }

  export type GetPlanSpecAggregateType<T extends PlanSpecAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanSpec]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanSpec[P]>
      : GetScalarType<T[P], AggregatePlanSpec[P]>
  }




  export type PlanSpecGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanSpecWhereInput
    orderBy?: PlanSpecOrderByWithAggregationInput | PlanSpecOrderByWithAggregationInput[]
    by: PlanSpecScalarFieldEnum[] | PlanSpecScalarFieldEnum
    having?: PlanSpecScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanSpecCountAggregateInputType | true
    _min?: PlanSpecMinAggregateInputType
    _max?: PlanSpecMaxAggregateInputType
  }

  export type PlanSpecGroupByOutputType = {
    id: string
    planId: string
    specName: string
    specValue: string
    createdAt: Date
    updatedAt: Date
    _count: PlanSpecCountAggregateOutputType | null
    _min: PlanSpecMinAggregateOutputType | null
    _max: PlanSpecMaxAggregateOutputType | null
  }

  type GetPlanSpecGroupByPayload<T extends PlanSpecGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanSpecGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanSpecGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanSpecGroupByOutputType[P]>
            : GetScalarType<T[P], PlanSpecGroupByOutputType[P]>
        }
      >
    >


  export type PlanSpecSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    specName?: boolean
    specValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSpec"]>

  export type PlanSpecSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    specName?: boolean
    specValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSpec"]>

  export type PlanSpecSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    specName?: boolean
    specValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planSpec"]>

  export type PlanSpecSelectScalar = {
    id?: boolean
    planId?: boolean
    specName?: boolean
    specValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanSpecOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "specName" | "specValue" | "createdAt" | "updatedAt", ExtArgs["result"]["planSpec"]>
  export type PlanSpecInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanSpecIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanSpecIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanSpecPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanSpec"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      specName: string
      specValue: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planSpec"]>
    composites: {}
  }

  type PlanSpecGetPayload<S extends boolean | null | undefined | PlanSpecDefaultArgs> = $Result.GetResult<Prisma.$PlanSpecPayload, S>

  type PlanSpecCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanSpecFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanSpecCountAggregateInputType | true
    }

  export interface PlanSpecDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanSpec'], meta: { name: 'PlanSpec' } }
    /**
     * Find zero or one PlanSpec that matches the filter.
     * @param {PlanSpecFindUniqueArgs} args - Arguments to find a PlanSpec
     * @example
     * // Get one PlanSpec
     * const planSpec = await prisma.planSpec.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanSpecFindUniqueArgs>(args: SelectSubset<T, PlanSpecFindUniqueArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanSpec that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanSpecFindUniqueOrThrowArgs} args - Arguments to find a PlanSpec
     * @example
     * // Get one PlanSpec
     * const planSpec = await prisma.planSpec.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanSpecFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanSpecFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSpec that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecFindFirstArgs} args - Arguments to find a PlanSpec
     * @example
     * // Get one PlanSpec
     * const planSpec = await prisma.planSpec.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanSpecFindFirstArgs>(args?: SelectSubset<T, PlanSpecFindFirstArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanSpec that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecFindFirstOrThrowArgs} args - Arguments to find a PlanSpec
     * @example
     * // Get one PlanSpec
     * const planSpec = await prisma.planSpec.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanSpecFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanSpecFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanSpecs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanSpecs
     * const planSpecs = await prisma.planSpec.findMany()
     * 
     * // Get first 10 PlanSpecs
     * const planSpecs = await prisma.planSpec.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planSpecWithIdOnly = await prisma.planSpec.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanSpecFindManyArgs>(args?: SelectSubset<T, PlanSpecFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanSpec.
     * @param {PlanSpecCreateArgs} args - Arguments to create a PlanSpec.
     * @example
     * // Create one PlanSpec
     * const PlanSpec = await prisma.planSpec.create({
     *   data: {
     *     // ... data to create a PlanSpec
     *   }
     * })
     * 
     */
    create<T extends PlanSpecCreateArgs>(args: SelectSubset<T, PlanSpecCreateArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanSpecs.
     * @param {PlanSpecCreateManyArgs} args - Arguments to create many PlanSpecs.
     * @example
     * // Create many PlanSpecs
     * const planSpec = await prisma.planSpec.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanSpecCreateManyArgs>(args?: SelectSubset<T, PlanSpecCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanSpecs and returns the data saved in the database.
     * @param {PlanSpecCreateManyAndReturnArgs} args - Arguments to create many PlanSpecs.
     * @example
     * // Create many PlanSpecs
     * const planSpec = await prisma.planSpec.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanSpecs and only return the `id`
     * const planSpecWithIdOnly = await prisma.planSpec.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanSpecCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanSpecCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanSpec.
     * @param {PlanSpecDeleteArgs} args - Arguments to delete one PlanSpec.
     * @example
     * // Delete one PlanSpec
     * const PlanSpec = await prisma.planSpec.delete({
     *   where: {
     *     // ... filter to delete one PlanSpec
     *   }
     * })
     * 
     */
    delete<T extends PlanSpecDeleteArgs>(args: SelectSubset<T, PlanSpecDeleteArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanSpec.
     * @param {PlanSpecUpdateArgs} args - Arguments to update one PlanSpec.
     * @example
     * // Update one PlanSpec
     * const planSpec = await prisma.planSpec.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanSpecUpdateArgs>(args: SelectSubset<T, PlanSpecUpdateArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanSpecs.
     * @param {PlanSpecDeleteManyArgs} args - Arguments to filter PlanSpecs to delete.
     * @example
     * // Delete a few PlanSpecs
     * const { count } = await prisma.planSpec.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanSpecDeleteManyArgs>(args?: SelectSubset<T, PlanSpecDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanSpecs
     * const planSpec = await prisma.planSpec.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanSpecUpdateManyArgs>(args: SelectSubset<T, PlanSpecUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanSpecs and returns the data updated in the database.
     * @param {PlanSpecUpdateManyAndReturnArgs} args - Arguments to update many PlanSpecs.
     * @example
     * // Update many PlanSpecs
     * const planSpec = await prisma.planSpec.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanSpecs and only return the `id`
     * const planSpecWithIdOnly = await prisma.planSpec.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanSpecUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanSpecUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanSpec.
     * @param {PlanSpecUpsertArgs} args - Arguments to update or create a PlanSpec.
     * @example
     * // Update or create a PlanSpec
     * const planSpec = await prisma.planSpec.upsert({
     *   create: {
     *     // ... data to create a PlanSpec
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanSpec we want to update
     *   }
     * })
     */
    upsert<T extends PlanSpecUpsertArgs>(args: SelectSubset<T, PlanSpecUpsertArgs<ExtArgs>>): Prisma__PlanSpecClient<$Result.GetResult<Prisma.$PlanSpecPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanSpecs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecCountArgs} args - Arguments to filter PlanSpecs to count.
     * @example
     * // Count the number of PlanSpecs
     * const count = await prisma.planSpec.count({
     *   where: {
     *     // ... the filter for the PlanSpecs we want to count
     *   }
     * })
    **/
    count<T extends PlanSpecCountArgs>(
      args?: Subset<T, PlanSpecCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanSpecCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanSpecAggregateArgs>(args: Subset<T, PlanSpecAggregateArgs>): Prisma.PrismaPromise<GetPlanSpecAggregateType<T>>

    /**
     * Group by PlanSpec.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanSpecGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanSpecGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanSpecGroupByArgs['orderBy'] }
        : { orderBy?: PlanSpecGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanSpecGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanSpecGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanSpec model
   */
  readonly fields: PlanSpecFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanSpec.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanSpecClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanSpec model
   */
  interface PlanSpecFieldRefs {
    readonly id: FieldRef<"PlanSpec", 'String'>
    readonly planId: FieldRef<"PlanSpec", 'String'>
    readonly specName: FieldRef<"PlanSpec", 'String'>
    readonly specValue: FieldRef<"PlanSpec", 'String'>
    readonly createdAt: FieldRef<"PlanSpec", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanSpec", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanSpec findUnique
   */
  export type PlanSpecFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter, which PlanSpec to fetch.
     */
    where: PlanSpecWhereUniqueInput
  }

  /**
   * PlanSpec findUniqueOrThrow
   */
  export type PlanSpecFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter, which PlanSpec to fetch.
     */
    where: PlanSpecWhereUniqueInput
  }

  /**
   * PlanSpec findFirst
   */
  export type PlanSpecFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter, which PlanSpec to fetch.
     */
    where?: PlanSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSpecs to fetch.
     */
    orderBy?: PlanSpecOrderByWithRelationInput | PlanSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSpecs.
     */
    cursor?: PlanSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSpecs.
     */
    distinct?: PlanSpecScalarFieldEnum | PlanSpecScalarFieldEnum[]
  }

  /**
   * PlanSpec findFirstOrThrow
   */
  export type PlanSpecFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter, which PlanSpec to fetch.
     */
    where?: PlanSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSpecs to fetch.
     */
    orderBy?: PlanSpecOrderByWithRelationInput | PlanSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanSpecs.
     */
    cursor?: PlanSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSpecs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanSpecs.
     */
    distinct?: PlanSpecScalarFieldEnum | PlanSpecScalarFieldEnum[]
  }

  /**
   * PlanSpec findMany
   */
  export type PlanSpecFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter, which PlanSpecs to fetch.
     */
    where?: PlanSpecWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanSpecs to fetch.
     */
    orderBy?: PlanSpecOrderByWithRelationInput | PlanSpecOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanSpecs.
     */
    cursor?: PlanSpecWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanSpecs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanSpecs.
     */
    skip?: number
    distinct?: PlanSpecScalarFieldEnum | PlanSpecScalarFieldEnum[]
  }

  /**
   * PlanSpec create
   */
  export type PlanSpecCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanSpec.
     */
    data: XOR<PlanSpecCreateInput, PlanSpecUncheckedCreateInput>
  }

  /**
   * PlanSpec createMany
   */
  export type PlanSpecCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanSpecs.
     */
    data: PlanSpecCreateManyInput | PlanSpecCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanSpec createManyAndReturn
   */
  export type PlanSpecCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * The data used to create many PlanSpecs.
     */
    data: PlanSpecCreateManyInput | PlanSpecCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSpec update
   */
  export type PlanSpecUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanSpec.
     */
    data: XOR<PlanSpecUpdateInput, PlanSpecUncheckedUpdateInput>
    /**
     * Choose, which PlanSpec to update.
     */
    where: PlanSpecWhereUniqueInput
  }

  /**
   * PlanSpec updateMany
   */
  export type PlanSpecUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanSpecs.
     */
    data: XOR<PlanSpecUpdateManyMutationInput, PlanSpecUncheckedUpdateManyInput>
    /**
     * Filter which PlanSpecs to update
     */
    where?: PlanSpecWhereInput
    /**
     * Limit how many PlanSpecs to update.
     */
    limit?: number
  }

  /**
   * PlanSpec updateManyAndReturn
   */
  export type PlanSpecUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * The data used to update PlanSpecs.
     */
    data: XOR<PlanSpecUpdateManyMutationInput, PlanSpecUncheckedUpdateManyInput>
    /**
     * Filter which PlanSpecs to update
     */
    where?: PlanSpecWhereInput
    /**
     * Limit how many PlanSpecs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanSpec upsert
   */
  export type PlanSpecUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanSpec to update in case it exists.
     */
    where: PlanSpecWhereUniqueInput
    /**
     * In case the PlanSpec found by the `where` argument doesn't exist, create a new PlanSpec with this data.
     */
    create: XOR<PlanSpecCreateInput, PlanSpecUncheckedCreateInput>
    /**
     * In case the PlanSpec was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanSpecUpdateInput, PlanSpecUncheckedUpdateInput>
  }

  /**
   * PlanSpec delete
   */
  export type PlanSpecDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
    /**
     * Filter which PlanSpec to delete.
     */
    where: PlanSpecWhereUniqueInput
  }

  /**
   * PlanSpec deleteMany
   */
  export type PlanSpecDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanSpecs to delete
     */
    where?: PlanSpecWhereInput
    /**
     * Limit how many PlanSpecs to delete.
     */
    limit?: number
  }

  /**
   * PlanSpec without action
   */
  export type PlanSpecDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanSpec
     */
    select?: PlanSpecSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanSpec
     */
    omit?: PlanSpecOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanSpecInclude<ExtArgs> | null
  }


  /**
   * Model PlanDescription
   */

  export type AggregatePlanDescription = {
    _count: PlanDescriptionCountAggregateOutputType | null
    _min: PlanDescriptionMinAggregateOutputType | null
    _max: PlanDescriptionMaxAggregateOutputType | null
  }

  export type PlanDescriptionMinAggregateOutputType = {
    id: string | null
    planId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanDescriptionMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanDescriptionCountAggregateOutputType = {
    id: number
    planId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanDescriptionMinAggregateInputType = {
    id?: true
    planId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanDescriptionMaxAggregateInputType = {
    id?: true
    planId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanDescriptionCountAggregateInputType = {
    id?: true
    planId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanDescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanDescription to aggregate.
     */
    where?: PlanDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanDescriptions to fetch.
     */
    orderBy?: PlanDescriptionOrderByWithRelationInput | PlanDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlanDescriptions
    **/
    _count?: true | PlanDescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanDescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanDescriptionMaxAggregateInputType
  }

  export type GetPlanDescriptionAggregateType<T extends PlanDescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePlanDescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlanDescription[P]>
      : GetScalarType<T[P], AggregatePlanDescription[P]>
  }




  export type PlanDescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanDescriptionWhereInput
    orderBy?: PlanDescriptionOrderByWithAggregationInput | PlanDescriptionOrderByWithAggregationInput[]
    by: PlanDescriptionScalarFieldEnum[] | PlanDescriptionScalarFieldEnum
    having?: PlanDescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanDescriptionCountAggregateInputType | true
    _min?: PlanDescriptionMinAggregateInputType
    _max?: PlanDescriptionMaxAggregateInputType
  }

  export type PlanDescriptionGroupByOutputType = {
    id: string
    planId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: PlanDescriptionCountAggregateOutputType | null
    _min: PlanDescriptionMinAggregateOutputType | null
    _max: PlanDescriptionMaxAggregateOutputType | null
  }

  type GetPlanDescriptionGroupByPayload<T extends PlanDescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanDescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanDescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanDescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PlanDescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PlanDescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planDescription"]>

  export type PlanDescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planDescription"]>

  export type PlanDescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planDescription"]>

  export type PlanDescriptionSelectScalar = {
    id?: boolean
    planId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanDescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "planId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["planDescription"]>
  export type PlanDescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanDescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type PlanDescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $PlanDescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlanDescription"
    objects: {
      plan: Prisma.$PlanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["planDescription"]>
    composites: {}
  }

  type PlanDescriptionGetPayload<S extends boolean | null | undefined | PlanDescriptionDefaultArgs> = $Result.GetResult<Prisma.$PlanDescriptionPayload, S>

  type PlanDescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanDescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanDescriptionCountAggregateInputType | true
    }

  export interface PlanDescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlanDescription'], meta: { name: 'PlanDescription' } }
    /**
     * Find zero or one PlanDescription that matches the filter.
     * @param {PlanDescriptionFindUniqueArgs} args - Arguments to find a PlanDescription
     * @example
     * // Get one PlanDescription
     * const planDescription = await prisma.planDescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanDescriptionFindUniqueArgs>(args: SelectSubset<T, PlanDescriptionFindUniqueArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlanDescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanDescriptionFindUniqueOrThrowArgs} args - Arguments to find a PlanDescription
     * @example
     * // Get one PlanDescription
     * const planDescription = await prisma.planDescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanDescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanDescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanDescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionFindFirstArgs} args - Arguments to find a PlanDescription
     * @example
     * // Get one PlanDescription
     * const planDescription = await prisma.planDescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanDescriptionFindFirstArgs>(args?: SelectSubset<T, PlanDescriptionFindFirstArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlanDescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionFindFirstOrThrowArgs} args - Arguments to find a PlanDescription
     * @example
     * // Get one PlanDescription
     * const planDescription = await prisma.planDescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanDescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanDescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlanDescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlanDescriptions
     * const planDescriptions = await prisma.planDescription.findMany()
     * 
     * // Get first 10 PlanDescriptions
     * const planDescriptions = await prisma.planDescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planDescriptionWithIdOnly = await prisma.planDescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanDescriptionFindManyArgs>(args?: SelectSubset<T, PlanDescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlanDescription.
     * @param {PlanDescriptionCreateArgs} args - Arguments to create a PlanDescription.
     * @example
     * // Create one PlanDescription
     * const PlanDescription = await prisma.planDescription.create({
     *   data: {
     *     // ... data to create a PlanDescription
     *   }
     * })
     * 
     */
    create<T extends PlanDescriptionCreateArgs>(args: SelectSubset<T, PlanDescriptionCreateArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlanDescriptions.
     * @param {PlanDescriptionCreateManyArgs} args - Arguments to create many PlanDescriptions.
     * @example
     * // Create many PlanDescriptions
     * const planDescription = await prisma.planDescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanDescriptionCreateManyArgs>(args?: SelectSubset<T, PlanDescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlanDescriptions and returns the data saved in the database.
     * @param {PlanDescriptionCreateManyAndReturnArgs} args - Arguments to create many PlanDescriptions.
     * @example
     * // Create many PlanDescriptions
     * const planDescription = await prisma.planDescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlanDescriptions and only return the `id`
     * const planDescriptionWithIdOnly = await prisma.planDescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanDescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanDescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlanDescription.
     * @param {PlanDescriptionDeleteArgs} args - Arguments to delete one PlanDescription.
     * @example
     * // Delete one PlanDescription
     * const PlanDescription = await prisma.planDescription.delete({
     *   where: {
     *     // ... filter to delete one PlanDescription
     *   }
     * })
     * 
     */
    delete<T extends PlanDescriptionDeleteArgs>(args: SelectSubset<T, PlanDescriptionDeleteArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlanDescription.
     * @param {PlanDescriptionUpdateArgs} args - Arguments to update one PlanDescription.
     * @example
     * // Update one PlanDescription
     * const planDescription = await prisma.planDescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanDescriptionUpdateArgs>(args: SelectSubset<T, PlanDescriptionUpdateArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlanDescriptions.
     * @param {PlanDescriptionDeleteManyArgs} args - Arguments to filter PlanDescriptions to delete.
     * @example
     * // Delete a few PlanDescriptions
     * const { count } = await prisma.planDescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDescriptionDeleteManyArgs>(args?: SelectSubset<T, PlanDescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlanDescriptions
     * const planDescription = await prisma.planDescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanDescriptionUpdateManyArgs>(args: SelectSubset<T, PlanDescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlanDescriptions and returns the data updated in the database.
     * @param {PlanDescriptionUpdateManyAndReturnArgs} args - Arguments to update many PlanDescriptions.
     * @example
     * // Update many PlanDescriptions
     * const planDescription = await prisma.planDescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlanDescriptions and only return the `id`
     * const planDescriptionWithIdOnly = await prisma.planDescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanDescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanDescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlanDescription.
     * @param {PlanDescriptionUpsertArgs} args - Arguments to update or create a PlanDescription.
     * @example
     * // Update or create a PlanDescription
     * const planDescription = await prisma.planDescription.upsert({
     *   create: {
     *     // ... data to create a PlanDescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlanDescription we want to update
     *   }
     * })
     */
    upsert<T extends PlanDescriptionUpsertArgs>(args: SelectSubset<T, PlanDescriptionUpsertArgs<ExtArgs>>): Prisma__PlanDescriptionClient<$Result.GetResult<Prisma.$PlanDescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlanDescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionCountArgs} args - Arguments to filter PlanDescriptions to count.
     * @example
     * // Count the number of PlanDescriptions
     * const count = await prisma.planDescription.count({
     *   where: {
     *     // ... the filter for the PlanDescriptions we want to count
     *   }
     * })
    **/
    count<T extends PlanDescriptionCountArgs>(
      args?: Subset<T, PlanDescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanDescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlanDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanDescriptionAggregateArgs>(args: Subset<T, PlanDescriptionAggregateArgs>): Prisma.PrismaPromise<GetPlanDescriptionAggregateType<T>>

    /**
     * Group by PlanDescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanDescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanDescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanDescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PlanDescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanDescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanDescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlanDescription model
   */
  readonly fields: PlanDescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlanDescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanDescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlanDescription model
   */
  interface PlanDescriptionFieldRefs {
    readonly id: FieldRef<"PlanDescription", 'String'>
    readonly planId: FieldRef<"PlanDescription", 'String'>
    readonly content: FieldRef<"PlanDescription", 'String'>
    readonly createdAt: FieldRef<"PlanDescription", 'DateTime'>
    readonly updatedAt: FieldRef<"PlanDescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlanDescription findUnique
   */
  export type PlanDescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanDescription to fetch.
     */
    where: PlanDescriptionWhereUniqueInput
  }

  /**
   * PlanDescription findUniqueOrThrow
   */
  export type PlanDescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanDescription to fetch.
     */
    where: PlanDescriptionWhereUniqueInput
  }

  /**
   * PlanDescription findFirst
   */
  export type PlanDescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanDescription to fetch.
     */
    where?: PlanDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanDescriptions to fetch.
     */
    orderBy?: PlanDescriptionOrderByWithRelationInput | PlanDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanDescriptions.
     */
    cursor?: PlanDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanDescriptions.
     */
    distinct?: PlanDescriptionScalarFieldEnum | PlanDescriptionScalarFieldEnum[]
  }

  /**
   * PlanDescription findFirstOrThrow
   */
  export type PlanDescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanDescription to fetch.
     */
    where?: PlanDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanDescriptions to fetch.
     */
    orderBy?: PlanDescriptionOrderByWithRelationInput | PlanDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlanDescriptions.
     */
    cursor?: PlanDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanDescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlanDescriptions.
     */
    distinct?: PlanDescriptionScalarFieldEnum | PlanDescriptionScalarFieldEnum[]
  }

  /**
   * PlanDescription findMany
   */
  export type PlanDescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter, which PlanDescriptions to fetch.
     */
    where?: PlanDescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlanDescriptions to fetch.
     */
    orderBy?: PlanDescriptionOrderByWithRelationInput | PlanDescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlanDescriptions.
     */
    cursor?: PlanDescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlanDescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlanDescriptions.
     */
    skip?: number
    distinct?: PlanDescriptionScalarFieldEnum | PlanDescriptionScalarFieldEnum[]
  }

  /**
   * PlanDescription create
   */
  export type PlanDescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PlanDescription.
     */
    data: XOR<PlanDescriptionCreateInput, PlanDescriptionUncheckedCreateInput>
  }

  /**
   * PlanDescription createMany
   */
  export type PlanDescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlanDescriptions.
     */
    data: PlanDescriptionCreateManyInput | PlanDescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlanDescription createManyAndReturn
   */
  export type PlanDescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many PlanDescriptions.
     */
    data: PlanDescriptionCreateManyInput | PlanDescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanDescription update
   */
  export type PlanDescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PlanDescription.
     */
    data: XOR<PlanDescriptionUpdateInput, PlanDescriptionUncheckedUpdateInput>
    /**
     * Choose, which PlanDescription to update.
     */
    where: PlanDescriptionWhereUniqueInput
  }

  /**
   * PlanDescription updateMany
   */
  export type PlanDescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlanDescriptions.
     */
    data: XOR<PlanDescriptionUpdateManyMutationInput, PlanDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which PlanDescriptions to update
     */
    where?: PlanDescriptionWhereInput
    /**
     * Limit how many PlanDescriptions to update.
     */
    limit?: number
  }

  /**
   * PlanDescription updateManyAndReturn
   */
  export type PlanDescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * The data used to update PlanDescriptions.
     */
    data: XOR<PlanDescriptionUpdateManyMutationInput, PlanDescriptionUncheckedUpdateManyInput>
    /**
     * Filter which PlanDescriptions to update
     */
    where?: PlanDescriptionWhereInput
    /**
     * Limit how many PlanDescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlanDescription upsert
   */
  export type PlanDescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PlanDescription to update in case it exists.
     */
    where: PlanDescriptionWhereUniqueInput
    /**
     * In case the PlanDescription found by the `where` argument doesn't exist, create a new PlanDescription with this data.
     */
    create: XOR<PlanDescriptionCreateInput, PlanDescriptionUncheckedCreateInput>
    /**
     * In case the PlanDescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanDescriptionUpdateInput, PlanDescriptionUncheckedUpdateInput>
  }

  /**
   * PlanDescription delete
   */
  export type PlanDescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
    /**
     * Filter which PlanDescription to delete.
     */
    where: PlanDescriptionWhereUniqueInput
  }

  /**
   * PlanDescription deleteMany
   */
  export type PlanDescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlanDescriptions to delete
     */
    where?: PlanDescriptionWhereInput
    /**
     * Limit how many PlanDescriptions to delete.
     */
    limit?: number
  }

  /**
   * PlanDescription without action
   */
  export type PlanDescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlanDescription
     */
    select?: PlanDescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlanDescription
     */
    omit?: PlanDescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlanDescriptionInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startsAt: Date | null
    endsAt: Date | null
    renewedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    planId: string | null
    status: $Enums.SubscriptionStatus | null
    startsAt: Date | null
    endsAt: Date | null
    renewedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    adminId: number
    planId: number
    status: number
    startsAt: number
    endsAt: number
    renewedAt: number
    cancelledAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionMinAggregateInputType = {
    id?: true
    adminId?: true
    planId?: true
    status?: true
    startsAt?: true
    endsAt?: true
    renewedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    adminId?: true
    planId?: true
    status?: true
    startsAt?: true
    endsAt?: true
    renewedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    adminId?: true
    planId?: true
    status?: true
    startsAt?: true
    endsAt?: true
    renewedAt?: true
    cancelledAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    adminId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date
    endsAt: Date | null
    renewedAt: Date | null
    cancelledAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    planId?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    renewedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    events?: boolean | Subscription$eventsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    planId?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    renewedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    planId?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    renewedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    adminId?: boolean
    planId?: boolean
    status?: boolean
    startsAt?: boolean
    endsAt?: boolean
    renewedAt?: boolean
    cancelledAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "planId" | "status" | "startsAt" | "endsAt" | "renewedAt" | "cancelledAt" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    events?: boolean | Subscription$eventsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    plan?: boolean | PlanDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      plan: Prisma.$PlanPayload<ExtArgs>
      payments: Prisma.$SubscriptionPaymentPayload<ExtArgs>[]
      events: Prisma.$SubscriptionEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      planId: string
      status: $Enums.SubscriptionStatus
      startsAt: Date
      endsAt: Date | null
      renewedAt: Date | null
      cancelledAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plan<T extends PlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlanDefaultArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Subscription$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly adminId: FieldRef<"Subscription", 'String'>
    readonly planId: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly startsAt: FieldRef<"Subscription", 'DateTime'>
    readonly endsAt: FieldRef<"Subscription", 'DateTime'>
    readonly renewedAt: FieldRef<"Subscription", 'DateTime'>
    readonly cancelledAt: FieldRef<"Subscription", 'DateTime'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    where?: SubscriptionPaymentWhereInput
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    cursor?: SubscriptionPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * Subscription.events
   */
  export type Subscription$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    where?: SubscriptionEventWhereInput
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    cursor?: SubscriptionEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionPayment
   */

  export type AggregateSubscriptionPayment = {
    _count: SubscriptionPaymentCountAggregateOutputType | null
    _avg: SubscriptionPaymentAvgAggregateOutputType | null
    _sum: SubscriptionPaymentSumAggregateOutputType | null
    _min: SubscriptionPaymentMinAggregateOutputType | null
    _max: SubscriptionPaymentMaxAggregateOutputType | null
  }

  export type SubscriptionPaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionPaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type SubscriptionPaymentMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    paidAt: Date | null
    status: string | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPaymentMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    paidAt: Date | null
    status: string | null
    paymentMethod: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionPaymentCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    currency: number
    paidAt: number
    status: number
    paymentMethod: number
    gatewayResponse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type SubscriptionPaymentSumAggregateInputType = {
    amount?: true
  }

  export type SubscriptionPaymentMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    paidAt?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPaymentMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    paidAt?: true
    status?: true
    paymentMethod?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionPaymentCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    paidAt?: true
    status?: true
    paymentMethod?: true
    gatewayResponse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPayment to aggregate.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionPayments
    **/
    _count?: true | SubscriptionPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionPaymentMaxAggregateInputType
  }

  export type GetSubscriptionPaymentAggregateType<T extends SubscriptionPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPayment[P]>
      : GetScalarType<T[P], AggregateSubscriptionPayment[P]>
  }




  export type SubscriptionPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionPaymentWhereInput
    orderBy?: SubscriptionPaymentOrderByWithAggregationInput | SubscriptionPaymentOrderByWithAggregationInput[]
    by: SubscriptionPaymentScalarFieldEnum[] | SubscriptionPaymentScalarFieldEnum
    having?: SubscriptionPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionPaymentCountAggregateInputType | true
    _avg?: SubscriptionPaymentAvgAggregateInputType
    _sum?: SubscriptionPaymentSumAggregateInputType
    _min?: SubscriptionPaymentMinAggregateInputType
    _max?: SubscriptionPaymentMaxAggregateInputType
  }

  export type SubscriptionPaymentGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: number
    currency: string
    paidAt: Date
    status: string
    paymentMethod: string | null
    gatewayResponse: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionPaymentCountAggregateOutputType | null
    _avg: SubscriptionPaymentAvgAggregateOutputType | null
    _sum: SubscriptionPaymentSumAggregateOutputType | null
    _min: SubscriptionPaymentMinAggregateOutputType | null
    _max: SubscriptionPaymentMaxAggregateOutputType | null
  }

  type GetSubscriptionPaymentGroupByPayload<T extends SubscriptionPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionPaymentGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    paidAt?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    paidAt?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    paidAt?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionPayment"]>

  export type SubscriptionPaymentSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    paidAt?: boolean
    status?: boolean
    paymentMethod?: boolean
    gatewayResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "amount" | "currency" | "paidAt" | "status" | "paymentMethod" | "gatewayResponse" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionPayment"]>
  export type SubscriptionPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionPayment"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: number
      currency: string
      paidAt: Date
      status: string
      paymentMethod: string | null
      gatewayResponse: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionPayment"]>
    composites: {}
  }

  type SubscriptionPaymentGetPayload<S extends boolean | null | undefined | SubscriptionPaymentDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPaymentPayload, S>

  type SubscriptionPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionPaymentCountAggregateInputType | true
    }

  export interface SubscriptionPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPayment'], meta: { name: 'SubscriptionPayment' } }
    /**
     * Find zero or one SubscriptionPayment that matches the filter.
     * @param {SubscriptionPaymentFindUniqueArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPaymentFindUniqueArgs>(args: SelectSubset<T, SubscriptionPaymentFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPaymentFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindFirstArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPaymentFindFirstArgs>(args?: SelectSubset<T, SubscriptionPaymentFindFirstArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPayment
     * @example
     * // Get one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPayments
     * const subscriptionPayments = await prisma.subscriptionPayment.findMany()
     * 
     * // Get first 10 SubscriptionPayments
     * const subscriptionPayments = await prisma.subscriptionPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionPaymentFindManyArgs>(args?: SelectSubset<T, SubscriptionPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionPayment.
     * @param {SubscriptionPaymentCreateArgs} args - Arguments to create a SubscriptionPayment.
     * @example
     * // Create one SubscriptionPayment
     * const SubscriptionPayment = await prisma.subscriptionPayment.create({
     *   data: {
     *     // ... data to create a SubscriptionPayment
     *   }
     * })
     * 
     */
    create<T extends SubscriptionPaymentCreateArgs>(args: SelectSubset<T, SubscriptionPaymentCreateArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionPayments.
     * @param {SubscriptionPaymentCreateManyArgs} args - Arguments to create many SubscriptionPayments.
     * @example
     * // Create many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionPaymentCreateManyArgs>(args?: SelectSubset<T, SubscriptionPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionPayments and returns the data saved in the database.
     * @param {SubscriptionPaymentCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPayments.
     * @example
     * // Create many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionPayments and only return the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionPayment.
     * @param {SubscriptionPaymentDeleteArgs} args - Arguments to delete one SubscriptionPayment.
     * @example
     * // Delete one SubscriptionPayment
     * const SubscriptionPayment = await prisma.subscriptionPayment.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPayment
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionPaymentDeleteArgs>(args: SelectSubset<T, SubscriptionPaymentDeleteArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionPayment.
     * @param {SubscriptionPaymentUpdateArgs} args - Arguments to update one SubscriptionPayment.
     * @example
     * // Update one SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionPaymentUpdateArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionPayments.
     * @param {SubscriptionPaymentDeleteManyArgs} args - Arguments to filter SubscriptionPayments to delete.
     * @example
     * // Delete a few SubscriptionPayments
     * const { count } = await prisma.subscriptionPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionPaymentDeleteManyArgs>(args?: SelectSubset<T, SubscriptionPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionPaymentUpdateManyArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionPayments and returns the data updated in the database.
     * @param {SubscriptionPaymentUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPayments.
     * @example
     * // Update many SubscriptionPayments
     * const subscriptionPayment = await prisma.subscriptionPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionPayments and only return the `id`
     * const subscriptionPaymentWithIdOnly = await prisma.subscriptionPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionPayment.
     * @param {SubscriptionPaymentUpsertArgs} args - Arguments to update or create a SubscriptionPayment.
     * @example
     * // Update or create a SubscriptionPayment
     * const subscriptionPayment = await prisma.subscriptionPayment.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPayment we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPaymentUpsertArgs>(args: SelectSubset<T, SubscriptionPaymentUpsertArgs<ExtArgs>>): Prisma__SubscriptionPaymentClient<$Result.GetResult<Prisma.$SubscriptionPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentCountArgs} args - Arguments to filter SubscriptionPayments to count.
     * @example
     * // Count the number of SubscriptionPayments
     * const count = await prisma.subscriptionPayment.count({
     *   where: {
     *     // ... the filter for the SubscriptionPayments we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionPaymentCountArgs>(
      args?: Subset<T, SubscriptionPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionPaymentAggregateArgs>(args: Subset<T, SubscriptionPaymentAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionPaymentAggregateType<T>>

    /**
     * Group by SubscriptionPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPaymentGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionPayment model
   */
  readonly fields: SubscriptionPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionPayment model
   */
  interface SubscriptionPaymentFieldRefs {
    readonly id: FieldRef<"SubscriptionPayment", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionPayment", 'String'>
    readonly amount: FieldRef<"SubscriptionPayment", 'Float'>
    readonly currency: FieldRef<"SubscriptionPayment", 'String'>
    readonly paidAt: FieldRef<"SubscriptionPayment", 'DateTime'>
    readonly status: FieldRef<"SubscriptionPayment", 'String'>
    readonly paymentMethod: FieldRef<"SubscriptionPayment", 'String'>
    readonly gatewayResponse: FieldRef<"SubscriptionPayment", 'Json'>
    readonly createdAt: FieldRef<"SubscriptionPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionPayment findUnique
   */
  export type SubscriptionPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment findUniqueOrThrow
   */
  export type SubscriptionPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment findFirst
   */
  export type SubscriptionPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPayments.
     */
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment findFirstOrThrow
   */
  export type SubscriptionPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayment to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionPayments.
     */
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment findMany
   */
  export type SubscriptionPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionPayments to fetch.
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionPayments to fetch.
     */
    orderBy?: SubscriptionPaymentOrderByWithRelationInput | SubscriptionPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionPayments.
     */
    cursor?: SubscriptionPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionPayments.
     */
    skip?: number
    distinct?: SubscriptionPaymentScalarFieldEnum | SubscriptionPaymentScalarFieldEnum[]
  }

  /**
   * SubscriptionPayment create
   */
  export type SubscriptionPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionPayment.
     */
    data: XOR<SubscriptionPaymentCreateInput, SubscriptionPaymentUncheckedCreateInput>
  }

  /**
   * SubscriptionPayment createMany
   */
  export type SubscriptionPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionPayments.
     */
    data: SubscriptionPaymentCreateManyInput | SubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionPayment createManyAndReturn
   */
  export type SubscriptionPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionPayments.
     */
    data: SubscriptionPaymentCreateManyInput | SubscriptionPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionPayment update
   */
  export type SubscriptionPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionPayment.
     */
    data: XOR<SubscriptionPaymentUpdateInput, SubscriptionPaymentUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionPayment to update.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment updateMany
   */
  export type SubscriptionPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionPayments.
     */
    data: XOR<SubscriptionPaymentUpdateManyMutationInput, SubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPayments to update
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to update.
     */
    limit?: number
  }

  /**
   * SubscriptionPayment updateManyAndReturn
   */
  export type SubscriptionPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionPayments.
     */
    data: XOR<SubscriptionPaymentUpdateManyMutationInput, SubscriptionPaymentUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionPayments to update
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionPayment upsert
   */
  export type SubscriptionPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionPayment to update in case it exists.
     */
    where: SubscriptionPaymentWhereUniqueInput
    /**
     * In case the SubscriptionPayment found by the `where` argument doesn't exist, create a new SubscriptionPayment with this data.
     */
    create: XOR<SubscriptionPaymentCreateInput, SubscriptionPaymentUncheckedCreateInput>
    /**
     * In case the SubscriptionPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionPaymentUpdateInput, SubscriptionPaymentUncheckedUpdateInput>
  }

  /**
   * SubscriptionPayment delete
   */
  export type SubscriptionPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionPayment to delete.
     */
    where: SubscriptionPaymentWhereUniqueInput
  }

  /**
   * SubscriptionPayment deleteMany
   */
  export type SubscriptionPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionPayments to delete
     */
    where?: SubscriptionPaymentWhereInput
    /**
     * Limit how many SubscriptionPayments to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionPayment without action
   */
  export type SubscriptionPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionPayment
     */
    select?: SubscriptionPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionPayment
     */
    omit?: SubscriptionPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionPaymentInclude<ExtArgs> | null
  }


  /**
   * Model SubscriptionEvent
   */

  export type AggregateSubscriptionEvent = {
    _count: SubscriptionEventCountAggregateOutputType | null
    _min: SubscriptionEventMinAggregateOutputType | null
    _max: SubscriptionEventMaxAggregateOutputType | null
  }

  export type SubscriptionEventMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    eventType: string | null
    eventAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionEventMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    eventType: string | null
    eventAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionEventCountAggregateOutputType = {
    id: number
    subscriptionId: number
    eventType: number
    eventAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionEventMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    eventType?: true
    eventAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionEventMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    eventType?: true
    eventAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionEventCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    eventType?: true
    eventAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionEvent to aggregate.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubscriptionEvents
    **/
    _count?: true | SubscriptionEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionEventMaxAggregateInputType
  }

  export type GetSubscriptionEventAggregateType<T extends SubscriptionEventAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptionEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionEvent[P]>
      : GetScalarType<T[P], AggregateSubscriptionEvent[P]>
  }




  export type SubscriptionEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionEventWhereInput
    orderBy?: SubscriptionEventOrderByWithAggregationInput | SubscriptionEventOrderByWithAggregationInput[]
    by: SubscriptionEventScalarFieldEnum[] | SubscriptionEventScalarFieldEnum
    having?: SubscriptionEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionEventCountAggregateInputType | true
    _min?: SubscriptionEventMinAggregateInputType
    _max?: SubscriptionEventMaxAggregateInputType
  }

  export type SubscriptionEventGroupByOutputType = {
    id: string
    subscriptionId: string
    eventType: string
    eventAt: Date
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionEventCountAggregateOutputType | null
    _min: SubscriptionEventMinAggregateOutputType | null
    _max: SubscriptionEventMaxAggregateOutputType | null
  }

  type GetSubscriptionEventGroupByPayload<T extends SubscriptionEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionEventGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionEventGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    eventType?: boolean
    eventAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionEvent"]>

  export type SubscriptionEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    eventType?: boolean
    eventAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionEvent"]>

  export type SubscriptionEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    eventType?: boolean
    eventAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptionEvent"]>

  export type SubscriptionEventSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    eventType?: boolean
    eventAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "eventType" | "eventAt" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["subscriptionEvent"]>
  export type SubscriptionEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type SubscriptionEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $SubscriptionEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubscriptionEvent"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      eventType: string
      eventAt: Date
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscriptionEvent"]>
    composites: {}
  }

  type SubscriptionEventGetPayload<S extends boolean | null | undefined | SubscriptionEventDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionEventPayload, S>

  type SubscriptionEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionEventCountAggregateInputType | true
    }

  export interface SubscriptionEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionEvent'], meta: { name: 'SubscriptionEvent' } }
    /**
     * Find zero or one SubscriptionEvent that matches the filter.
     * @param {SubscriptionEventFindUniqueArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionEventFindUniqueArgs>(args: SelectSubset<T, SubscriptionEventFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SubscriptionEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionEventFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionEventFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindFirstArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionEventFindFirstArgs>(args?: SelectSubset<T, SubscriptionEventFindFirstArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SubscriptionEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindFirstOrThrowArgs} args - Arguments to find a SubscriptionEvent
     * @example
     * // Get one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionEventFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SubscriptionEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionEvents
     * const subscriptionEvents = await prisma.subscriptionEvent.findMany()
     * 
     * // Get first 10 SubscriptionEvents
     * const subscriptionEvents = await prisma.subscriptionEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionEventWithIdOnly = await prisma.subscriptionEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionEventFindManyArgs>(args?: SelectSubset<T, SubscriptionEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SubscriptionEvent.
     * @param {SubscriptionEventCreateArgs} args - Arguments to create a SubscriptionEvent.
     * @example
     * // Create one SubscriptionEvent
     * const SubscriptionEvent = await prisma.subscriptionEvent.create({
     *   data: {
     *     // ... data to create a SubscriptionEvent
     *   }
     * })
     * 
     */
    create<T extends SubscriptionEventCreateArgs>(args: SelectSubset<T, SubscriptionEventCreateArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SubscriptionEvents.
     * @param {SubscriptionEventCreateManyArgs} args - Arguments to create many SubscriptionEvents.
     * @example
     * // Create many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionEventCreateManyArgs>(args?: SelectSubset<T, SubscriptionEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SubscriptionEvents and returns the data saved in the database.
     * @param {SubscriptionEventCreateManyAndReturnArgs} args - Arguments to create many SubscriptionEvents.
     * @example
     * // Create many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SubscriptionEvents and only return the `id`
     * const subscriptionEventWithIdOnly = await prisma.subscriptionEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionEventCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SubscriptionEvent.
     * @param {SubscriptionEventDeleteArgs} args - Arguments to delete one SubscriptionEvent.
     * @example
     * // Delete one SubscriptionEvent
     * const SubscriptionEvent = await prisma.subscriptionEvent.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionEvent
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionEventDeleteArgs>(args: SelectSubset<T, SubscriptionEventDeleteArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SubscriptionEvent.
     * @param {SubscriptionEventUpdateArgs} args - Arguments to update one SubscriptionEvent.
     * @example
     * // Update one SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionEventUpdateArgs>(args: SelectSubset<T, SubscriptionEventUpdateArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SubscriptionEvents.
     * @param {SubscriptionEventDeleteManyArgs} args - Arguments to filter SubscriptionEvents to delete.
     * @example
     * // Delete a few SubscriptionEvents
     * const { count } = await prisma.subscriptionEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionEventDeleteManyArgs>(args?: SelectSubset<T, SubscriptionEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionEventUpdateManyArgs>(args: SelectSubset<T, SubscriptionEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubscriptionEvents and returns the data updated in the database.
     * @param {SubscriptionEventUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionEvents.
     * @example
     * // Update many SubscriptionEvents
     * const subscriptionEvent = await prisma.subscriptionEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SubscriptionEvents and only return the `id`
     * const subscriptionEventWithIdOnly = await prisma.subscriptionEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionEventUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SubscriptionEvent.
     * @param {SubscriptionEventUpsertArgs} args - Arguments to update or create a SubscriptionEvent.
     * @example
     * // Update or create a SubscriptionEvent
     * const subscriptionEvent = await prisma.subscriptionEvent.upsert({
     *   create: {
     *     // ... data to create a SubscriptionEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionEvent we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionEventUpsertArgs>(args: SelectSubset<T, SubscriptionEventUpsertArgs<ExtArgs>>): Prisma__SubscriptionEventClient<$Result.GetResult<Prisma.$SubscriptionEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SubscriptionEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventCountArgs} args - Arguments to filter SubscriptionEvents to count.
     * @example
     * // Count the number of SubscriptionEvents
     * const count = await prisma.subscriptionEvent.count({
     *   where: {
     *     // ... the filter for the SubscriptionEvents we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionEventCountArgs>(
      args?: Subset<T, SubscriptionEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubscriptionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionEventAggregateArgs>(args: Subset<T, SubscriptionEventAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionEventAggregateType<T>>

    /**
     * Group by SubscriptionEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionEventGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubscriptionEvent model
   */
  readonly fields: SubscriptionEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubscriptionEvent model
   */
  interface SubscriptionEventFieldRefs {
    readonly id: FieldRef<"SubscriptionEvent", 'String'>
    readonly subscriptionId: FieldRef<"SubscriptionEvent", 'String'>
    readonly eventType: FieldRef<"SubscriptionEvent", 'String'>
    readonly eventAt: FieldRef<"SubscriptionEvent", 'DateTime'>
    readonly metadata: FieldRef<"SubscriptionEvent", 'Json'>
    readonly createdAt: FieldRef<"SubscriptionEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"SubscriptionEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SubscriptionEvent findUnique
   */
  export type SubscriptionEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent findUniqueOrThrow
   */
  export type SubscriptionEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent findFirst
   */
  export type SubscriptionEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionEvents.
     */
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent findFirstOrThrow
   */
  export type SubscriptionEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvent to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubscriptionEvents.
     */
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent findMany
   */
  export type SubscriptionEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter, which SubscriptionEvents to fetch.
     */
    where?: SubscriptionEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubscriptionEvents to fetch.
     */
    orderBy?: SubscriptionEventOrderByWithRelationInput | SubscriptionEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubscriptionEvents.
     */
    cursor?: SubscriptionEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubscriptionEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubscriptionEvents.
     */
    skip?: number
    distinct?: SubscriptionEventScalarFieldEnum | SubscriptionEventScalarFieldEnum[]
  }

  /**
   * SubscriptionEvent create
   */
  export type SubscriptionEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * The data needed to create a SubscriptionEvent.
     */
    data: XOR<SubscriptionEventCreateInput, SubscriptionEventUncheckedCreateInput>
  }

  /**
   * SubscriptionEvent createMany
   */
  export type SubscriptionEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubscriptionEvents.
     */
    data: SubscriptionEventCreateManyInput | SubscriptionEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubscriptionEvent createManyAndReturn
   */
  export type SubscriptionEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * The data used to create many SubscriptionEvents.
     */
    data: SubscriptionEventCreateManyInput | SubscriptionEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionEvent update
   */
  export type SubscriptionEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * The data needed to update a SubscriptionEvent.
     */
    data: XOR<SubscriptionEventUpdateInput, SubscriptionEventUncheckedUpdateInput>
    /**
     * Choose, which SubscriptionEvent to update.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent updateMany
   */
  export type SubscriptionEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubscriptionEvents.
     */
    data: XOR<SubscriptionEventUpdateManyMutationInput, SubscriptionEventUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionEvents to update
     */
    where?: SubscriptionEventWhereInput
    /**
     * Limit how many SubscriptionEvents to update.
     */
    limit?: number
  }

  /**
   * SubscriptionEvent updateManyAndReturn
   */
  export type SubscriptionEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * The data used to update SubscriptionEvents.
     */
    data: XOR<SubscriptionEventUpdateManyMutationInput, SubscriptionEventUncheckedUpdateManyInput>
    /**
     * Filter which SubscriptionEvents to update
     */
    where?: SubscriptionEventWhereInput
    /**
     * Limit how many SubscriptionEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SubscriptionEvent upsert
   */
  export type SubscriptionEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * The filter to search for the SubscriptionEvent to update in case it exists.
     */
    where: SubscriptionEventWhereUniqueInput
    /**
     * In case the SubscriptionEvent found by the `where` argument doesn't exist, create a new SubscriptionEvent with this data.
     */
    create: XOR<SubscriptionEventCreateInput, SubscriptionEventUncheckedCreateInput>
    /**
     * In case the SubscriptionEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionEventUpdateInput, SubscriptionEventUncheckedUpdateInput>
  }

  /**
   * SubscriptionEvent delete
   */
  export type SubscriptionEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
    /**
     * Filter which SubscriptionEvent to delete.
     */
    where: SubscriptionEventWhereUniqueInput
  }

  /**
   * SubscriptionEvent deleteMany
   */
  export type SubscriptionEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubscriptionEvents to delete
     */
    where?: SubscriptionEventWhereInput
    /**
     * Limit how many SubscriptionEvents to delete.
     */
    limit?: number
  }

  /**
   * SubscriptionEvent without action
   */
  export type SubscriptionEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionEvent
     */
    select?: SubscriptionEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SubscriptionEvent
     */
    omit?: SubscriptionEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionEventInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    productName: string | null
    productPrice: string | null
    description: string | null
    productLink: string | null
    adminId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    productName: string | null
    productPrice: string | null
    description: string | null
    productLink: string | null
    adminId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    productName: number
    productCategory: number
    productPrice: number
    description: number
    productLink: number
    tags: number
    specifications: number
    adminId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    productName?: true
    productPrice?: true
    description?: true
    productLink?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    productName?: true
    productPrice?: true
    description?: true
    productLink?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    productName?: true
    productCategory?: true
    productPrice?: true
    description?: true
    productLink?: true
    tags?: true
    specifications?: true
    adminId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    productName: string
    productCategory: JsonValue
    productPrice: string
    description: string | null
    productLink: string | null
    tags: string[]
    specifications: JsonValue
    adminId: string
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    productCategory?: boolean
    productPrice?: boolean
    description?: boolean
    productLink?: boolean
    tags?: boolean
    specifications?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    customerProductHistory?: boolean | Product$customerProductHistoryArgs<ExtArgs>
    renewalHistory?: boolean | Product$renewalHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    productCategory?: boolean
    productPrice?: boolean
    description?: boolean
    productLink?: boolean
    tags?: boolean
    specifications?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productName?: boolean
    productCategory?: boolean
    productPrice?: boolean
    description?: boolean
    productLink?: boolean
    tags?: boolean
    specifications?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    productName?: boolean
    productCategory?: boolean
    productPrice?: boolean
    description?: boolean
    productLink?: boolean
    tags?: boolean
    specifications?: boolean
    adminId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productName" | "productCategory" | "productPrice" | "description" | "productLink" | "tags" | "specifications" | "adminId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    customerProductHistory?: boolean | Product$customerProductHistoryArgs<ExtArgs>
    renewalHistory?: boolean | Product$renewalHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      customerProductHistory: Prisma.$CustomerProductHistoryPayload<ExtArgs>[]
      renewalHistory: Prisma.$ProductRenewalHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productName: string
      productCategory: Prisma.JsonValue
      productPrice: string
      description: string | null
      productLink: string | null
      tags: string[]
      specifications: Prisma.JsonValue
      adminId: string
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customerProductHistory<T extends Product$customerProductHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$customerProductHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    renewalHistory<T extends Product$renewalHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$renewalHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly productName: FieldRef<"Product", 'String'>
    readonly productCategory: FieldRef<"Product", 'Json'>
    readonly productPrice: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly productLink: FieldRef<"Product", 'String'>
    readonly tags: FieldRef<"Product", 'String[]'>
    readonly specifications: FieldRef<"Product", 'Json'>
    readonly adminId: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.customerProductHistory
   */
  export type Product$customerProductHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    where?: CustomerProductHistoryWhereInput
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    cursor?: CustomerProductHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * Product.renewalHistory
   */
  export type Product$renewalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    where?: ProductRenewalHistoryWhereInput
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    cursor?: ProductRenewalHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRenewalHistoryScalarFieldEnum | ProductRenewalHistoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductRenewalHistory
   */

  export type AggregateProductRenewalHistory = {
    _count: ProductRenewalHistoryCountAggregateOutputType | null
    _min: ProductRenewalHistoryMinAggregateOutputType | null
    _max: ProductRenewalHistoryMaxAggregateOutputType | null
  }

  export type ProductRenewalHistoryMinAggregateOutputType = {
    id: string | null
    customerProductHistoryId: string | null
    productId: string | null
    purchaseDate: Date | null
    renewalDate: Date | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductRenewalHistoryMaxAggregateOutputType = {
    id: string | null
    customerProductHistoryId: string | null
    productId: string | null
    purchaseDate: Date | null
    renewalDate: Date | null
    expiryDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductRenewalHistoryCountAggregateOutputType = {
    id: number
    customerProductHistoryId: number
    productId: number
    purchaseDate: number
    renewalDate: number
    expiryDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductRenewalHistoryMinAggregateInputType = {
    id?: true
    customerProductHistoryId?: true
    productId?: true
    purchaseDate?: true
    renewalDate?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductRenewalHistoryMaxAggregateInputType = {
    id?: true
    customerProductHistoryId?: true
    productId?: true
    purchaseDate?: true
    renewalDate?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductRenewalHistoryCountAggregateInputType = {
    id?: true
    customerProductHistoryId?: true
    productId?: true
    purchaseDate?: true
    renewalDate?: true
    expiryDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductRenewalHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRenewalHistory to aggregate.
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRenewalHistories to fetch.
     */
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductRenewalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRenewalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRenewalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductRenewalHistories
    **/
    _count?: true | ProductRenewalHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductRenewalHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductRenewalHistoryMaxAggregateInputType
  }

  export type GetProductRenewalHistoryAggregateType<T extends ProductRenewalHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateProductRenewalHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductRenewalHistory[P]>
      : GetScalarType<T[P], AggregateProductRenewalHistory[P]>
  }




  export type ProductRenewalHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductRenewalHistoryWhereInput
    orderBy?: ProductRenewalHistoryOrderByWithAggregationInput | ProductRenewalHistoryOrderByWithAggregationInput[]
    by: ProductRenewalHistoryScalarFieldEnum[] | ProductRenewalHistoryScalarFieldEnum
    having?: ProductRenewalHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductRenewalHistoryCountAggregateInputType | true
    _min?: ProductRenewalHistoryMinAggregateInputType
    _max?: ProductRenewalHistoryMaxAggregateInputType
  }

  export type ProductRenewalHistoryGroupByOutputType = {
    id: string
    customerProductHistoryId: string
    productId: string
    purchaseDate: Date
    renewalDate: Date | null
    expiryDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProductRenewalHistoryCountAggregateOutputType | null
    _min: ProductRenewalHistoryMinAggregateOutputType | null
    _max: ProductRenewalHistoryMaxAggregateOutputType | null
  }

  type GetProductRenewalHistoryGroupByPayload<T extends ProductRenewalHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductRenewalHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductRenewalHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductRenewalHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ProductRenewalHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ProductRenewalHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProductHistoryId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewalDate?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRenewalHistory"]>

  export type ProductRenewalHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProductHistoryId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewalDate?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRenewalHistory"]>

  export type ProductRenewalHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerProductHistoryId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewalDate?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productRenewalHistory"]>

  export type ProductRenewalHistorySelectScalar = {
    id?: boolean
    customerProductHistoryId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewalDate?: boolean
    expiryDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductRenewalHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerProductHistoryId" | "productId" | "purchaseDate" | "renewalDate" | "expiryDate" | "createdAt" | "updatedAt", ExtArgs["result"]["productRenewalHistory"]>
  export type ProductRenewalHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductRenewalHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductRenewalHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerProductHistory?: boolean | CustomerProductHistoryDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductRenewalHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductRenewalHistory"
    objects: {
      customerProductHistory: Prisma.$CustomerProductHistoryPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerProductHistoryId: string
      productId: string
      purchaseDate: Date
      renewalDate: Date | null
      expiryDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productRenewalHistory"]>
    composites: {}
  }

  type ProductRenewalHistoryGetPayload<S extends boolean | null | undefined | ProductRenewalHistoryDefaultArgs> = $Result.GetResult<Prisma.$ProductRenewalHistoryPayload, S>

  type ProductRenewalHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductRenewalHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductRenewalHistoryCountAggregateInputType | true
    }

  export interface ProductRenewalHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductRenewalHistory'], meta: { name: 'ProductRenewalHistory' } }
    /**
     * Find zero or one ProductRenewalHistory that matches the filter.
     * @param {ProductRenewalHistoryFindUniqueArgs} args - Arguments to find a ProductRenewalHistory
     * @example
     * // Get one ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductRenewalHistoryFindUniqueArgs>(args: SelectSubset<T, ProductRenewalHistoryFindUniqueArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductRenewalHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductRenewalHistoryFindUniqueOrThrowArgs} args - Arguments to find a ProductRenewalHistory
     * @example
     * // Get one ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductRenewalHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductRenewalHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductRenewalHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryFindFirstArgs} args - Arguments to find a ProductRenewalHistory
     * @example
     * // Get one ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductRenewalHistoryFindFirstArgs>(args?: SelectSubset<T, ProductRenewalHistoryFindFirstArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductRenewalHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryFindFirstOrThrowArgs} args - Arguments to find a ProductRenewalHistory
     * @example
     * // Get one ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductRenewalHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductRenewalHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductRenewalHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductRenewalHistories
     * const productRenewalHistories = await prisma.productRenewalHistory.findMany()
     * 
     * // Get first 10 ProductRenewalHistories
     * const productRenewalHistories = await prisma.productRenewalHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productRenewalHistoryWithIdOnly = await prisma.productRenewalHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductRenewalHistoryFindManyArgs>(args?: SelectSubset<T, ProductRenewalHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductRenewalHistory.
     * @param {ProductRenewalHistoryCreateArgs} args - Arguments to create a ProductRenewalHistory.
     * @example
     * // Create one ProductRenewalHistory
     * const ProductRenewalHistory = await prisma.productRenewalHistory.create({
     *   data: {
     *     // ... data to create a ProductRenewalHistory
     *   }
     * })
     * 
     */
    create<T extends ProductRenewalHistoryCreateArgs>(args: SelectSubset<T, ProductRenewalHistoryCreateArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductRenewalHistories.
     * @param {ProductRenewalHistoryCreateManyArgs} args - Arguments to create many ProductRenewalHistories.
     * @example
     * // Create many ProductRenewalHistories
     * const productRenewalHistory = await prisma.productRenewalHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductRenewalHistoryCreateManyArgs>(args?: SelectSubset<T, ProductRenewalHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductRenewalHistories and returns the data saved in the database.
     * @param {ProductRenewalHistoryCreateManyAndReturnArgs} args - Arguments to create many ProductRenewalHistories.
     * @example
     * // Create many ProductRenewalHistories
     * const productRenewalHistory = await prisma.productRenewalHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductRenewalHistories and only return the `id`
     * const productRenewalHistoryWithIdOnly = await prisma.productRenewalHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductRenewalHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductRenewalHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductRenewalHistory.
     * @param {ProductRenewalHistoryDeleteArgs} args - Arguments to delete one ProductRenewalHistory.
     * @example
     * // Delete one ProductRenewalHistory
     * const ProductRenewalHistory = await prisma.productRenewalHistory.delete({
     *   where: {
     *     // ... filter to delete one ProductRenewalHistory
     *   }
     * })
     * 
     */
    delete<T extends ProductRenewalHistoryDeleteArgs>(args: SelectSubset<T, ProductRenewalHistoryDeleteArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductRenewalHistory.
     * @param {ProductRenewalHistoryUpdateArgs} args - Arguments to update one ProductRenewalHistory.
     * @example
     * // Update one ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductRenewalHistoryUpdateArgs>(args: SelectSubset<T, ProductRenewalHistoryUpdateArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductRenewalHistories.
     * @param {ProductRenewalHistoryDeleteManyArgs} args - Arguments to filter ProductRenewalHistories to delete.
     * @example
     * // Delete a few ProductRenewalHistories
     * const { count } = await prisma.productRenewalHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductRenewalHistoryDeleteManyArgs>(args?: SelectSubset<T, ProductRenewalHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRenewalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductRenewalHistories
     * const productRenewalHistory = await prisma.productRenewalHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductRenewalHistoryUpdateManyArgs>(args: SelectSubset<T, ProductRenewalHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductRenewalHistories and returns the data updated in the database.
     * @param {ProductRenewalHistoryUpdateManyAndReturnArgs} args - Arguments to update many ProductRenewalHistories.
     * @example
     * // Update many ProductRenewalHistories
     * const productRenewalHistory = await prisma.productRenewalHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductRenewalHistories and only return the `id`
     * const productRenewalHistoryWithIdOnly = await prisma.productRenewalHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductRenewalHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductRenewalHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductRenewalHistory.
     * @param {ProductRenewalHistoryUpsertArgs} args - Arguments to update or create a ProductRenewalHistory.
     * @example
     * // Update or create a ProductRenewalHistory
     * const productRenewalHistory = await prisma.productRenewalHistory.upsert({
     *   create: {
     *     // ... data to create a ProductRenewalHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductRenewalHistory we want to update
     *   }
     * })
     */
    upsert<T extends ProductRenewalHistoryUpsertArgs>(args: SelectSubset<T, ProductRenewalHistoryUpsertArgs<ExtArgs>>): Prisma__ProductRenewalHistoryClient<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductRenewalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryCountArgs} args - Arguments to filter ProductRenewalHistories to count.
     * @example
     * // Count the number of ProductRenewalHistories
     * const count = await prisma.productRenewalHistory.count({
     *   where: {
     *     // ... the filter for the ProductRenewalHistories we want to count
     *   }
     * })
    **/
    count<T extends ProductRenewalHistoryCountArgs>(
      args?: Subset<T, ProductRenewalHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductRenewalHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductRenewalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductRenewalHistoryAggregateArgs>(args: Subset<T, ProductRenewalHistoryAggregateArgs>): Prisma.PrismaPromise<GetProductRenewalHistoryAggregateType<T>>

    /**
     * Group by ProductRenewalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductRenewalHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductRenewalHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductRenewalHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ProductRenewalHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductRenewalHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductRenewalHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductRenewalHistory model
   */
  readonly fields: ProductRenewalHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductRenewalHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductRenewalHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customerProductHistory<T extends CustomerProductHistoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProductHistoryDefaultArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductRenewalHistory model
   */
  interface ProductRenewalHistoryFieldRefs {
    readonly id: FieldRef<"ProductRenewalHistory", 'String'>
    readonly customerProductHistoryId: FieldRef<"ProductRenewalHistory", 'String'>
    readonly productId: FieldRef<"ProductRenewalHistory", 'String'>
    readonly purchaseDate: FieldRef<"ProductRenewalHistory", 'DateTime'>
    readonly renewalDate: FieldRef<"ProductRenewalHistory", 'DateTime'>
    readonly expiryDate: FieldRef<"ProductRenewalHistory", 'DateTime'>
    readonly createdAt: FieldRef<"ProductRenewalHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductRenewalHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductRenewalHistory findUnique
   */
  export type ProductRenewalHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductRenewalHistory to fetch.
     */
    where: ProductRenewalHistoryWhereUniqueInput
  }

  /**
   * ProductRenewalHistory findUniqueOrThrow
   */
  export type ProductRenewalHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductRenewalHistory to fetch.
     */
    where: ProductRenewalHistoryWhereUniqueInput
  }

  /**
   * ProductRenewalHistory findFirst
   */
  export type ProductRenewalHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductRenewalHistory to fetch.
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRenewalHistories to fetch.
     */
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRenewalHistories.
     */
    cursor?: ProductRenewalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRenewalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRenewalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRenewalHistories.
     */
    distinct?: ProductRenewalHistoryScalarFieldEnum | ProductRenewalHistoryScalarFieldEnum[]
  }

  /**
   * ProductRenewalHistory findFirstOrThrow
   */
  export type ProductRenewalHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductRenewalHistory to fetch.
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRenewalHistories to fetch.
     */
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductRenewalHistories.
     */
    cursor?: ProductRenewalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRenewalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRenewalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductRenewalHistories.
     */
    distinct?: ProductRenewalHistoryScalarFieldEnum | ProductRenewalHistoryScalarFieldEnum[]
  }

  /**
   * ProductRenewalHistory findMany
   */
  export type ProductRenewalHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ProductRenewalHistories to fetch.
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductRenewalHistories to fetch.
     */
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductRenewalHistories.
     */
    cursor?: ProductRenewalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductRenewalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductRenewalHistories.
     */
    skip?: number
    distinct?: ProductRenewalHistoryScalarFieldEnum | ProductRenewalHistoryScalarFieldEnum[]
  }

  /**
   * ProductRenewalHistory create
   */
  export type ProductRenewalHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductRenewalHistory.
     */
    data: XOR<ProductRenewalHistoryCreateInput, ProductRenewalHistoryUncheckedCreateInput>
  }

  /**
   * ProductRenewalHistory createMany
   */
  export type ProductRenewalHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductRenewalHistories.
     */
    data: ProductRenewalHistoryCreateManyInput | ProductRenewalHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductRenewalHistory createManyAndReturn
   */
  export type ProductRenewalHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ProductRenewalHistories.
     */
    data: ProductRenewalHistoryCreateManyInput | ProductRenewalHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductRenewalHistory update
   */
  export type ProductRenewalHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductRenewalHistory.
     */
    data: XOR<ProductRenewalHistoryUpdateInput, ProductRenewalHistoryUncheckedUpdateInput>
    /**
     * Choose, which ProductRenewalHistory to update.
     */
    where: ProductRenewalHistoryWhereUniqueInput
  }

  /**
   * ProductRenewalHistory updateMany
   */
  export type ProductRenewalHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductRenewalHistories.
     */
    data: XOR<ProductRenewalHistoryUpdateManyMutationInput, ProductRenewalHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductRenewalHistories to update
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * Limit how many ProductRenewalHistories to update.
     */
    limit?: number
  }

  /**
   * ProductRenewalHistory updateManyAndReturn
   */
  export type ProductRenewalHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ProductRenewalHistories.
     */
    data: XOR<ProductRenewalHistoryUpdateManyMutationInput, ProductRenewalHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ProductRenewalHistories to update
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * Limit how many ProductRenewalHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductRenewalHistory upsert
   */
  export type ProductRenewalHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductRenewalHistory to update in case it exists.
     */
    where: ProductRenewalHistoryWhereUniqueInput
    /**
     * In case the ProductRenewalHistory found by the `where` argument doesn't exist, create a new ProductRenewalHistory with this data.
     */
    create: XOR<ProductRenewalHistoryCreateInput, ProductRenewalHistoryUncheckedCreateInput>
    /**
     * In case the ProductRenewalHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductRenewalHistoryUpdateInput, ProductRenewalHistoryUncheckedUpdateInput>
  }

  /**
   * ProductRenewalHistory delete
   */
  export type ProductRenewalHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    /**
     * Filter which ProductRenewalHistory to delete.
     */
    where: ProductRenewalHistoryWhereUniqueInput
  }

  /**
   * ProductRenewalHistory deleteMany
   */
  export type ProductRenewalHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductRenewalHistories to delete
     */
    where?: ProductRenewalHistoryWhereInput
    /**
     * Limit how many ProductRenewalHistories to delete.
     */
    limit?: number
  }

  /**
   * ProductRenewalHistory without action
   */
  export type ProductRenewalHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    companyName: string | null
    contactPerson: string | null
    mobileNumber: string | null
    email: string | null
    serialNo: string | null
    prime: boolean | null
    blacklisted: boolean | null
    remark: string | null
    joiningDate: Date | null
    hasReference: boolean | null
    partnerId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    companyName: string | null
    contactPerson: string | null
    mobileNumber: string | null
    email: string | null
    serialNo: string | null
    prime: boolean | null
    blacklisted: boolean | null
    remark: string | null
    joiningDate: Date | null
    hasReference: boolean | null
    partnerId: string | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    adminId: number
    companyName: number
    contactPerson: number
    mobileNumber: number
    email: number
    serialNo: number
    prime: number
    blacklisted: number
    remark: number
    adminCustomFields: number
    address: number
    joiningDate: number
    hasReference: number
    partnerId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    adminId?: true
    companyName?: true
    contactPerson?: true
    mobileNumber?: true
    email?: true
    serialNo?: true
    prime?: true
    blacklisted?: true
    remark?: true
    joiningDate?: true
    hasReference?: true
    partnerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    adminId?: true
    companyName?: true
    contactPerson?: true
    mobileNumber?: true
    email?: true
    serialNo?: true
    prime?: true
    blacklisted?: true
    remark?: true
    joiningDate?: true
    hasReference?: true
    partnerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    adminId?: true
    companyName?: true
    contactPerson?: true
    mobileNumber?: true
    email?: true
    serialNo?: true
    prime?: true
    blacklisted?: true
    remark?: true
    adminCustomFields?: true
    address?: true
    joiningDate?: true
    hasReference?: true
    partnerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime: boolean
    blacklisted: boolean
    remark: string | null
    adminCustomFields: JsonValue | null
    address: JsonValue
    joiningDate: Date
    hasReference: boolean
    partnerId: string | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    mobileNumber?: boolean
    email?: boolean
    serialNo?: boolean
    prime?: boolean
    blacklisted?: boolean
    remark?: boolean
    adminCustomFields?: boolean
    address?: boolean
    joiningDate?: boolean
    hasReference?: boolean
    partnerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
    product?: boolean | Customer$productArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    mobileNumber?: boolean
    email?: boolean
    serialNo?: boolean
    prime?: boolean
    blacklisted?: boolean
    remark?: boolean
    adminCustomFields?: boolean
    address?: boolean
    joiningDate?: boolean
    hasReference?: boolean
    partnerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    mobileNumber?: boolean
    email?: boolean
    serialNo?: boolean
    prime?: boolean
    blacklisted?: boolean
    remark?: boolean
    adminCustomFields?: boolean
    address?: boolean
    joiningDate?: boolean
    hasReference?: boolean
    partnerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    adminId?: boolean
    companyName?: boolean
    contactPerson?: boolean
    mobileNumber?: boolean
    email?: boolean
    serialNo?: boolean
    prime?: boolean
    blacklisted?: boolean
    remark?: boolean
    adminCustomFields?: boolean
    address?: boolean
    joiningDate?: boolean
    hasReference?: boolean
    partnerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "companyName" | "contactPerson" | "mobileNumber" | "email" | "serialNo" | "prime" | "blacklisted" | "remark" | "adminCustomFields" | "address" | "joiningDate" | "hasReference" | "partnerId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
    product?: boolean | Customer$productArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    partner?: boolean | Customer$partnerArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      product: Prisma.$CustomerProductHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      companyName: string
      contactPerson: string
      mobileNumber: string
      email: string
      serialNo: string
      prime: boolean
      blacklisted: boolean
      remark: string | null
      adminCustomFields: Prisma.JsonValue | null
      address: Prisma.JsonValue
      joiningDate: Date
      hasReference: boolean
      partnerId: string | null
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    partner<T extends Customer$partnerArgs<ExtArgs> = {}>(args?: Subset<T, Customer$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Customer$productArgs<ExtArgs> = {}>(args?: Subset<T, Customer$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly adminId: FieldRef<"Customer", 'String'>
    readonly companyName: FieldRef<"Customer", 'String'>
    readonly contactPerson: FieldRef<"Customer", 'String'>
    readonly mobileNumber: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly serialNo: FieldRef<"Customer", 'String'>
    readonly prime: FieldRef<"Customer", 'Boolean'>
    readonly blacklisted: FieldRef<"Customer", 'Boolean'>
    readonly remark: FieldRef<"Customer", 'String'>
    readonly adminCustomFields: FieldRef<"Customer", 'Json'>
    readonly address: FieldRef<"Customer", 'Json'>
    readonly joiningDate: FieldRef<"Customer", 'DateTime'>
    readonly hasReference: FieldRef<"Customer", 'Boolean'>
    readonly partnerId: FieldRef<"Customer", 'String'>
    readonly status: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.partner
   */
  export type Customer$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Partner
     */
    omit?: PartnerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * Customer.product
   */
  export type Customer$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    where?: CustomerProductHistoryWhereInput
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    cursor?: CustomerProductHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerProductHistory
   */

  export type AggregateCustomerProductHistory = {
    _count: CustomerProductHistoryCountAggregateOutputType | null
    _min: CustomerProductHistoryMinAggregateOutputType | null
    _max: CustomerProductHistoryMaxAggregateOutputType | null
  }

  export type CustomerProductHistoryMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    adminId: string | null
    productId: string | null
    purchaseDate: Date | null
    renewal: boolean | null
    renewPeriod: $Enums.renewPeriod | null
    expiryDate: Date | null
    renewalDate: Date | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductHistoryMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    adminId: string | null
    productId: string | null
    purchaseDate: Date | null
    renewal: boolean | null
    renewPeriod: $Enums.renewPeriod | null
    expiryDate: Date | null
    renewalDate: Date | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerProductHistoryCountAggregateOutputType = {
    id: number
    customerId: number
    adminId: number
    productId: number
    purchaseDate: number
    renewal: number
    renewPeriod: number
    expiryDate: number
    renewalDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerProductHistoryMinAggregateInputType = {
    id?: true
    customerId?: true
    adminId?: true
    productId?: true
    purchaseDate?: true
    renewal?: true
    renewPeriod?: true
    expiryDate?: true
    renewalDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductHistoryMaxAggregateInputType = {
    id?: true
    customerId?: true
    adminId?: true
    productId?: true
    purchaseDate?: true
    renewal?: true
    renewPeriod?: true
    expiryDate?: true
    renewalDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerProductHistoryCountAggregateInputType = {
    id?: true
    customerId?: true
    adminId?: true
    productId?: true
    purchaseDate?: true
    renewal?: true
    renewPeriod?: true
    expiryDate?: true
    renewalDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerProductHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProductHistory to aggregate.
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductHistories to fetch.
     */
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerProductHistories
    **/
    _count?: true | CustomerProductHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerProductHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerProductHistoryMaxAggregateInputType
  }

  export type GetCustomerProductHistoryAggregateType<T extends CustomerProductHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerProductHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerProductHistory[P]>
      : GetScalarType<T[P], AggregateCustomerProductHistory[P]>
  }




  export type CustomerProductHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerProductHistoryWhereInput
    orderBy?: CustomerProductHistoryOrderByWithAggregationInput | CustomerProductHistoryOrderByWithAggregationInput[]
    by: CustomerProductHistoryScalarFieldEnum[] | CustomerProductHistoryScalarFieldEnum
    having?: CustomerProductHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerProductHistoryCountAggregateInputType | true
    _min?: CustomerProductHistoryMinAggregateInputType
    _max?: CustomerProductHistoryMaxAggregateInputType
  }

  export type CustomerProductHistoryGroupByOutputType = {
    id: string
    customerId: string
    adminId: string
    productId: string
    purchaseDate: Date
    renewal: boolean
    renewPeriod: $Enums.renewPeriod
    expiryDate: Date | null
    renewalDate: Date | null
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerProductHistoryCountAggregateOutputType | null
    _min: CustomerProductHistoryMinAggregateOutputType | null
    _max: CustomerProductHistoryMaxAggregateOutputType | null
  }

  type GetCustomerProductHistoryGroupByPayload<T extends CustomerProductHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerProductHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerProductHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerProductHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerProductHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CustomerProductHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    adminId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewal?: boolean
    renewPeriod?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    renewals?: boolean | CustomerProductHistory$renewalsArgs<ExtArgs>
    _count?: boolean | CustomerProductHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProductHistory"]>

  export type CustomerProductHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    adminId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewal?: boolean
    renewPeriod?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProductHistory"]>

  export type CustomerProductHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    adminId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewal?: boolean
    renewPeriod?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerProductHistory"]>

  export type CustomerProductHistorySelectScalar = {
    id?: boolean
    customerId?: boolean
    adminId?: boolean
    productId?: boolean
    purchaseDate?: boolean
    renewal?: boolean
    renewPeriod?: boolean
    expiryDate?: boolean
    renewalDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerProductHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "adminId" | "productId" | "purchaseDate" | "renewal" | "renewPeriod" | "expiryDate" | "renewalDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["customerProductHistory"]>
  export type CustomerProductHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    renewals?: boolean | CustomerProductHistory$renewalsArgs<ExtArgs>
    _count?: boolean | CustomerProductHistoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerProductHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type CustomerProductHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    admin?: boolean | AdminDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $CustomerProductHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerProductHistory"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      admin: Prisma.$AdminPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      renewals: Prisma.$ProductRenewalHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      adminId: string
      productId: string
      purchaseDate: Date
      renewal: boolean
      renewPeriod: $Enums.renewPeriod
      expiryDate: Date | null
      renewalDate: Date | null
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerProductHistory"]>
    composites: {}
  }

  type CustomerProductHistoryGetPayload<S extends boolean | null | undefined | CustomerProductHistoryDefaultArgs> = $Result.GetResult<Prisma.$CustomerProductHistoryPayload, S>

  type CustomerProductHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerProductHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerProductHistoryCountAggregateInputType | true
    }

  export interface CustomerProductHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerProductHistory'], meta: { name: 'CustomerProductHistory' } }
    /**
     * Find zero or one CustomerProductHistory that matches the filter.
     * @param {CustomerProductHistoryFindUniqueArgs} args - Arguments to find a CustomerProductHistory
     * @example
     * // Get one CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerProductHistoryFindUniqueArgs>(args: SelectSubset<T, CustomerProductHistoryFindUniqueArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerProductHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerProductHistoryFindUniqueOrThrowArgs} args - Arguments to find a CustomerProductHistory
     * @example
     * // Get one CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerProductHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerProductHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProductHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryFindFirstArgs} args - Arguments to find a CustomerProductHistory
     * @example
     * // Get one CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerProductHistoryFindFirstArgs>(args?: SelectSubset<T, CustomerProductHistoryFindFirstArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerProductHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryFindFirstOrThrowArgs} args - Arguments to find a CustomerProductHistory
     * @example
     * // Get one CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerProductHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerProductHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerProductHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerProductHistories
     * const customerProductHistories = await prisma.customerProductHistory.findMany()
     * 
     * // Get first 10 CustomerProductHistories
     * const customerProductHistories = await prisma.customerProductHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerProductHistoryWithIdOnly = await prisma.customerProductHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerProductHistoryFindManyArgs>(args?: SelectSubset<T, CustomerProductHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerProductHistory.
     * @param {CustomerProductHistoryCreateArgs} args - Arguments to create a CustomerProductHistory.
     * @example
     * // Create one CustomerProductHistory
     * const CustomerProductHistory = await prisma.customerProductHistory.create({
     *   data: {
     *     // ... data to create a CustomerProductHistory
     *   }
     * })
     * 
     */
    create<T extends CustomerProductHistoryCreateArgs>(args: SelectSubset<T, CustomerProductHistoryCreateArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerProductHistories.
     * @param {CustomerProductHistoryCreateManyArgs} args - Arguments to create many CustomerProductHistories.
     * @example
     * // Create many CustomerProductHistories
     * const customerProductHistory = await prisma.customerProductHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerProductHistoryCreateManyArgs>(args?: SelectSubset<T, CustomerProductHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerProductHistories and returns the data saved in the database.
     * @param {CustomerProductHistoryCreateManyAndReturnArgs} args - Arguments to create many CustomerProductHistories.
     * @example
     * // Create many CustomerProductHistories
     * const customerProductHistory = await prisma.customerProductHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerProductHistories and only return the `id`
     * const customerProductHistoryWithIdOnly = await prisma.customerProductHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerProductHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerProductHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerProductHistory.
     * @param {CustomerProductHistoryDeleteArgs} args - Arguments to delete one CustomerProductHistory.
     * @example
     * // Delete one CustomerProductHistory
     * const CustomerProductHistory = await prisma.customerProductHistory.delete({
     *   where: {
     *     // ... filter to delete one CustomerProductHistory
     *   }
     * })
     * 
     */
    delete<T extends CustomerProductHistoryDeleteArgs>(args: SelectSubset<T, CustomerProductHistoryDeleteArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerProductHistory.
     * @param {CustomerProductHistoryUpdateArgs} args - Arguments to update one CustomerProductHistory.
     * @example
     * // Update one CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerProductHistoryUpdateArgs>(args: SelectSubset<T, CustomerProductHistoryUpdateArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerProductHistories.
     * @param {CustomerProductHistoryDeleteManyArgs} args - Arguments to filter CustomerProductHistories to delete.
     * @example
     * // Delete a few CustomerProductHistories
     * const { count } = await prisma.customerProductHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerProductHistoryDeleteManyArgs>(args?: SelectSubset<T, CustomerProductHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProductHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerProductHistories
     * const customerProductHistory = await prisma.customerProductHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerProductHistoryUpdateManyArgs>(args: SelectSubset<T, CustomerProductHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerProductHistories and returns the data updated in the database.
     * @param {CustomerProductHistoryUpdateManyAndReturnArgs} args - Arguments to update many CustomerProductHistories.
     * @example
     * // Update many CustomerProductHistories
     * const customerProductHistory = await prisma.customerProductHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerProductHistories and only return the `id`
     * const customerProductHistoryWithIdOnly = await prisma.customerProductHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerProductHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerProductHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerProductHistory.
     * @param {CustomerProductHistoryUpsertArgs} args - Arguments to update or create a CustomerProductHistory.
     * @example
     * // Update or create a CustomerProductHistory
     * const customerProductHistory = await prisma.customerProductHistory.upsert({
     *   create: {
     *     // ... data to create a CustomerProductHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerProductHistory we want to update
     *   }
     * })
     */
    upsert<T extends CustomerProductHistoryUpsertArgs>(args: SelectSubset<T, CustomerProductHistoryUpsertArgs<ExtArgs>>): Prisma__CustomerProductHistoryClient<$Result.GetResult<Prisma.$CustomerProductHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerProductHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryCountArgs} args - Arguments to filter CustomerProductHistories to count.
     * @example
     * // Count the number of CustomerProductHistories
     * const count = await prisma.customerProductHistory.count({
     *   where: {
     *     // ... the filter for the CustomerProductHistories we want to count
     *   }
     * })
    **/
    count<T extends CustomerProductHistoryCountArgs>(
      args?: Subset<T, CustomerProductHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerProductHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerProductHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerProductHistoryAggregateArgs>(args: Subset<T, CustomerProductHistoryAggregateArgs>): Prisma.PrismaPromise<GetCustomerProductHistoryAggregateType<T>>

    /**
     * Group by CustomerProductHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerProductHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerProductHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerProductHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CustomerProductHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerProductHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerProductHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerProductHistory model
   */
  readonly fields: CustomerProductHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerProductHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerProductHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    renewals<T extends CustomerProductHistory$renewalsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerProductHistory$renewalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductRenewalHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerProductHistory model
   */
  interface CustomerProductHistoryFieldRefs {
    readonly id: FieldRef<"CustomerProductHistory", 'String'>
    readonly customerId: FieldRef<"CustomerProductHistory", 'String'>
    readonly adminId: FieldRef<"CustomerProductHistory", 'String'>
    readonly productId: FieldRef<"CustomerProductHistory", 'String'>
    readonly purchaseDate: FieldRef<"CustomerProductHistory", 'DateTime'>
    readonly renewal: FieldRef<"CustomerProductHistory", 'Boolean'>
    readonly renewPeriod: FieldRef<"CustomerProductHistory", 'renewPeriod'>
    readonly expiryDate: FieldRef<"CustomerProductHistory", 'DateTime'>
    readonly renewalDate: FieldRef<"CustomerProductHistory", 'DateTime'>
    readonly status: FieldRef<"CustomerProductHistory", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerProductHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerProductHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerProductHistory findUnique
   */
  export type CustomerProductHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProductHistory to fetch.
     */
    where: CustomerProductHistoryWhereUniqueInput
  }

  /**
   * CustomerProductHistory findUniqueOrThrow
   */
  export type CustomerProductHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProductHistory to fetch.
     */
    where: CustomerProductHistoryWhereUniqueInput
  }

  /**
   * CustomerProductHistory findFirst
   */
  export type CustomerProductHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProductHistory to fetch.
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductHistories to fetch.
     */
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProductHistories.
     */
    cursor?: CustomerProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProductHistories.
     */
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * CustomerProductHistory findFirstOrThrow
   */
  export type CustomerProductHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProductHistory to fetch.
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductHistories to fetch.
     */
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerProductHistories.
     */
    cursor?: CustomerProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerProductHistories.
     */
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * CustomerProductHistory findMany
   */
  export type CustomerProductHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CustomerProductHistories to fetch.
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerProductHistories to fetch.
     */
    orderBy?: CustomerProductHistoryOrderByWithRelationInput | CustomerProductHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerProductHistories.
     */
    cursor?: CustomerProductHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerProductHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerProductHistories.
     */
    skip?: number
    distinct?: CustomerProductHistoryScalarFieldEnum | CustomerProductHistoryScalarFieldEnum[]
  }

  /**
   * CustomerProductHistory create
   */
  export type CustomerProductHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerProductHistory.
     */
    data: XOR<CustomerProductHistoryCreateInput, CustomerProductHistoryUncheckedCreateInput>
  }

  /**
   * CustomerProductHistory createMany
   */
  export type CustomerProductHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerProductHistories.
     */
    data: CustomerProductHistoryCreateManyInput | CustomerProductHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerProductHistory createManyAndReturn
   */
  export type CustomerProductHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerProductHistories.
     */
    data: CustomerProductHistoryCreateManyInput | CustomerProductHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProductHistory update
   */
  export type CustomerProductHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerProductHistory.
     */
    data: XOR<CustomerProductHistoryUpdateInput, CustomerProductHistoryUncheckedUpdateInput>
    /**
     * Choose, which CustomerProductHistory to update.
     */
    where: CustomerProductHistoryWhereUniqueInput
  }

  /**
   * CustomerProductHistory updateMany
   */
  export type CustomerProductHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerProductHistories.
     */
    data: XOR<CustomerProductHistoryUpdateManyMutationInput, CustomerProductHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProductHistories to update
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * Limit how many CustomerProductHistories to update.
     */
    limit?: number
  }

  /**
   * CustomerProductHistory updateManyAndReturn
   */
  export type CustomerProductHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * The data used to update CustomerProductHistories.
     */
    data: XOR<CustomerProductHistoryUpdateManyMutationInput, CustomerProductHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CustomerProductHistories to update
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * Limit how many CustomerProductHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerProductHistory upsert
   */
  export type CustomerProductHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerProductHistory to update in case it exists.
     */
    where: CustomerProductHistoryWhereUniqueInput
    /**
     * In case the CustomerProductHistory found by the `where` argument doesn't exist, create a new CustomerProductHistory with this data.
     */
    create: XOR<CustomerProductHistoryCreateInput, CustomerProductHistoryUncheckedCreateInput>
    /**
     * In case the CustomerProductHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerProductHistoryUpdateInput, CustomerProductHistoryUncheckedUpdateInput>
  }

  /**
   * CustomerProductHistory delete
   */
  export type CustomerProductHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
    /**
     * Filter which CustomerProductHistory to delete.
     */
    where: CustomerProductHistoryWhereUniqueInput
  }

  /**
   * CustomerProductHistory deleteMany
   */
  export type CustomerProductHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerProductHistories to delete
     */
    where?: CustomerProductHistoryWhereInput
    /**
     * Limit how many CustomerProductHistories to delete.
     */
    limit?: number
  }

  /**
   * CustomerProductHistory.renewals
   */
  export type CustomerProductHistory$renewalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductRenewalHistory
     */
    select?: ProductRenewalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductRenewalHistory
     */
    omit?: ProductRenewalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductRenewalHistoryInclude<ExtArgs> | null
    where?: ProductRenewalHistoryWhereInput
    orderBy?: ProductRenewalHistoryOrderByWithRelationInput | ProductRenewalHistoryOrderByWithRelationInput[]
    cursor?: ProductRenewalHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductRenewalHistoryScalarFieldEnum | ProductRenewalHistoryScalarFieldEnum[]
  }

  /**
   * CustomerProductHistory without action
   */
  export type CustomerProductHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerProductHistory
     */
    select?: CustomerProductHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerProductHistory
     */
    omit?: CustomerProductHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerProductHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AdminCustomField
   */

  export type AggregateAdminCustomField = {
    _count: AdminCustomFieldCountAggregateOutputType | null
    _min: AdminCustomFieldMinAggregateOutputType | null
    _max: AdminCustomFieldMaxAggregateOutputType | null
  }

  export type AdminCustomFieldMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    fieldName: string | null
    fieldType: string | null
    isRequired: boolean | null
    isMultiSelect: boolean | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCustomFieldMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    fieldName: string | null
    fieldType: string | null
    isRequired: boolean | null
    isMultiSelect: boolean | null
    status: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCustomFieldCountAggregateOutputType = {
    id: number
    adminId: number
    fieldName: number
    fieldType: number
    isRequired: number
    options: number
    isMultiSelect: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminCustomFieldMinAggregateInputType = {
    id?: true
    adminId?: true
    fieldName?: true
    fieldType?: true
    isRequired?: true
    isMultiSelect?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCustomFieldMaxAggregateInputType = {
    id?: true
    adminId?: true
    fieldName?: true
    fieldType?: true
    isRequired?: true
    isMultiSelect?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCustomFieldCountAggregateInputType = {
    id?: true
    adminId?: true
    fieldName?: true
    fieldType?: true
    isRequired?: true
    options?: true
    isMultiSelect?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminCustomFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminCustomField to aggregate.
     */
    where?: AdminCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCustomFields to fetch.
     */
    orderBy?: AdminCustomFieldOrderByWithRelationInput | AdminCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminCustomFields
    **/
    _count?: true | AdminCustomFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminCustomFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminCustomFieldMaxAggregateInputType
  }

  export type GetAdminCustomFieldAggregateType<T extends AdminCustomFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminCustomField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminCustomField[P]>
      : GetScalarType<T[P], AggregateAdminCustomField[P]>
  }




  export type AdminCustomFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminCustomFieldWhereInput
    orderBy?: AdminCustomFieldOrderByWithAggregationInput | AdminCustomFieldOrderByWithAggregationInput[]
    by: AdminCustomFieldScalarFieldEnum[] | AdminCustomFieldScalarFieldEnum
    having?: AdminCustomFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCustomFieldCountAggregateInputType | true
    _min?: AdminCustomFieldMinAggregateInputType
    _max?: AdminCustomFieldMaxAggregateInputType
  }

  export type AdminCustomFieldGroupByOutputType = {
    id: string
    adminId: string
    fieldName: string
    fieldType: string
    isRequired: boolean
    options: string[]
    isMultiSelect: boolean
    status: boolean
    createdAt: Date
    updatedAt: Date
    _count: AdminCustomFieldCountAggregateOutputType | null
    _min: AdminCustomFieldMinAggregateOutputType | null
    _max: AdminCustomFieldMaxAggregateOutputType | null
  }

  type GetAdminCustomFieldGroupByPayload<T extends AdminCustomFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminCustomFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminCustomFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminCustomFieldGroupByOutputType[P]>
            : GetScalarType<T[P], AdminCustomFieldGroupByOutputType[P]>
        }
      >
    >


  export type AdminCustomFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminCustomField"]>

  export type AdminCustomFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminCustomField"]>

  export type AdminCustomFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminCustomField"]>

  export type AdminCustomFieldSelectScalar = {
    id?: boolean
    adminId?: boolean
    fieldName?: boolean
    fieldType?: boolean
    isRequired?: boolean
    options?: boolean
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminCustomFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "fieldName" | "fieldType" | "isRequired" | "options" | "isMultiSelect" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["adminCustomField"]>
  export type AdminCustomFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminCustomFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }
  export type AdminCustomFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | AdminDefaultArgs<ExtArgs>
  }

  export type $AdminCustomFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminCustomField"
    objects: {
      admin: Prisma.$AdminPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      fieldName: string
      fieldType: string
      isRequired: boolean
      options: string[]
      isMultiSelect: boolean
      status: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminCustomField"]>
    composites: {}
  }

  type AdminCustomFieldGetPayload<S extends boolean | null | undefined | AdminCustomFieldDefaultArgs> = $Result.GetResult<Prisma.$AdminCustomFieldPayload, S>

  type AdminCustomFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminCustomFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCustomFieldCountAggregateInputType | true
    }

  export interface AdminCustomFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminCustomField'], meta: { name: 'AdminCustomField' } }
    /**
     * Find zero or one AdminCustomField that matches the filter.
     * @param {AdminCustomFieldFindUniqueArgs} args - Arguments to find a AdminCustomField
     * @example
     * // Get one AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminCustomFieldFindUniqueArgs>(args: SelectSubset<T, AdminCustomFieldFindUniqueArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminCustomField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminCustomFieldFindUniqueOrThrowArgs} args - Arguments to find a AdminCustomField
     * @example
     * // Get one AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminCustomFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminCustomFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminCustomField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldFindFirstArgs} args - Arguments to find a AdminCustomField
     * @example
     * // Get one AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminCustomFieldFindFirstArgs>(args?: SelectSubset<T, AdminCustomFieldFindFirstArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminCustomField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldFindFirstOrThrowArgs} args - Arguments to find a AdminCustomField
     * @example
     * // Get one AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminCustomFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminCustomFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminCustomFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminCustomFields
     * const adminCustomFields = await prisma.adminCustomField.findMany()
     * 
     * // Get first 10 AdminCustomFields
     * const adminCustomFields = await prisma.adminCustomField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminCustomFieldWithIdOnly = await prisma.adminCustomField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminCustomFieldFindManyArgs>(args?: SelectSubset<T, AdminCustomFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminCustomField.
     * @param {AdminCustomFieldCreateArgs} args - Arguments to create a AdminCustomField.
     * @example
     * // Create one AdminCustomField
     * const AdminCustomField = await prisma.adminCustomField.create({
     *   data: {
     *     // ... data to create a AdminCustomField
     *   }
     * })
     * 
     */
    create<T extends AdminCustomFieldCreateArgs>(args: SelectSubset<T, AdminCustomFieldCreateArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminCustomFields.
     * @param {AdminCustomFieldCreateManyArgs} args - Arguments to create many AdminCustomFields.
     * @example
     * // Create many AdminCustomFields
     * const adminCustomField = await prisma.adminCustomField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCustomFieldCreateManyArgs>(args?: SelectSubset<T, AdminCustomFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminCustomFields and returns the data saved in the database.
     * @param {AdminCustomFieldCreateManyAndReturnArgs} args - Arguments to create many AdminCustomFields.
     * @example
     * // Create many AdminCustomFields
     * const adminCustomField = await prisma.adminCustomField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminCustomFields and only return the `id`
     * const adminCustomFieldWithIdOnly = await prisma.adminCustomField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminCustomFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminCustomFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminCustomField.
     * @param {AdminCustomFieldDeleteArgs} args - Arguments to delete one AdminCustomField.
     * @example
     * // Delete one AdminCustomField
     * const AdminCustomField = await prisma.adminCustomField.delete({
     *   where: {
     *     // ... filter to delete one AdminCustomField
     *   }
     * })
     * 
     */
    delete<T extends AdminCustomFieldDeleteArgs>(args: SelectSubset<T, AdminCustomFieldDeleteArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminCustomField.
     * @param {AdminCustomFieldUpdateArgs} args - Arguments to update one AdminCustomField.
     * @example
     * // Update one AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminCustomFieldUpdateArgs>(args: SelectSubset<T, AdminCustomFieldUpdateArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminCustomFields.
     * @param {AdminCustomFieldDeleteManyArgs} args - Arguments to filter AdminCustomFields to delete.
     * @example
     * // Delete a few AdminCustomFields
     * const { count } = await prisma.adminCustomField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminCustomFieldDeleteManyArgs>(args?: SelectSubset<T, AdminCustomFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminCustomFields
     * const adminCustomField = await prisma.adminCustomField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminCustomFieldUpdateManyArgs>(args: SelectSubset<T, AdminCustomFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminCustomFields and returns the data updated in the database.
     * @param {AdminCustomFieldUpdateManyAndReturnArgs} args - Arguments to update many AdminCustomFields.
     * @example
     * // Update many AdminCustomFields
     * const adminCustomField = await prisma.adminCustomField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminCustomFields and only return the `id`
     * const adminCustomFieldWithIdOnly = await prisma.adminCustomField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminCustomFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminCustomFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminCustomField.
     * @param {AdminCustomFieldUpsertArgs} args - Arguments to update or create a AdminCustomField.
     * @example
     * // Update or create a AdminCustomField
     * const adminCustomField = await prisma.adminCustomField.upsert({
     *   create: {
     *     // ... data to create a AdminCustomField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminCustomField we want to update
     *   }
     * })
     */
    upsert<T extends AdminCustomFieldUpsertArgs>(args: SelectSubset<T, AdminCustomFieldUpsertArgs<ExtArgs>>): Prisma__AdminCustomFieldClient<$Result.GetResult<Prisma.$AdminCustomFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminCustomFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldCountArgs} args - Arguments to filter AdminCustomFields to count.
     * @example
     * // Count the number of AdminCustomFields
     * const count = await prisma.adminCustomField.count({
     *   where: {
     *     // ... the filter for the AdminCustomFields we want to count
     *   }
     * })
    **/
    count<T extends AdminCustomFieldCountArgs>(
      args?: Subset<T, AdminCustomFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCustomFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminCustomFieldAggregateArgs>(args: Subset<T, AdminCustomFieldAggregateArgs>): Prisma.PrismaPromise<GetAdminCustomFieldAggregateType<T>>

    /**
     * Group by AdminCustomField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCustomFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminCustomFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminCustomFieldGroupByArgs['orderBy'] }
        : { orderBy?: AdminCustomFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminCustomFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminCustomFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminCustomField model
   */
  readonly fields: AdminCustomFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminCustomField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminCustomFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends AdminDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdminDefaultArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminCustomField model
   */
  interface AdminCustomFieldFieldRefs {
    readonly id: FieldRef<"AdminCustomField", 'String'>
    readonly adminId: FieldRef<"AdminCustomField", 'String'>
    readonly fieldName: FieldRef<"AdminCustomField", 'String'>
    readonly fieldType: FieldRef<"AdminCustomField", 'String'>
    readonly isRequired: FieldRef<"AdminCustomField", 'Boolean'>
    readonly options: FieldRef<"AdminCustomField", 'String[]'>
    readonly isMultiSelect: FieldRef<"AdminCustomField", 'Boolean'>
    readonly status: FieldRef<"AdminCustomField", 'Boolean'>
    readonly createdAt: FieldRef<"AdminCustomField", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminCustomField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminCustomField findUnique
   */
  export type AdminCustomFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which AdminCustomField to fetch.
     */
    where: AdminCustomFieldWhereUniqueInput
  }

  /**
   * AdminCustomField findUniqueOrThrow
   */
  export type AdminCustomFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which AdminCustomField to fetch.
     */
    where: AdminCustomFieldWhereUniqueInput
  }

  /**
   * AdminCustomField findFirst
   */
  export type AdminCustomFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which AdminCustomField to fetch.
     */
    where?: AdminCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCustomFields to fetch.
     */
    orderBy?: AdminCustomFieldOrderByWithRelationInput | AdminCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminCustomFields.
     */
    cursor?: AdminCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminCustomFields.
     */
    distinct?: AdminCustomFieldScalarFieldEnum | AdminCustomFieldScalarFieldEnum[]
  }

  /**
   * AdminCustomField findFirstOrThrow
   */
  export type AdminCustomFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which AdminCustomField to fetch.
     */
    where?: AdminCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCustomFields to fetch.
     */
    orderBy?: AdminCustomFieldOrderByWithRelationInput | AdminCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminCustomFields.
     */
    cursor?: AdminCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCustomFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminCustomFields.
     */
    distinct?: AdminCustomFieldScalarFieldEnum | AdminCustomFieldScalarFieldEnum[]
  }

  /**
   * AdminCustomField findMany
   */
  export type AdminCustomFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter, which AdminCustomFields to fetch.
     */
    where?: AdminCustomFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminCustomFields to fetch.
     */
    orderBy?: AdminCustomFieldOrderByWithRelationInput | AdminCustomFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminCustomFields.
     */
    cursor?: AdminCustomFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminCustomFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminCustomFields.
     */
    skip?: number
    distinct?: AdminCustomFieldScalarFieldEnum | AdminCustomFieldScalarFieldEnum[]
  }

  /**
   * AdminCustomField create
   */
  export type AdminCustomFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminCustomField.
     */
    data: XOR<AdminCustomFieldCreateInput, AdminCustomFieldUncheckedCreateInput>
  }

  /**
   * AdminCustomField createMany
   */
  export type AdminCustomFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminCustomFields.
     */
    data: AdminCustomFieldCreateManyInput | AdminCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminCustomField createManyAndReturn
   */
  export type AdminCustomFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to create many AdminCustomFields.
     */
    data: AdminCustomFieldCreateManyInput | AdminCustomFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminCustomField update
   */
  export type AdminCustomFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminCustomField.
     */
    data: XOR<AdminCustomFieldUpdateInput, AdminCustomFieldUncheckedUpdateInput>
    /**
     * Choose, which AdminCustomField to update.
     */
    where: AdminCustomFieldWhereUniqueInput
  }

  /**
   * AdminCustomField updateMany
   */
  export type AdminCustomFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminCustomFields.
     */
    data: XOR<AdminCustomFieldUpdateManyMutationInput, AdminCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which AdminCustomFields to update
     */
    where?: AdminCustomFieldWhereInput
    /**
     * Limit how many AdminCustomFields to update.
     */
    limit?: number
  }

  /**
   * AdminCustomField updateManyAndReturn
   */
  export type AdminCustomFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * The data used to update AdminCustomFields.
     */
    data: XOR<AdminCustomFieldUpdateManyMutationInput, AdminCustomFieldUncheckedUpdateManyInput>
    /**
     * Filter which AdminCustomFields to update
     */
    where?: AdminCustomFieldWhereInput
    /**
     * Limit how many AdminCustomFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminCustomField upsert
   */
  export type AdminCustomFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminCustomField to update in case it exists.
     */
    where: AdminCustomFieldWhereUniqueInput
    /**
     * In case the AdminCustomField found by the `where` argument doesn't exist, create a new AdminCustomField with this data.
     */
    create: XOR<AdminCustomFieldCreateInput, AdminCustomFieldUncheckedCreateInput>
    /**
     * In case the AdminCustomField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminCustomFieldUpdateInput, AdminCustomFieldUncheckedUpdateInput>
  }

  /**
   * AdminCustomField delete
   */
  export type AdminCustomFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
    /**
     * Filter which AdminCustomField to delete.
     */
    where: AdminCustomFieldWhereUniqueInput
  }

  /**
   * AdminCustomField deleteMany
   */
  export type AdminCustomFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminCustomFields to delete
     */
    where?: AdminCustomFieldWhereInput
    /**
     * Limit how many AdminCustomFields to delete.
     */
    limit?: number
  }

  /**
   * AdminCustomField without action
   */
  export type AdminCustomFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminCustomField
     */
    select?: AdminCustomFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminCustomField
     */
    omit?: AdminCustomFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminCustomFieldInclude<ExtArgs> | null
  }


  /**
   * Model LoginAudit
   */

  export type AggregateLoginAudit = {
    _count: LoginAuditCountAggregateOutputType | null
    _min: LoginAuditMinAggregateOutputType | null
    _max: LoginAuditMaxAggregateOutputType | null
  }

  export type LoginAuditMinAggregateOutputType = {
    id: string | null
    loginCredentialId: string | null
    attemptTime: Date | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LoginAuditMaxAggregateOutputType = {
    id: string | null
    loginCredentialId: string | null
    attemptTime: Date | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type LoginAuditCountAggregateOutputType = {
    id: number
    loginCredentialId: number
    attemptTime: number
    success: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type LoginAuditMinAggregateInputType = {
    id?: true
    loginCredentialId?: true
    attemptTime?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type LoginAuditMaxAggregateInputType = {
    id?: true
    loginCredentialId?: true
    attemptTime?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type LoginAuditCountAggregateInputType = {
    id?: true
    loginCredentialId?: true
    attemptTime?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type LoginAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAudit to aggregate.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginAudits
    **/
    _count?: true | LoginAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginAuditMaxAggregateInputType
  }

  export type GetLoginAuditAggregateType<T extends LoginAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginAudit[P]>
      : GetScalarType<T[P], AggregateLoginAudit[P]>
  }




  export type LoginAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginAuditWhereInput
    orderBy?: LoginAuditOrderByWithAggregationInput | LoginAuditOrderByWithAggregationInput[]
    by: LoginAuditScalarFieldEnum[] | LoginAuditScalarFieldEnum
    having?: LoginAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginAuditCountAggregateInputType | true
    _min?: LoginAuditMinAggregateInputType
    _max?: LoginAuditMaxAggregateInputType
  }

  export type LoginAuditGroupByOutputType = {
    id: string
    loginCredentialId: string
    attemptTime: Date
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt: Date
    _count: LoginAuditCountAggregateOutputType | null
    _min: LoginAuditMinAggregateOutputType | null
    _max: LoginAuditMaxAggregateOutputType | null
  }

  type GetLoginAuditGroupByPayload<T extends LoginAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginAuditGroupByOutputType[P]>
            : GetScalarType<T[P], LoginAuditGroupByOutputType[P]>
        }
      >
    >


  export type LoginAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginCredentialId?: boolean
    attemptTime?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginAudit"]>

  export type LoginAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginCredentialId?: boolean
    attemptTime?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginAudit"]>

  export type LoginAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    loginCredentialId?: boolean
    attemptTime?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["loginAudit"]>

  export type LoginAuditSelectScalar = {
    id?: boolean
    loginCredentialId?: boolean
    attemptTime?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type LoginAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "loginCredentialId" | "attemptTime" | "success" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["loginAudit"]>
  export type LoginAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }
  export type LoginAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }
  export type LoginAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    loginCredential?: boolean | LoginCredentialDefaultArgs<ExtArgs>
  }

  export type $LoginAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginAudit"
    objects: {
      loginCredential: Prisma.$LoginCredentialPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      loginCredentialId: string
      attemptTime: Date
      success: boolean
      ipAddress: string
      userAgent: string
      createdAt: Date
    }, ExtArgs["result"]["loginAudit"]>
    composites: {}
  }

  type LoginAuditGetPayload<S extends boolean | null | undefined | LoginAuditDefaultArgs> = $Result.GetResult<Prisma.$LoginAuditPayload, S>

  type LoginAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LoginAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LoginAuditCountAggregateInputType | true
    }

  export interface LoginAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginAudit'], meta: { name: 'LoginAudit' } }
    /**
     * Find zero or one LoginAudit that matches the filter.
     * @param {LoginAuditFindUniqueArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginAuditFindUniqueArgs>(args: SelectSubset<T, LoginAuditFindUniqueArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LoginAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LoginAuditFindUniqueOrThrowArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindFirstArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginAuditFindFirstArgs>(args?: SelectSubset<T, LoginAuditFindFirstArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LoginAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindFirstOrThrowArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LoginAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginAudits
     * const loginAudits = await prisma.loginAudit.findMany()
     * 
     * // Get first 10 LoginAudits
     * const loginAudits = await prisma.loginAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginAuditWithIdOnly = await prisma.loginAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginAuditFindManyArgs>(args?: SelectSubset<T, LoginAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LoginAudit.
     * @param {LoginAuditCreateArgs} args - Arguments to create a LoginAudit.
     * @example
     * // Create one LoginAudit
     * const LoginAudit = await prisma.loginAudit.create({
     *   data: {
     *     // ... data to create a LoginAudit
     *   }
     * })
     * 
     */
    create<T extends LoginAuditCreateArgs>(args: SelectSubset<T, LoginAuditCreateArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LoginAudits.
     * @param {LoginAuditCreateManyArgs} args - Arguments to create many LoginAudits.
     * @example
     * // Create many LoginAudits
     * const loginAudit = await prisma.loginAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginAuditCreateManyArgs>(args?: SelectSubset<T, LoginAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginAudits and returns the data saved in the database.
     * @param {LoginAuditCreateManyAndReturnArgs} args - Arguments to create many LoginAudits.
     * @example
     * // Create many LoginAudits
     * const loginAudit = await prisma.loginAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginAudits and only return the `id`
     * const loginAuditWithIdOnly = await prisma.loginAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LoginAudit.
     * @param {LoginAuditDeleteArgs} args - Arguments to delete one LoginAudit.
     * @example
     * // Delete one LoginAudit
     * const LoginAudit = await prisma.loginAudit.delete({
     *   where: {
     *     // ... filter to delete one LoginAudit
     *   }
     * })
     * 
     */
    delete<T extends LoginAuditDeleteArgs>(args: SelectSubset<T, LoginAuditDeleteArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LoginAudit.
     * @param {LoginAuditUpdateArgs} args - Arguments to update one LoginAudit.
     * @example
     * // Update one LoginAudit
     * const loginAudit = await prisma.loginAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginAuditUpdateArgs>(args: SelectSubset<T, LoginAuditUpdateArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LoginAudits.
     * @param {LoginAuditDeleteManyArgs} args - Arguments to filter LoginAudits to delete.
     * @example
     * // Delete a few LoginAudits
     * const { count } = await prisma.loginAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginAuditDeleteManyArgs>(args?: SelectSubset<T, LoginAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginAudits
     * const loginAudit = await prisma.loginAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginAuditUpdateManyArgs>(args: SelectSubset<T, LoginAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginAudits and returns the data updated in the database.
     * @param {LoginAuditUpdateManyAndReturnArgs} args - Arguments to update many LoginAudits.
     * @example
     * // Update many LoginAudits
     * const loginAudit = await prisma.loginAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LoginAudits and only return the `id`
     * const loginAuditWithIdOnly = await prisma.loginAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LoginAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, LoginAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LoginAudit.
     * @param {LoginAuditUpsertArgs} args - Arguments to update or create a LoginAudit.
     * @example
     * // Update or create a LoginAudit
     * const loginAudit = await prisma.loginAudit.upsert({
     *   create: {
     *     // ... data to create a LoginAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginAudit we want to update
     *   }
     * })
     */
    upsert<T extends LoginAuditUpsertArgs>(args: SelectSubset<T, LoginAuditUpsertArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LoginAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditCountArgs} args - Arguments to filter LoginAudits to count.
     * @example
     * // Count the number of LoginAudits
     * const count = await prisma.loginAudit.count({
     *   where: {
     *     // ... the filter for the LoginAudits we want to count
     *   }
     * })
    **/
    count<T extends LoginAuditCountArgs>(
      args?: Subset<T, LoginAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAuditAggregateArgs>(args: Subset<T, LoginAuditAggregateArgs>): Prisma.PrismaPromise<GetLoginAuditAggregateType<T>>

    /**
     * Group by LoginAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginAuditGroupByArgs['orderBy'] }
        : { orderBy?: LoginAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginAudit model
   */
  readonly fields: LoginAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    loginCredential<T extends LoginCredentialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LoginCredentialDefaultArgs<ExtArgs>>): Prisma__LoginCredentialClient<$Result.GetResult<Prisma.$LoginCredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginAudit model
   */
  interface LoginAuditFieldRefs {
    readonly id: FieldRef<"LoginAudit", 'String'>
    readonly loginCredentialId: FieldRef<"LoginAudit", 'String'>
    readonly attemptTime: FieldRef<"LoginAudit", 'DateTime'>
    readonly success: FieldRef<"LoginAudit", 'Boolean'>
    readonly ipAddress: FieldRef<"LoginAudit", 'String'>
    readonly userAgent: FieldRef<"LoginAudit", 'String'>
    readonly createdAt: FieldRef<"LoginAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginAudit findUnique
   */
  export type LoginAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit findUniqueOrThrow
   */
  export type LoginAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit findFirst
   */
  export type LoginAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAudits.
     */
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit findFirstOrThrow
   */
  export type LoginAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAudits.
     */
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit findMany
   */
  export type LoginAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudits to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit create
   */
  export type LoginAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginAudit.
     */
    data: XOR<LoginAuditCreateInput, LoginAuditUncheckedCreateInput>
  }

  /**
   * LoginAudit createMany
   */
  export type LoginAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginAudits.
     */
    data: LoginAuditCreateManyInput | LoginAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginAudit createManyAndReturn
   */
  export type LoginAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * The data used to create many LoginAudits.
     */
    data: LoginAuditCreateManyInput | LoginAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginAudit update
   */
  export type LoginAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginAudit.
     */
    data: XOR<LoginAuditUpdateInput, LoginAuditUncheckedUpdateInput>
    /**
     * Choose, which LoginAudit to update.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit updateMany
   */
  export type LoginAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginAudits.
     */
    data: XOR<LoginAuditUpdateManyMutationInput, LoginAuditUncheckedUpdateManyInput>
    /**
     * Filter which LoginAudits to update
     */
    where?: LoginAuditWhereInput
    /**
     * Limit how many LoginAudits to update.
     */
    limit?: number
  }

  /**
   * LoginAudit updateManyAndReturn
   */
  export type LoginAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * The data used to update LoginAudits.
     */
    data: XOR<LoginAuditUpdateManyMutationInput, LoginAuditUncheckedUpdateManyInput>
    /**
     * Filter which LoginAudits to update
     */
    where?: LoginAuditWhereInput
    /**
     * Limit how many LoginAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginAudit upsert
   */
  export type LoginAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginAudit to update in case it exists.
     */
    where: LoginAuditWhereUniqueInput
    /**
     * In case the LoginAudit found by the `where` argument doesn't exist, create a new LoginAudit with this data.
     */
    create: XOR<LoginAuditCreateInput, LoginAuditUncheckedCreateInput>
    /**
     * In case the LoginAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginAuditUpdateInput, LoginAuditUncheckedUpdateInput>
  }

  /**
   * LoginAudit delete
   */
  export type LoginAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter which LoginAudit to delete.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit deleteMany
   */
  export type LoginAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAudits to delete
     */
    where?: LoginAuditWhereInput
    /**
     * Limit how many LoginAudits to delete.
     */
    limit?: number
  }

  /**
   * LoginAudit without action
   */
  export type LoginAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LoginAudit
     */
    omit?: LoginAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
  }


  /**
   * Model PasswordOtp
   */

  export type AggregatePasswordOtp = {
    _count: PasswordOtpCountAggregateOutputType | null
    _min: PasswordOtpMinAggregateOutputType | null
    _max: PasswordOtpMaxAggregateOutputType | null
  }

  export type PasswordOtpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    purpose: string | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordOtpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    purpose: string | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordOtpCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    purpose: number
    used: number
    createdAt: number
    _all: number
  }


  export type PasswordOtpMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    purpose?: true
    used?: true
    createdAt?: true
  }

  export type PasswordOtpMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    purpose?: true
    used?: true
    createdAt?: true
  }

  export type PasswordOtpCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    purpose?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordOtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordOtp to aggregate.
     */
    where?: PasswordOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordOtps to fetch.
     */
    orderBy?: PasswordOtpOrderByWithRelationInput | PasswordOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordOtps
    **/
    _count?: true | PasswordOtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordOtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordOtpMaxAggregateInputType
  }

  export type GetPasswordOtpAggregateType<T extends PasswordOtpAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordOtp[P]>
      : GetScalarType<T[P], AggregatePasswordOtp[P]>
  }




  export type PasswordOtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordOtpWhereInput
    orderBy?: PasswordOtpOrderByWithAggregationInput | PasswordOtpOrderByWithAggregationInput[]
    by: PasswordOtpScalarFieldEnum[] | PasswordOtpScalarFieldEnum
    having?: PasswordOtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordOtpCountAggregateInputType | true
    _min?: PasswordOtpMinAggregateInputType
    _max?: PasswordOtpMaxAggregateInputType
  }

  export type PasswordOtpGroupByOutputType = {
    id: string
    userId: string
    otp: string
    purpose: string
    used: boolean
    createdAt: Date
    _count: PasswordOtpCountAggregateOutputType | null
    _min: PasswordOtpMinAggregateOutputType | null
    _max: PasswordOtpMaxAggregateOutputType | null
  }

  type GetPasswordOtpGroupByPayload<T extends PasswordOtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordOtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordOtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordOtpGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordOtpGroupByOutputType[P]>
        }
      >
    >


  export type PasswordOtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    purpose?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordOtp"]>

  export type PasswordOtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    purpose?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordOtp"]>

  export type PasswordOtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    purpose?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["passwordOtp"]>

  export type PasswordOtpSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    purpose?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type PasswordOtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "otp" | "purpose" | "used" | "createdAt", ExtArgs["result"]["passwordOtp"]>

  export type $PasswordOtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordOtp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otp: string
      purpose: string
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["passwordOtp"]>
    composites: {}
  }

  type PasswordOtpGetPayload<S extends boolean | null | undefined | PasswordOtpDefaultArgs> = $Result.GetResult<Prisma.$PasswordOtpPayload, S>

  type PasswordOtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordOtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordOtpCountAggregateInputType | true
    }

  export interface PasswordOtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordOtp'], meta: { name: 'PasswordOtp' } }
    /**
     * Find zero or one PasswordOtp that matches the filter.
     * @param {PasswordOtpFindUniqueArgs} args - Arguments to find a PasswordOtp
     * @example
     * // Get one PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordOtpFindUniqueArgs>(args: SelectSubset<T, PasswordOtpFindUniqueArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordOtp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordOtpFindUniqueOrThrowArgs} args - Arguments to find a PasswordOtp
     * @example
     * // Get one PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordOtpFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordOtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordOtp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpFindFirstArgs} args - Arguments to find a PasswordOtp
     * @example
     * // Get one PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordOtpFindFirstArgs>(args?: SelectSubset<T, PasswordOtpFindFirstArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordOtp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpFindFirstOrThrowArgs} args - Arguments to find a PasswordOtp
     * @example
     * // Get one PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordOtpFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordOtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordOtps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordOtps
     * const passwordOtps = await prisma.passwordOtp.findMany()
     * 
     * // Get first 10 PasswordOtps
     * const passwordOtps = await prisma.passwordOtp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordOtpWithIdOnly = await prisma.passwordOtp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordOtpFindManyArgs>(args?: SelectSubset<T, PasswordOtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordOtp.
     * @param {PasswordOtpCreateArgs} args - Arguments to create a PasswordOtp.
     * @example
     * // Create one PasswordOtp
     * const PasswordOtp = await prisma.passwordOtp.create({
     *   data: {
     *     // ... data to create a PasswordOtp
     *   }
     * })
     * 
     */
    create<T extends PasswordOtpCreateArgs>(args: SelectSubset<T, PasswordOtpCreateArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordOtps.
     * @param {PasswordOtpCreateManyArgs} args - Arguments to create many PasswordOtps.
     * @example
     * // Create many PasswordOtps
     * const passwordOtp = await prisma.passwordOtp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordOtpCreateManyArgs>(args?: SelectSubset<T, PasswordOtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordOtps and returns the data saved in the database.
     * @param {PasswordOtpCreateManyAndReturnArgs} args - Arguments to create many PasswordOtps.
     * @example
     * // Create many PasswordOtps
     * const passwordOtp = await prisma.passwordOtp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordOtps and only return the `id`
     * const passwordOtpWithIdOnly = await prisma.passwordOtp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordOtpCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordOtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordOtp.
     * @param {PasswordOtpDeleteArgs} args - Arguments to delete one PasswordOtp.
     * @example
     * // Delete one PasswordOtp
     * const PasswordOtp = await prisma.passwordOtp.delete({
     *   where: {
     *     // ... filter to delete one PasswordOtp
     *   }
     * })
     * 
     */
    delete<T extends PasswordOtpDeleteArgs>(args: SelectSubset<T, PasswordOtpDeleteArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordOtp.
     * @param {PasswordOtpUpdateArgs} args - Arguments to update one PasswordOtp.
     * @example
     * // Update one PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordOtpUpdateArgs>(args: SelectSubset<T, PasswordOtpUpdateArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordOtps.
     * @param {PasswordOtpDeleteManyArgs} args - Arguments to filter PasswordOtps to delete.
     * @example
     * // Delete a few PasswordOtps
     * const { count } = await prisma.passwordOtp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordOtpDeleteManyArgs>(args?: SelectSubset<T, PasswordOtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordOtps
     * const passwordOtp = await prisma.passwordOtp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordOtpUpdateManyArgs>(args: SelectSubset<T, PasswordOtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordOtps and returns the data updated in the database.
     * @param {PasswordOtpUpdateManyAndReturnArgs} args - Arguments to update many PasswordOtps.
     * @example
     * // Update many PasswordOtps
     * const passwordOtp = await prisma.passwordOtp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordOtps and only return the `id`
     * const passwordOtpWithIdOnly = await prisma.passwordOtp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordOtpUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordOtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordOtp.
     * @param {PasswordOtpUpsertArgs} args - Arguments to update or create a PasswordOtp.
     * @example
     * // Update or create a PasswordOtp
     * const passwordOtp = await prisma.passwordOtp.upsert({
     *   create: {
     *     // ... data to create a PasswordOtp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordOtp we want to update
     *   }
     * })
     */
    upsert<T extends PasswordOtpUpsertArgs>(args: SelectSubset<T, PasswordOtpUpsertArgs<ExtArgs>>): Prisma__PasswordOtpClient<$Result.GetResult<Prisma.$PasswordOtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordOtps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpCountArgs} args - Arguments to filter PasswordOtps to count.
     * @example
     * // Count the number of PasswordOtps
     * const count = await prisma.passwordOtp.count({
     *   where: {
     *     // ... the filter for the PasswordOtps we want to count
     *   }
     * })
    **/
    count<T extends PasswordOtpCountArgs>(
      args?: Subset<T, PasswordOtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordOtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordOtpAggregateArgs>(args: Subset<T, PasswordOtpAggregateArgs>): Prisma.PrismaPromise<GetPasswordOtpAggregateType<T>>

    /**
     * Group by PasswordOtp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordOtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordOtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordOtpGroupByArgs['orderBy'] }
        : { orderBy?: PasswordOtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordOtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordOtp model
   */
  readonly fields: PasswordOtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordOtp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordOtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordOtp model
   */
  interface PasswordOtpFieldRefs {
    readonly id: FieldRef<"PasswordOtp", 'String'>
    readonly userId: FieldRef<"PasswordOtp", 'String'>
    readonly otp: FieldRef<"PasswordOtp", 'String'>
    readonly purpose: FieldRef<"PasswordOtp", 'String'>
    readonly used: FieldRef<"PasswordOtp", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordOtp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordOtp findUnique
   */
  export type PasswordOtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter, which PasswordOtp to fetch.
     */
    where: PasswordOtpWhereUniqueInput
  }

  /**
   * PasswordOtp findUniqueOrThrow
   */
  export type PasswordOtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter, which PasswordOtp to fetch.
     */
    where: PasswordOtpWhereUniqueInput
  }

  /**
   * PasswordOtp findFirst
   */
  export type PasswordOtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter, which PasswordOtp to fetch.
     */
    where?: PasswordOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordOtps to fetch.
     */
    orderBy?: PasswordOtpOrderByWithRelationInput | PasswordOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordOtps.
     */
    cursor?: PasswordOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordOtps.
     */
    distinct?: PasswordOtpScalarFieldEnum | PasswordOtpScalarFieldEnum[]
  }

  /**
   * PasswordOtp findFirstOrThrow
   */
  export type PasswordOtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter, which PasswordOtp to fetch.
     */
    where?: PasswordOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordOtps to fetch.
     */
    orderBy?: PasswordOtpOrderByWithRelationInput | PasswordOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordOtps.
     */
    cursor?: PasswordOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordOtps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordOtps.
     */
    distinct?: PasswordOtpScalarFieldEnum | PasswordOtpScalarFieldEnum[]
  }

  /**
   * PasswordOtp findMany
   */
  export type PasswordOtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter, which PasswordOtps to fetch.
     */
    where?: PasswordOtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordOtps to fetch.
     */
    orderBy?: PasswordOtpOrderByWithRelationInput | PasswordOtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordOtps.
     */
    cursor?: PasswordOtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordOtps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordOtps.
     */
    skip?: number
    distinct?: PasswordOtpScalarFieldEnum | PasswordOtpScalarFieldEnum[]
  }

  /**
   * PasswordOtp create
   */
  export type PasswordOtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordOtp.
     */
    data: XOR<PasswordOtpCreateInput, PasswordOtpUncheckedCreateInput>
  }

  /**
   * PasswordOtp createMany
   */
  export type PasswordOtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordOtps.
     */
    data: PasswordOtpCreateManyInput | PasswordOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordOtp createManyAndReturn
   */
  export type PasswordOtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordOtps.
     */
    data: PasswordOtpCreateManyInput | PasswordOtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordOtp update
   */
  export type PasswordOtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordOtp.
     */
    data: XOR<PasswordOtpUpdateInput, PasswordOtpUncheckedUpdateInput>
    /**
     * Choose, which PasswordOtp to update.
     */
    where: PasswordOtpWhereUniqueInput
  }

  /**
   * PasswordOtp updateMany
   */
  export type PasswordOtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordOtps.
     */
    data: XOR<PasswordOtpUpdateManyMutationInput, PasswordOtpUncheckedUpdateManyInput>
    /**
     * Filter which PasswordOtps to update
     */
    where?: PasswordOtpWhereInput
    /**
     * Limit how many PasswordOtps to update.
     */
    limit?: number
  }

  /**
   * PasswordOtp updateManyAndReturn
   */
  export type PasswordOtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * The data used to update PasswordOtps.
     */
    data: XOR<PasswordOtpUpdateManyMutationInput, PasswordOtpUncheckedUpdateManyInput>
    /**
     * Filter which PasswordOtps to update
     */
    where?: PasswordOtpWhereInput
    /**
     * Limit how many PasswordOtps to update.
     */
    limit?: number
  }

  /**
   * PasswordOtp upsert
   */
  export type PasswordOtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordOtp to update in case it exists.
     */
    where: PasswordOtpWhereUniqueInput
    /**
     * In case the PasswordOtp found by the `where` argument doesn't exist, create a new PasswordOtp with this data.
     */
    create: XOR<PasswordOtpCreateInput, PasswordOtpUncheckedCreateInput>
    /**
     * In case the PasswordOtp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordOtpUpdateInput, PasswordOtpUncheckedUpdateInput>
  }

  /**
   * PasswordOtp delete
   */
  export type PasswordOtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
    /**
     * Filter which PasswordOtp to delete.
     */
    where: PasswordOtpWhereUniqueInput
  }

  /**
   * PasswordOtp deleteMany
   */
  export type PasswordOtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordOtps to delete
     */
    where?: PasswordOtpWhereInput
    /**
     * Limit how many PasswordOtps to delete.
     */
    limit?: number
  }

  /**
   * PasswordOtp without action
   */
  export type PasswordOtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordOtp
     */
    select?: PasswordOtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordOtp
     */
    omit?: PasswordOtpOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SuperAdminScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    passwordHash: 'passwordHash',
    contactInfo: 'contactInfo',
    address: 'address',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SuperAdminScalarFieldEnum = (typeof SuperAdminScalarFieldEnum)[keyof typeof SuperAdminScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    passwordHash: 'passwordHash',
    companyName: 'companyName',
    address: 'address',
    contactInfo: 'contactInfo',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    role: 'role',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    passwordHash: 'passwordHash',
    department: 'department',
    position: 'position',
    status: 'status',
    contactInfo: 'contactInfo',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    role: 'role',
    companyName: 'companyName',
    firstName: 'firstName',
    lastName: 'lastName',
    contactInfo: 'contactInfo',
    address: 'address',
    email: 'email',
    passwordHash: 'passwordHash',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const LoginCredentialScalarFieldEnum: {
    id: 'id',
    role: 'role',
    email: 'email',
    passwordHash: 'passwordHash',
    userProfileId: 'userProfileId',
    adminId: 'adminId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    superAdminId: 'superAdminId'
  };

  export type LoginCredentialScalarFieldEnum = (typeof LoginCredentialScalarFieldEnum)[keyof typeof LoginCredentialScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    duration: 'duration',
    price: 'price',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const PlanOfferScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    offerType: 'offerType',
    value: 'value',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanOfferScalarFieldEnum = (typeof PlanOfferScalarFieldEnum)[keyof typeof PlanOfferScalarFieldEnum]


  export const PlanSpecScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    specName: 'specName',
    specValue: 'specValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanSpecScalarFieldEnum = (typeof PlanSpecScalarFieldEnum)[keyof typeof PlanSpecScalarFieldEnum]


  export const PlanDescriptionScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanDescriptionScalarFieldEnum = (typeof PlanDescriptionScalarFieldEnum)[keyof typeof PlanDescriptionScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    planId: 'planId',
    status: 'status',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    renewedAt: 'renewedAt',
    cancelledAt: 'cancelledAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SubscriptionPaymentScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    paidAt: 'paidAt',
    status: 'status',
    paymentMethod: 'paymentMethod',
    gatewayResponse: 'gatewayResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionPaymentScalarFieldEnum = (typeof SubscriptionPaymentScalarFieldEnum)[keyof typeof SubscriptionPaymentScalarFieldEnum]


  export const SubscriptionEventScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    eventType: 'eventType',
    eventAt: 'eventAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionEventScalarFieldEnum = (typeof SubscriptionEventScalarFieldEnum)[keyof typeof SubscriptionEventScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    productName: 'productName',
    productCategory: 'productCategory',
    productPrice: 'productPrice',
    description: 'description',
    productLink: 'productLink',
    tags: 'tags',
    specifications: 'specifications',
    adminId: 'adminId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductRenewalHistoryScalarFieldEnum: {
    id: 'id',
    customerProductHistoryId: 'customerProductHistoryId',
    productId: 'productId',
    purchaseDate: 'purchaseDate',
    renewalDate: 'renewalDate',
    expiryDate: 'expiryDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductRenewalHistoryScalarFieldEnum = (typeof ProductRenewalHistoryScalarFieldEnum)[keyof typeof ProductRenewalHistoryScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    companyName: 'companyName',
    contactPerson: 'contactPerson',
    mobileNumber: 'mobileNumber',
    email: 'email',
    serialNo: 'serialNo',
    prime: 'prime',
    blacklisted: 'blacklisted',
    remark: 'remark',
    adminCustomFields: 'adminCustomFields',
    address: 'address',
    joiningDate: 'joiningDate',
    hasReference: 'hasReference',
    partnerId: 'partnerId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerProductHistoryScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    adminId: 'adminId',
    productId: 'productId',
    purchaseDate: 'purchaseDate',
    renewal: 'renewal',
    renewPeriod: 'renewPeriod',
    expiryDate: 'expiryDate',
    renewalDate: 'renewalDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerProductHistoryScalarFieldEnum = (typeof CustomerProductHistoryScalarFieldEnum)[keyof typeof CustomerProductHistoryScalarFieldEnum]


  export const AdminCustomFieldScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    fieldName: 'fieldName',
    fieldType: 'fieldType',
    isRequired: 'isRequired',
    options: 'options',
    isMultiSelect: 'isMultiSelect',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminCustomFieldScalarFieldEnum = (typeof AdminCustomFieldScalarFieldEnum)[keyof typeof AdminCustomFieldScalarFieldEnum]


  export const LoginAuditScalarFieldEnum: {
    id: 'id',
    loginCredentialId: 'loginCredentialId',
    attemptTime: 'attemptTime',
    success: 'success',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type LoginAuditScalarFieldEnum = (typeof LoginAuditScalarFieldEnum)[keyof typeof LoginAuditScalarFieldEnum]


  export const PasswordOtpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    purpose: 'purpose',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type PasswordOtpScalarFieldEnum = (typeof PasswordOtpScalarFieldEnum)[keyof typeof PasswordOtpScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'OfferType'
   */
  export type EnumOfferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferType'>
    


  /**
   * Reference to a field of type 'OfferType[]'
   */
  export type ListEnumOfferTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OfferType[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'renewPeriod'
   */
  export type EnumrenewPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'renewPeriod'>
    


  /**
   * Reference to a field of type 'renewPeriod[]'
   */
  export type ListEnumrenewPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'renewPeriod[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type SuperAdminWhereInput = {
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    id?: UuidFilter<"SuperAdmin"> | string
    firstName?: StringFilter<"SuperAdmin"> | string
    lastName?: StringFilter<"SuperAdmin"> | string
    email?: StringFilter<"SuperAdmin"> | string
    passwordHash?: StringFilter<"SuperAdmin"> | string
    contactInfo?: JsonNullableFilter<"SuperAdmin">
    address?: JsonNullableFilter<"SuperAdmin">
    status?: BoolFilter<"SuperAdmin"> | boolean
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    loginCreds?: LoginCredentialListRelationFilter
  }

  export type SuperAdminOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    loginCreds?: LoginCredentialOrderByRelationAggregateInput
  }

  export type SuperAdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: SuperAdminWhereInput | SuperAdminWhereInput[]
    OR?: SuperAdminWhereInput[]
    NOT?: SuperAdminWhereInput | SuperAdminWhereInput[]
    firstName?: StringFilter<"SuperAdmin"> | string
    lastName?: StringFilter<"SuperAdmin"> | string
    passwordHash?: StringFilter<"SuperAdmin"> | string
    contactInfo?: JsonNullableFilter<"SuperAdmin">
    address?: JsonNullableFilter<"SuperAdmin">
    status?: BoolFilter<"SuperAdmin"> | boolean
    createdAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeFilter<"SuperAdmin"> | Date | string
    loginCreds?: LoginCredentialListRelationFilter
  }, "id" | "email">

  export type SuperAdminOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SuperAdminCountOrderByAggregateInput
    _max?: SuperAdminMaxOrderByAggregateInput
    _min?: SuperAdminMinOrderByAggregateInput
  }

  export type SuperAdminScalarWhereWithAggregatesInput = {
    AND?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    OR?: SuperAdminScalarWhereWithAggregatesInput[]
    NOT?: SuperAdminScalarWhereWithAggregatesInput | SuperAdminScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SuperAdmin"> | string
    firstName?: StringWithAggregatesFilter<"SuperAdmin"> | string
    lastName?: StringWithAggregatesFilter<"SuperAdmin"> | string
    email?: StringWithAggregatesFilter<"SuperAdmin"> | string
    passwordHash?: StringWithAggregatesFilter<"SuperAdmin"> | string
    contactInfo?: JsonNullableWithAggregatesFilter<"SuperAdmin">
    address?: JsonNullableWithAggregatesFilter<"SuperAdmin">
    status?: BoolWithAggregatesFilter<"SuperAdmin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SuperAdmin"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: UuidFilter<"Admin"> | string
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    firstName?: StringFilter<"Admin"> | string
    lastName?: StringFilter<"Admin"> | string
    email?: StringFilter<"Admin"> | string
    passwordHash?: StringFilter<"Admin"> | string
    companyName?: StringFilter<"Admin"> | string
    address?: JsonNullableFilter<"Admin">
    contactInfo?: JsonNullableFilter<"Admin">
    status?: BoolFilter<"Admin"> | boolean
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    teamMembers?: TeamMemberListRelationFilter
    partners?: PartnerListRelationFilter
    customers?: CustomerListRelationFilter
    customFields?: AdminCustomFieldListRelationFilter
    products?: ProductListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    loginCreds?: LoginCredentialListRelationFilter
    productHistories?: CustomerProductHistoryListRelationFilter
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    address?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teamMembers?: TeamMemberOrderByRelationAggregateInput
    partners?: PartnerOrderByRelationAggregateInput
    customers?: CustomerOrderByRelationAggregateInput
    customFields?: AdminCustomFieldOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    loginCreds?: LoginCredentialOrderByRelationAggregateInput
    productHistories?: CustomerProductHistoryOrderByRelationAggregateInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    role?: EnumRoleFilter<"Admin"> | $Enums.Role
    firstName?: StringFilter<"Admin"> | string
    lastName?: StringFilter<"Admin"> | string
    passwordHash?: StringFilter<"Admin"> | string
    companyName?: StringFilter<"Admin"> | string
    address?: JsonNullableFilter<"Admin">
    contactInfo?: JsonNullableFilter<"Admin">
    status?: BoolFilter<"Admin"> | boolean
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    teamMembers?: TeamMemberListRelationFilter
    partners?: PartnerListRelationFilter
    customers?: CustomerListRelationFilter
    customFields?: AdminCustomFieldListRelationFilter
    products?: ProductListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    loginCreds?: LoginCredentialListRelationFilter
    productHistories?: CustomerProductHistoryListRelationFilter
  }, "id" | "email">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    address?: SortOrderInput | SortOrder
    contactInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Admin"> | string
    role?: EnumRoleWithAggregatesFilter<"Admin"> | $Enums.Role
    firstName?: StringWithAggregatesFilter<"Admin"> | string
    lastName?: StringWithAggregatesFilter<"Admin"> | string
    email?: StringWithAggregatesFilter<"Admin"> | string
    passwordHash?: StringWithAggregatesFilter<"Admin"> | string
    companyName?: StringWithAggregatesFilter<"Admin"> | string
    address?: JsonNullableWithAggregatesFilter<"Admin">
    contactInfo?: JsonNullableWithAggregatesFilter<"Admin">
    status?: BoolWithAggregatesFilter<"Admin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: UuidFilter<"TeamMember"> | string
    adminId?: UuidFilter<"TeamMember"> | string
    role?: EnumRoleFilter<"TeamMember"> | $Enums.Role
    firstName?: StringFilter<"TeamMember"> | string
    lastName?: StringFilter<"TeamMember"> | string
    email?: StringFilter<"TeamMember"> | string
    passwordHash?: StringFilter<"TeamMember"> | string
    department?: StringNullableFilter<"TeamMember"> | string | null
    position?: StringNullableFilter<"TeamMember"> | string | null
    status?: BoolFilter<"TeamMember"> | boolean
    contactInfo?: JsonNullableFilter<"TeamMember">
    address?: JsonNullableFilter<"TeamMember">
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    status?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    adminId?: UuidFilter<"TeamMember"> | string
    role?: EnumRoleFilter<"TeamMember"> | $Enums.Role
    firstName?: StringFilter<"TeamMember"> | string
    lastName?: StringFilter<"TeamMember"> | string
    passwordHash?: StringFilter<"TeamMember"> | string
    department?: StringNullableFilter<"TeamMember"> | string | null
    position?: StringNullableFilter<"TeamMember"> | string | null
    status?: BoolFilter<"TeamMember"> | boolean
    contactInfo?: JsonNullableFilter<"TeamMember">
    address?: JsonNullableFilter<"TeamMember">
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id" | "email">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    department?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    status?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"TeamMember"> | string
    adminId?: UuidWithAggregatesFilter<"TeamMember"> | string
    role?: EnumRoleWithAggregatesFilter<"TeamMember"> | $Enums.Role
    firstName?: StringWithAggregatesFilter<"TeamMember"> | string
    lastName?: StringWithAggregatesFilter<"TeamMember"> | string
    email?: StringWithAggregatesFilter<"TeamMember"> | string
    passwordHash?: StringWithAggregatesFilter<"TeamMember"> | string
    department?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    position?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    status?: BoolWithAggregatesFilter<"TeamMember"> | boolean
    contactInfo?: JsonNullableWithAggregatesFilter<"TeamMember">
    address?: JsonNullableWithAggregatesFilter<"TeamMember">
    createdAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: UuidFilter<"Partner"> | string
    adminId?: UuidFilter<"Partner"> | string
    role?: EnumRoleFilter<"Partner"> | $Enums.Role
    companyName?: StringFilter<"Partner"> | string
    firstName?: StringFilter<"Partner"> | string
    lastName?: StringFilter<"Partner"> | string
    contactInfo?: JsonNullableFilter<"Partner">
    address?: JsonNullableFilter<"Partner">
    email?: StringFilter<"Partner"> | string
    passwordHash?: StringFilter<"Partner"> | string
    status?: BoolFilter<"Partner"> | boolean
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    customers?: CustomerListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    adminId?: UuidFilter<"Partner"> | string
    role?: EnumRoleFilter<"Partner"> | $Enums.Role
    companyName?: StringFilter<"Partner"> | string
    firstName?: StringFilter<"Partner"> | string
    lastName?: StringFilter<"Partner"> | string
    contactInfo?: JsonNullableFilter<"Partner">
    address?: JsonNullableFilter<"Partner">
    passwordHash?: StringFilter<"Partner"> | string
    status?: BoolFilter<"Partner"> | boolean
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    customers?: CustomerListRelationFilter
  }, "id" | "email">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Partner"> | string
    adminId?: UuidWithAggregatesFilter<"Partner"> | string
    role?: EnumRoleWithAggregatesFilter<"Partner"> | $Enums.Role
    companyName?: StringWithAggregatesFilter<"Partner"> | string
    firstName?: StringWithAggregatesFilter<"Partner"> | string
    lastName?: StringWithAggregatesFilter<"Partner"> | string
    contactInfo?: JsonNullableWithAggregatesFilter<"Partner">
    address?: JsonNullableWithAggregatesFilter<"Partner">
    email?: StringWithAggregatesFilter<"Partner"> | string
    passwordHash?: StringWithAggregatesFilter<"Partner"> | string
    status?: BoolWithAggregatesFilter<"Partner"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type LoginCredentialWhereInput = {
    AND?: LoginCredentialWhereInput | LoginCredentialWhereInput[]
    OR?: LoginCredentialWhereInput[]
    NOT?: LoginCredentialWhereInput | LoginCredentialWhereInput[]
    id?: UuidFilter<"LoginCredential"> | string
    role?: EnumRoleFilter<"LoginCredential"> | $Enums.Role
    email?: StringFilter<"LoginCredential"> | string
    passwordHash?: StringFilter<"LoginCredential"> | string
    userProfileId?: UuidFilter<"LoginCredential"> | string
    adminId?: UuidNullableFilter<"LoginCredential"> | string | null
    status?: BoolFilter<"LoginCredential"> | boolean
    createdAt?: DateTimeFilter<"LoginCredential"> | Date | string
    updatedAt?: DateTimeFilter<"LoginCredential"> | Date | string
    superAdminId?: UuidNullableFilter<"LoginCredential"> | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    superadmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    loginAudits?: LoginAuditListRelationFilter
  }

  export type LoginCredentialOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userProfileId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrderInput | SortOrder
    admin?: AdminOrderByWithRelationInput
    superadmin?: SuperAdminOrderByWithRelationInput
    loginAudits?: LoginAuditOrderByRelationAggregateInput
  }

  export type LoginCredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: LoginCredentialWhereInput | LoginCredentialWhereInput[]
    OR?: LoginCredentialWhereInput[]
    NOT?: LoginCredentialWhereInput | LoginCredentialWhereInput[]
    role?: EnumRoleFilter<"LoginCredential"> | $Enums.Role
    passwordHash?: StringFilter<"LoginCredential"> | string
    userProfileId?: UuidFilter<"LoginCredential"> | string
    adminId?: UuidNullableFilter<"LoginCredential"> | string | null
    status?: BoolFilter<"LoginCredential"> | boolean
    createdAt?: DateTimeFilter<"LoginCredential"> | Date | string
    updatedAt?: DateTimeFilter<"LoginCredential"> | Date | string
    superAdminId?: UuidNullableFilter<"LoginCredential"> | string | null
    admin?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    superadmin?: XOR<SuperAdminNullableScalarRelationFilter, SuperAdminWhereInput> | null
    loginAudits?: LoginAuditListRelationFilter
  }, "id" | "email">

  export type LoginCredentialOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userProfileId?: SortOrder
    adminId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrderInput | SortOrder
    _count?: LoginCredentialCountOrderByAggregateInput
    _max?: LoginCredentialMaxOrderByAggregateInput
    _min?: LoginCredentialMinOrderByAggregateInput
  }

  export type LoginCredentialScalarWhereWithAggregatesInput = {
    AND?: LoginCredentialScalarWhereWithAggregatesInput | LoginCredentialScalarWhereWithAggregatesInput[]
    OR?: LoginCredentialScalarWhereWithAggregatesInput[]
    NOT?: LoginCredentialScalarWhereWithAggregatesInput | LoginCredentialScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LoginCredential"> | string
    role?: EnumRoleWithAggregatesFilter<"LoginCredential"> | $Enums.Role
    email?: StringWithAggregatesFilter<"LoginCredential"> | string
    passwordHash?: StringWithAggregatesFilter<"LoginCredential"> | string
    userProfileId?: UuidWithAggregatesFilter<"LoginCredential"> | string
    adminId?: UuidNullableWithAggregatesFilter<"LoginCredential"> | string | null
    status?: BoolWithAggregatesFilter<"LoginCredential"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LoginCredential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LoginCredential"> | Date | string
    superAdminId?: UuidNullableWithAggregatesFilter<"LoginCredential"> | string | null
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: UuidFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    duration?: StringFilter<"Plan"> | string
    price?: FloatFilter<"Plan"> | number
    status?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    offers?: PlanOfferListRelationFilter
    specs?: PlanSpecListRelationFilter
    descriptions?: PlanDescriptionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    offers?: PlanOfferOrderByRelationAggregateInput
    specs?: PlanSpecOrderByRelationAggregateInput
    descriptions?: PlanDescriptionOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    duration?: StringFilter<"Plan"> | string
    price?: FloatFilter<"Plan"> | number
    status?: BoolFilter<"Plan"> | boolean
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
    offers?: PlanOfferListRelationFilter
    specs?: PlanSpecListRelationFilter
    descriptions?: PlanDescriptionListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    duration?: StringWithAggregatesFilter<"Plan"> | string
    price?: FloatWithAggregatesFilter<"Plan"> | number
    status?: BoolWithAggregatesFilter<"Plan"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type PlanOfferWhereInput = {
    AND?: PlanOfferWhereInput | PlanOfferWhereInput[]
    OR?: PlanOfferWhereInput[]
    NOT?: PlanOfferWhereInput | PlanOfferWhereInput[]
    id?: UuidFilter<"PlanOffer"> | string
    planId?: UuidFilter<"PlanOffer"> | string
    offerType?: EnumOfferTypeFilter<"PlanOffer"> | $Enums.OfferType
    value?: FloatNullableFilter<"PlanOffer"> | number | null
    startsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanOffer"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOffer"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanOfferOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    offerType?: SortOrder
    value?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanOfferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanOfferWhereInput | PlanOfferWhereInput[]
    OR?: PlanOfferWhereInput[]
    NOT?: PlanOfferWhereInput | PlanOfferWhereInput[]
    planId?: UuidFilter<"PlanOffer"> | string
    offerType?: EnumOfferTypeFilter<"PlanOffer"> | $Enums.OfferType
    value?: FloatNullableFilter<"PlanOffer"> | number | null
    startsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanOffer"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOffer"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanOfferOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    offerType?: SortOrder
    value?: SortOrderInput | SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanOfferCountOrderByAggregateInput
    _avg?: PlanOfferAvgOrderByAggregateInput
    _max?: PlanOfferMaxOrderByAggregateInput
    _min?: PlanOfferMinOrderByAggregateInput
    _sum?: PlanOfferSumOrderByAggregateInput
  }

  export type PlanOfferScalarWhereWithAggregatesInput = {
    AND?: PlanOfferScalarWhereWithAggregatesInput | PlanOfferScalarWhereWithAggregatesInput[]
    OR?: PlanOfferScalarWhereWithAggregatesInput[]
    NOT?: PlanOfferScalarWhereWithAggregatesInput | PlanOfferScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanOffer"> | string
    planId?: UuidWithAggregatesFilter<"PlanOffer"> | string
    offerType?: EnumOfferTypeWithAggregatesFilter<"PlanOffer"> | $Enums.OfferType
    value?: FloatNullableWithAggregatesFilter<"PlanOffer"> | number | null
    startsAt?: DateTimeNullableWithAggregatesFilter<"PlanOffer"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"PlanOffer"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlanOffer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanOffer"> | Date | string
  }

  export type PlanSpecWhereInput = {
    AND?: PlanSpecWhereInput | PlanSpecWhereInput[]
    OR?: PlanSpecWhereInput[]
    NOT?: PlanSpecWhereInput | PlanSpecWhereInput[]
    id?: UuidFilter<"PlanSpec"> | string
    planId?: UuidFilter<"PlanSpec"> | string
    specName?: StringFilter<"PlanSpec"> | string
    specValue?: StringFilter<"PlanSpec"> | string
    createdAt?: DateTimeFilter<"PlanSpec"> | Date | string
    updatedAt?: DateTimeFilter<"PlanSpec"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanSpecOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    specName?: SortOrder
    specValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanSpecWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanSpecWhereInput | PlanSpecWhereInput[]
    OR?: PlanSpecWhereInput[]
    NOT?: PlanSpecWhereInput | PlanSpecWhereInput[]
    planId?: UuidFilter<"PlanSpec"> | string
    specName?: StringFilter<"PlanSpec"> | string
    specValue?: StringFilter<"PlanSpec"> | string
    createdAt?: DateTimeFilter<"PlanSpec"> | Date | string
    updatedAt?: DateTimeFilter<"PlanSpec"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanSpecOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    specName?: SortOrder
    specValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanSpecCountOrderByAggregateInput
    _max?: PlanSpecMaxOrderByAggregateInput
    _min?: PlanSpecMinOrderByAggregateInput
  }

  export type PlanSpecScalarWhereWithAggregatesInput = {
    AND?: PlanSpecScalarWhereWithAggregatesInput | PlanSpecScalarWhereWithAggregatesInput[]
    OR?: PlanSpecScalarWhereWithAggregatesInput[]
    NOT?: PlanSpecScalarWhereWithAggregatesInput | PlanSpecScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanSpec"> | string
    planId?: UuidWithAggregatesFilter<"PlanSpec"> | string
    specName?: StringWithAggregatesFilter<"PlanSpec"> | string
    specValue?: StringWithAggregatesFilter<"PlanSpec"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlanSpec"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanSpec"> | Date | string
  }

  export type PlanDescriptionWhereInput = {
    AND?: PlanDescriptionWhereInput | PlanDescriptionWhereInput[]
    OR?: PlanDescriptionWhereInput[]
    NOT?: PlanDescriptionWhereInput | PlanDescriptionWhereInput[]
    id?: UuidFilter<"PlanDescription"> | string
    planId?: UuidFilter<"PlanDescription"> | string
    content?: StringFilter<"PlanDescription"> | string
    createdAt?: DateTimeFilter<"PlanDescription"> | Date | string
    updatedAt?: DateTimeFilter<"PlanDescription"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }

  export type PlanDescriptionOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: PlanOrderByWithRelationInput
  }

  export type PlanDescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanDescriptionWhereInput | PlanDescriptionWhereInput[]
    OR?: PlanDescriptionWhereInput[]
    NOT?: PlanDescriptionWhereInput | PlanDescriptionWhereInput[]
    planId?: UuidFilter<"PlanDescription"> | string
    content?: StringFilter<"PlanDescription"> | string
    createdAt?: DateTimeFilter<"PlanDescription"> | Date | string
    updatedAt?: DateTimeFilter<"PlanDescription"> | Date | string
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
  }, "id">

  export type PlanDescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanDescriptionCountOrderByAggregateInput
    _max?: PlanDescriptionMaxOrderByAggregateInput
    _min?: PlanDescriptionMinOrderByAggregateInput
  }

  export type PlanDescriptionScalarWhereWithAggregatesInput = {
    AND?: PlanDescriptionScalarWhereWithAggregatesInput | PlanDescriptionScalarWhereWithAggregatesInput[]
    OR?: PlanDescriptionScalarWhereWithAggregatesInput[]
    NOT?: PlanDescriptionScalarWhereWithAggregatesInput | PlanDescriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PlanDescription"> | string
    planId?: UuidWithAggregatesFilter<"PlanDescription"> | string
    content?: StringWithAggregatesFilter<"PlanDescription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PlanDescription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlanDescription"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    adminId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startsAt?: DateTimeFilter<"Subscription"> | Date | string
    endsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    payments?: SubscriptionPaymentListRelationFilter
    events?: SubscriptionEventListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    renewedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    plan?: PlanOrderByWithRelationInput
    payments?: SubscriptionPaymentOrderByRelationAggregateInput
    events?: SubscriptionEventOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    adminId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startsAt?: DateTimeFilter<"Subscription"> | Date | string
    endsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    plan?: XOR<PlanScalarRelationFilter, PlanWhereInput>
    payments?: SubscriptionPaymentListRelationFilter
    events?: SubscriptionEventListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrderInput | SortOrder
    renewedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Subscription"> | string
    adminId?: UuidWithAggregatesFilter<"Subscription"> | string
    planId?: UuidWithAggregatesFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    startsAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endsAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    renewedAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type SubscriptionPaymentWhereInput = {
    AND?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    OR?: SubscriptionPaymentWhereInput[]
    NOT?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    id?: UuidFilter<"SubscriptionPayment"> | string
    subscriptionId?: UuidFilter<"SubscriptionPayment"> | string
    amount?: FloatFilter<"SubscriptionPayment"> | number
    currency?: StringFilter<"SubscriptionPayment"> | string
    paidAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    status?: StringFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableFilter<"SubscriptionPayment"> | string | null
    gatewayResponse?: JsonNullableFilter<"SubscriptionPayment">
    createdAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type SubscriptionPaymentOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type SubscriptionPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    OR?: SubscriptionPaymentWhereInput[]
    NOT?: SubscriptionPaymentWhereInput | SubscriptionPaymentWhereInput[]
    subscriptionId?: UuidFilter<"SubscriptionPayment"> | string
    amount?: FloatFilter<"SubscriptionPayment"> | number
    currency?: StringFilter<"SubscriptionPayment"> | string
    paidAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    status?: StringFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableFilter<"SubscriptionPayment"> | string | null
    gatewayResponse?: JsonNullableFilter<"SubscriptionPayment">
    createdAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type SubscriptionPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    gatewayResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionPaymentCountOrderByAggregateInput
    _avg?: SubscriptionPaymentAvgOrderByAggregateInput
    _max?: SubscriptionPaymentMaxOrderByAggregateInput
    _min?: SubscriptionPaymentMinOrderByAggregateInput
    _sum?: SubscriptionPaymentSumOrderByAggregateInput
  }

  export type SubscriptionPaymentScalarWhereWithAggregatesInput = {
    AND?: SubscriptionPaymentScalarWhereWithAggregatesInput | SubscriptionPaymentScalarWhereWithAggregatesInput[]
    OR?: SubscriptionPaymentScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionPaymentScalarWhereWithAggregatesInput | SubscriptionPaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SubscriptionPayment"> | string
    subscriptionId?: UuidWithAggregatesFilter<"SubscriptionPayment"> | string
    amount?: FloatWithAggregatesFilter<"SubscriptionPayment"> | number
    currency?: StringWithAggregatesFilter<"SubscriptionPayment"> | string
    paidAt?: DateTimeWithAggregatesFilter<"SubscriptionPayment"> | Date | string
    status?: StringWithAggregatesFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableWithAggregatesFilter<"SubscriptionPayment"> | string | null
    gatewayResponse?: JsonNullableWithAggregatesFilter<"SubscriptionPayment">
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionPayment"> | Date | string
  }

  export type SubscriptionEventWhereInput = {
    AND?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    OR?: SubscriptionEventWhereInput[]
    NOT?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    id?: UuidFilter<"SubscriptionEvent"> | string
    subscriptionId?: UuidFilter<"SubscriptionEvent"> | string
    eventType?: StringFilter<"SubscriptionEvent"> | string
    eventAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    metadata?: JsonNullableFilter<"SubscriptionEvent">
    createdAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type SubscriptionEventOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    eventType?: SortOrder
    eventAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type SubscriptionEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    OR?: SubscriptionEventWhereInput[]
    NOT?: SubscriptionEventWhereInput | SubscriptionEventWhereInput[]
    subscriptionId?: UuidFilter<"SubscriptionEvent"> | string
    eventType?: StringFilter<"SubscriptionEvent"> | string
    eventAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    metadata?: JsonNullableFilter<"SubscriptionEvent">
    createdAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type SubscriptionEventOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    eventType?: SortOrder
    eventAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionEventCountOrderByAggregateInput
    _max?: SubscriptionEventMaxOrderByAggregateInput
    _min?: SubscriptionEventMinOrderByAggregateInput
  }

  export type SubscriptionEventScalarWhereWithAggregatesInput = {
    AND?: SubscriptionEventScalarWhereWithAggregatesInput | SubscriptionEventScalarWhereWithAggregatesInput[]
    OR?: SubscriptionEventScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionEventScalarWhereWithAggregatesInput | SubscriptionEventScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SubscriptionEvent"> | string
    subscriptionId?: UuidWithAggregatesFilter<"SubscriptionEvent"> | string
    eventType?: StringWithAggregatesFilter<"SubscriptionEvent"> | string
    eventAt?: DateTimeWithAggregatesFilter<"SubscriptionEvent"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"SubscriptionEvent">
    createdAt?: DateTimeWithAggregatesFilter<"SubscriptionEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SubscriptionEvent"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    productName?: StringFilter<"Product"> | string
    productCategory?: JsonFilter<"Product">
    productPrice?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    productLink?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    specifications?: JsonFilter<"Product">
    adminId?: UuidFilter<"Product"> | string
    status?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    customerProductHistory?: CustomerProductHistoryListRelationFilter
    renewalHistory?: ProductRenewalHistoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    productName?: SortOrder
    productCategory?: SortOrder
    productPrice?: SortOrder
    description?: SortOrderInput | SortOrder
    productLink?: SortOrderInput | SortOrder
    tags?: SortOrder
    specifications?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    customerProductHistory?: CustomerProductHistoryOrderByRelationAggregateInput
    renewalHistory?: ProductRenewalHistoryOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    productName?: StringFilter<"Product"> | string
    productCategory?: JsonFilter<"Product">
    productPrice?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    productLink?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    specifications?: JsonFilter<"Product">
    adminId?: UuidFilter<"Product"> | string
    status?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    customerProductHistory?: CustomerProductHistoryListRelationFilter
    renewalHistory?: ProductRenewalHistoryListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    productName?: SortOrder
    productCategory?: SortOrder
    productPrice?: SortOrder
    description?: SortOrderInput | SortOrder
    productLink?: SortOrderInput | SortOrder
    tags?: SortOrder
    specifications?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    productName?: StringWithAggregatesFilter<"Product"> | string
    productCategory?: JsonWithAggregatesFilter<"Product">
    productPrice?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    productLink?: StringNullableWithAggregatesFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    specifications?: JsonWithAggregatesFilter<"Product">
    adminId?: UuidWithAggregatesFilter<"Product"> | string
    status?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductRenewalHistoryWhereInput = {
    AND?: ProductRenewalHistoryWhereInput | ProductRenewalHistoryWhereInput[]
    OR?: ProductRenewalHistoryWhereInput[]
    NOT?: ProductRenewalHistoryWhereInput | ProductRenewalHistoryWhereInput[]
    id?: UuidFilter<"ProductRenewalHistory"> | string
    customerProductHistoryId?: UuidFilter<"ProductRenewalHistory"> | string
    productId?: UuidFilter<"ProductRenewalHistory"> | string
    purchaseDate?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    renewalDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    customerProductHistory?: XOR<CustomerProductHistoryScalarRelationFilter, CustomerProductHistoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductRenewalHistoryOrderByWithRelationInput = {
    id?: SortOrder
    customerProductHistoryId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewalDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customerProductHistory?: CustomerProductHistoryOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductRenewalHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductRenewalHistoryWhereInput | ProductRenewalHistoryWhereInput[]
    OR?: ProductRenewalHistoryWhereInput[]
    NOT?: ProductRenewalHistoryWhereInput | ProductRenewalHistoryWhereInput[]
    customerProductHistoryId?: UuidFilter<"ProductRenewalHistory"> | string
    productId?: UuidFilter<"ProductRenewalHistory"> | string
    purchaseDate?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    renewalDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    customerProductHistory?: XOR<CustomerProductHistoryScalarRelationFilter, CustomerProductHistoryWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductRenewalHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    customerProductHistoryId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewalDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductRenewalHistoryCountOrderByAggregateInput
    _max?: ProductRenewalHistoryMaxOrderByAggregateInput
    _min?: ProductRenewalHistoryMinOrderByAggregateInput
  }

  export type ProductRenewalHistoryScalarWhereWithAggregatesInput = {
    AND?: ProductRenewalHistoryScalarWhereWithAggregatesInput | ProductRenewalHistoryScalarWhereWithAggregatesInput[]
    OR?: ProductRenewalHistoryScalarWhereWithAggregatesInput[]
    NOT?: ProductRenewalHistoryScalarWhereWithAggregatesInput | ProductRenewalHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductRenewalHistory"> | string
    customerProductHistoryId?: UuidWithAggregatesFilter<"ProductRenewalHistory"> | string
    productId?: UuidWithAggregatesFilter<"ProductRenewalHistory"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"ProductRenewalHistory"> | Date | string
    renewalDate?: DateTimeNullableWithAggregatesFilter<"ProductRenewalHistory"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"ProductRenewalHistory"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductRenewalHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductRenewalHistory"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: UuidFilter<"Customer"> | string
    adminId?: UuidFilter<"Customer"> | string
    companyName?: StringFilter<"Customer"> | string
    contactPerson?: StringFilter<"Customer"> | string
    mobileNumber?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    serialNo?: StringFilter<"Customer"> | string
    prime?: BoolFilter<"Customer"> | boolean
    blacklisted?: BoolFilter<"Customer"> | boolean
    remark?: StringNullableFilter<"Customer"> | string | null
    adminCustomFields?: JsonNullableFilter<"Customer">
    address?: JsonFilter<"Customer">
    joiningDate?: DateTimeFilter<"Customer"> | Date | string
    hasReference?: BoolFilter<"Customer"> | boolean
    partnerId?: UuidNullableFilter<"Customer"> | string | null
    status?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    product?: CustomerProductHistoryListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    mobileNumber?: SortOrder
    email?: SortOrder
    serialNo?: SortOrder
    prime?: SortOrder
    blacklisted?: SortOrder
    remark?: SortOrderInput | SortOrder
    adminCustomFields?: SortOrderInput | SortOrder
    address?: SortOrder
    joiningDate?: SortOrder
    hasReference?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
    partner?: PartnerOrderByWithRelationInput
    product?: CustomerProductHistoryOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mobileNumber?: string
    email?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    adminId?: UuidFilter<"Customer"> | string
    companyName?: StringFilter<"Customer"> | string
    contactPerson?: StringFilter<"Customer"> | string
    serialNo?: StringFilter<"Customer"> | string
    prime?: BoolFilter<"Customer"> | boolean
    blacklisted?: BoolFilter<"Customer"> | boolean
    remark?: StringNullableFilter<"Customer"> | string | null
    adminCustomFields?: JsonNullableFilter<"Customer">
    address?: JsonFilter<"Customer">
    joiningDate?: DateTimeFilter<"Customer"> | Date | string
    hasReference?: BoolFilter<"Customer"> | boolean
    partnerId?: UuidNullableFilter<"Customer"> | string | null
    status?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    partner?: XOR<PartnerNullableScalarRelationFilter, PartnerWhereInput> | null
    product?: CustomerProductHistoryListRelationFilter
  }, "id" | "mobileNumber" | "email">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    mobileNumber?: SortOrder
    email?: SortOrder
    serialNo?: SortOrder
    prime?: SortOrder
    blacklisted?: SortOrder
    remark?: SortOrderInput | SortOrder
    adminCustomFields?: SortOrderInput | SortOrder
    address?: SortOrder
    joiningDate?: SortOrder
    hasReference?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Customer"> | string
    adminId?: UuidWithAggregatesFilter<"Customer"> | string
    companyName?: StringWithAggregatesFilter<"Customer"> | string
    contactPerson?: StringWithAggregatesFilter<"Customer"> | string
    mobileNumber?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringWithAggregatesFilter<"Customer"> | string
    serialNo?: StringWithAggregatesFilter<"Customer"> | string
    prime?: BoolWithAggregatesFilter<"Customer"> | boolean
    blacklisted?: BoolWithAggregatesFilter<"Customer"> | boolean
    remark?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    adminCustomFields?: JsonNullableWithAggregatesFilter<"Customer">
    address?: JsonWithAggregatesFilter<"Customer">
    joiningDate?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    hasReference?: BoolWithAggregatesFilter<"Customer"> | boolean
    partnerId?: UuidNullableWithAggregatesFilter<"Customer"> | string | null
    status?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerProductHistoryWhereInput = {
    AND?: CustomerProductHistoryWhereInput | CustomerProductHistoryWhereInput[]
    OR?: CustomerProductHistoryWhereInput[]
    NOT?: CustomerProductHistoryWhereInput | CustomerProductHistoryWhereInput[]
    id?: UuidFilter<"CustomerProductHistory"> | string
    customerId?: UuidFilter<"CustomerProductHistory"> | string
    adminId?: UuidFilter<"CustomerProductHistory"> | string
    productId?: UuidFilter<"CustomerProductHistory"> | string
    purchaseDate?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    renewal?: BoolFilter<"CustomerProductHistory"> | boolean
    renewPeriod?: EnumrenewPeriodFilter<"CustomerProductHistory"> | $Enums.renewPeriod
    expiryDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    status?: BoolFilter<"CustomerProductHistory"> | boolean
    createdAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    renewals?: ProductRenewalHistoryListRelationFilter
  }

  export type CustomerProductHistoryOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    adminId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewal?: SortOrder
    renewPeriod?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    renewalDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    admin?: AdminOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    renewals?: ProductRenewalHistoryOrderByRelationAggregateInput
  }

  export type CustomerProductHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerProductHistoryWhereInput | CustomerProductHistoryWhereInput[]
    OR?: CustomerProductHistoryWhereInput[]
    NOT?: CustomerProductHistoryWhereInput | CustomerProductHistoryWhereInput[]
    customerId?: UuidFilter<"CustomerProductHistory"> | string
    adminId?: UuidFilter<"CustomerProductHistory"> | string
    productId?: UuidFilter<"CustomerProductHistory"> | string
    purchaseDate?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    renewal?: BoolFilter<"CustomerProductHistory"> | boolean
    renewPeriod?: EnumrenewPeriodFilter<"CustomerProductHistory"> | $Enums.renewPeriod
    expiryDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    status?: BoolFilter<"CustomerProductHistory"> | boolean
    createdAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    renewals?: ProductRenewalHistoryListRelationFilter
  }, "id">

  export type CustomerProductHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    adminId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewal?: SortOrder
    renewPeriod?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    renewalDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerProductHistoryCountOrderByAggregateInput
    _max?: CustomerProductHistoryMaxOrderByAggregateInput
    _min?: CustomerProductHistoryMinOrderByAggregateInput
  }

  export type CustomerProductHistoryScalarWhereWithAggregatesInput = {
    AND?: CustomerProductHistoryScalarWhereWithAggregatesInput | CustomerProductHistoryScalarWhereWithAggregatesInput[]
    OR?: CustomerProductHistoryScalarWhereWithAggregatesInput[]
    NOT?: CustomerProductHistoryScalarWhereWithAggregatesInput | CustomerProductHistoryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CustomerProductHistory"> | string
    customerId?: UuidWithAggregatesFilter<"CustomerProductHistory"> | string
    adminId?: UuidWithAggregatesFilter<"CustomerProductHistory"> | string
    productId?: UuidWithAggregatesFilter<"CustomerProductHistory"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"CustomerProductHistory"> | Date | string
    renewal?: BoolWithAggregatesFilter<"CustomerProductHistory"> | boolean
    renewPeriod?: EnumrenewPeriodWithAggregatesFilter<"CustomerProductHistory"> | $Enums.renewPeriod
    expiryDate?: DateTimeNullableWithAggregatesFilter<"CustomerProductHistory"> | Date | string | null
    renewalDate?: DateTimeNullableWithAggregatesFilter<"CustomerProductHistory"> | Date | string | null
    status?: BoolWithAggregatesFilter<"CustomerProductHistory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerProductHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerProductHistory"> | Date | string
  }

  export type AdminCustomFieldWhereInput = {
    AND?: AdminCustomFieldWhereInput | AdminCustomFieldWhereInput[]
    OR?: AdminCustomFieldWhereInput[]
    NOT?: AdminCustomFieldWhereInput | AdminCustomFieldWhereInput[]
    id?: UuidFilter<"AdminCustomField"> | string
    adminId?: UuidFilter<"AdminCustomField"> | string
    fieldName?: StringFilter<"AdminCustomField"> | string
    fieldType?: StringFilter<"AdminCustomField"> | string
    isRequired?: BoolFilter<"AdminCustomField"> | boolean
    options?: StringNullableListFilter<"AdminCustomField">
    isMultiSelect?: BoolFilter<"AdminCustomField"> | boolean
    status?: BoolFilter<"AdminCustomField"> | boolean
    createdAt?: DateTimeFilter<"AdminCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"AdminCustomField"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }

  export type AdminCustomFieldOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrder
    isMultiSelect?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    admin?: AdminOrderByWithRelationInput
  }

  export type AdminCustomFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminCustomFieldWhereInput | AdminCustomFieldWhereInput[]
    OR?: AdminCustomFieldWhereInput[]
    NOT?: AdminCustomFieldWhereInput | AdminCustomFieldWhereInput[]
    adminId?: UuidFilter<"AdminCustomField"> | string
    fieldName?: StringFilter<"AdminCustomField"> | string
    fieldType?: StringFilter<"AdminCustomField"> | string
    isRequired?: BoolFilter<"AdminCustomField"> | boolean
    options?: StringNullableListFilter<"AdminCustomField">
    isMultiSelect?: BoolFilter<"AdminCustomField"> | boolean
    status?: BoolFilter<"AdminCustomField"> | boolean
    createdAt?: DateTimeFilter<"AdminCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"AdminCustomField"> | Date | string
    admin?: XOR<AdminScalarRelationFilter, AdminWhereInput>
  }, "id">

  export type AdminCustomFieldOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrder
    isMultiSelect?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCustomFieldCountOrderByAggregateInput
    _max?: AdminCustomFieldMaxOrderByAggregateInput
    _min?: AdminCustomFieldMinOrderByAggregateInput
  }

  export type AdminCustomFieldScalarWhereWithAggregatesInput = {
    AND?: AdminCustomFieldScalarWhereWithAggregatesInput | AdminCustomFieldScalarWhereWithAggregatesInput[]
    OR?: AdminCustomFieldScalarWhereWithAggregatesInput[]
    NOT?: AdminCustomFieldScalarWhereWithAggregatesInput | AdminCustomFieldScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AdminCustomField"> | string
    adminId?: UuidWithAggregatesFilter<"AdminCustomField"> | string
    fieldName?: StringWithAggregatesFilter<"AdminCustomField"> | string
    fieldType?: StringWithAggregatesFilter<"AdminCustomField"> | string
    isRequired?: BoolWithAggregatesFilter<"AdminCustomField"> | boolean
    options?: StringNullableListFilter<"AdminCustomField">
    isMultiSelect?: BoolWithAggregatesFilter<"AdminCustomField"> | boolean
    status?: BoolWithAggregatesFilter<"AdminCustomField"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AdminCustomField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminCustomField"> | Date | string
  }

  export type LoginAuditWhereInput = {
    AND?: LoginAuditWhereInput | LoginAuditWhereInput[]
    OR?: LoginAuditWhereInput[]
    NOT?: LoginAuditWhereInput | LoginAuditWhereInput[]
    id?: UuidFilter<"LoginAudit"> | string
    loginCredentialId?: UuidFilter<"LoginAudit"> | string
    attemptTime?: DateTimeFilter<"LoginAudit"> | Date | string
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringFilter<"LoginAudit"> | string
    userAgent?: StringFilter<"LoginAudit"> | string
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
    loginCredential?: XOR<LoginCredentialScalarRelationFilter, LoginCredentialWhereInput>
  }

  export type LoginAuditOrderByWithRelationInput = {
    id?: SortOrder
    loginCredentialId?: SortOrder
    attemptTime?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    loginCredential?: LoginCredentialOrderByWithRelationInput
  }

  export type LoginAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoginAuditWhereInput | LoginAuditWhereInput[]
    OR?: LoginAuditWhereInput[]
    NOT?: LoginAuditWhereInput | LoginAuditWhereInput[]
    loginCredentialId?: UuidFilter<"LoginAudit"> | string
    attemptTime?: DateTimeFilter<"LoginAudit"> | Date | string
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringFilter<"LoginAudit"> | string
    userAgent?: StringFilter<"LoginAudit"> | string
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
    loginCredential?: XOR<LoginCredentialScalarRelationFilter, LoginCredentialWhereInput>
  }, "id">

  export type LoginAuditOrderByWithAggregationInput = {
    id?: SortOrder
    loginCredentialId?: SortOrder
    attemptTime?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    _count?: LoginAuditCountOrderByAggregateInput
    _max?: LoginAuditMaxOrderByAggregateInput
    _min?: LoginAuditMinOrderByAggregateInput
  }

  export type LoginAuditScalarWhereWithAggregatesInput = {
    AND?: LoginAuditScalarWhereWithAggregatesInput | LoginAuditScalarWhereWithAggregatesInput[]
    OR?: LoginAuditScalarWhereWithAggregatesInput[]
    NOT?: LoginAuditScalarWhereWithAggregatesInput | LoginAuditScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LoginAudit"> | string
    loginCredentialId?: UuidWithAggregatesFilter<"LoginAudit"> | string
    attemptTime?: DateTimeWithAggregatesFilter<"LoginAudit"> | Date | string
    success?: BoolWithAggregatesFilter<"LoginAudit"> | boolean
    ipAddress?: StringWithAggregatesFilter<"LoginAudit"> | string
    userAgent?: StringWithAggregatesFilter<"LoginAudit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LoginAudit"> | Date | string
  }

  export type PasswordOtpWhereInput = {
    AND?: PasswordOtpWhereInput | PasswordOtpWhereInput[]
    OR?: PasswordOtpWhereInput[]
    NOT?: PasswordOtpWhereInput | PasswordOtpWhereInput[]
    id?: UuidFilter<"PasswordOtp"> | string
    userId?: UuidFilter<"PasswordOtp"> | string
    otp?: StringFilter<"PasswordOtp"> | string
    purpose?: StringFilter<"PasswordOtp"> | string
    used?: BoolFilter<"PasswordOtp"> | boolean
    createdAt?: DateTimeFilter<"PasswordOtp"> | Date | string
  }

  export type PasswordOtpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    purpose?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordOtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordOtpWhereInput | PasswordOtpWhereInput[]
    OR?: PasswordOtpWhereInput[]
    NOT?: PasswordOtpWhereInput | PasswordOtpWhereInput[]
    userId?: UuidFilter<"PasswordOtp"> | string
    otp?: StringFilter<"PasswordOtp"> | string
    purpose?: StringFilter<"PasswordOtp"> | string
    used?: BoolFilter<"PasswordOtp"> | boolean
    createdAt?: DateTimeFilter<"PasswordOtp"> | Date | string
  }, "id">

  export type PasswordOtpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    purpose?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordOtpCountOrderByAggregateInput
    _max?: PasswordOtpMaxOrderByAggregateInput
    _min?: PasswordOtpMinOrderByAggregateInput
  }

  export type PasswordOtpScalarWhereWithAggregatesInput = {
    AND?: PasswordOtpScalarWhereWithAggregatesInput | PasswordOtpScalarWhereWithAggregatesInput[]
    OR?: PasswordOtpScalarWhereWithAggregatesInput[]
    NOT?: PasswordOtpScalarWhereWithAggregatesInput | PasswordOtpScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PasswordOtp"> | string
    userId?: UuidWithAggregatesFilter<"PasswordOtp"> | string
    otp?: StringWithAggregatesFilter<"PasswordOtp"> | string
    purpose?: StringWithAggregatesFilter<"PasswordOtp"> | string
    used?: BoolWithAggregatesFilter<"PasswordOtp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordOtp"> | Date | string
  }

  export type SuperAdminCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    loginCreds?: LoginCredentialCreateNestedManyWithoutSuperadminInput
  }

  export type SuperAdminUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutSuperadminInput
  }

  export type SuperAdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCreds?: LoginCredentialUpdateManyWithoutSuperadminNestedInput
  }

  export type SuperAdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutSuperadminNestedInput
  }

  export type SuperAdminCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateManyInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutTeamMembersInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    adminId: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutTeamMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    adminId: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutPartnersInput
    customers?: CustomerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    adminId: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutPartnersNestedInput
    customers?: CustomerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    adminId: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginCredentialCreateInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutLoginCredsInput
    superadmin?: SuperAdminCreateNestedOneWithoutLoginCredsInput
    loginAudits?: LoginAuditCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialUncheckedCreateInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId?: string | null
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutLoginCredsNestedInput
    superadmin?: SuperAdminUpdateOneWithoutLoginCredsNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialCreateManyInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId?: string | null
  }

  export type LoginCredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginCredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferCreateNestedManyWithoutPlanInput
    specs?: PlanSpecCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferUncheckedCreateNestedManyWithoutPlanInput
    specs?: PlanSpecUncheckedCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUncheckedUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUncheckedUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferCreateInput = {
    id?: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutOffersInput
  }

  export type PlanOfferUncheckedCreateInput = {
    id?: string
    planId: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOfferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutOffersNestedInput
  }

  export type PlanOfferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferCreateManyInput = {
    id?: string
    planId: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOfferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecCreateInput = {
    id?: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSpecsInput
  }

  export type PlanSpecUncheckedCreateInput = {
    id?: string
    planId: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanSpecUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSpecsNestedInput
  }

  export type PlanSpecUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecCreateManyInput = {
    id?: string
    planId: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanSpecUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutDescriptionsInput
  }

  export type PlanDescriptionUncheckedCreateInput = {
    id?: string
    planId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanDescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutDescriptionsNestedInput
  }

  export type PlanDescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionCreateManyInput = {
    id?: string
    planId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanDescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: SubscriptionPaymentCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    adminId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SubscriptionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: SubscriptionPaymentUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    adminId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentCreateInput = {
    id?: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type SubscriptionPaymentUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type SubscriptionPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventCreateInput = {
    id?: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutEventsInput
  }

  export type SubscriptionEventUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutEventsNestedInput
  }

  export type SubscriptionEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventCreateManyInput = {
    id?: string
    subscriptionId: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutProductsInput
    customerProductHistory?: CustomerProductHistoryCreateNestedManyWithoutProductInput
    renewalHistory?: ProductRenewalHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    adminId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedCreateNestedManyWithoutProductInput
    renewalHistory?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutProductsNestedInput
    customerProductHistory?: CustomerProductHistoryUpdateManyWithoutProductNestedInput
    renewalHistory?: ProductRenewalHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedUpdateManyWithoutProductNestedInput
    renewalHistory?: ProductRenewalHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    adminId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryCreateInput = {
    id?: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory: CustomerProductHistoryCreateNestedOneWithoutRenewalsInput
    product: ProductCreateNestedOneWithoutRenewalHistoryInput
  }

  export type ProductRenewalHistoryUncheckedCreateInput = {
    id?: string
    customerProductHistoryId: string
    productId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUpdateOneRequiredWithoutRenewalsNestedInput
    product?: ProductUpdateOneRequiredWithoutRenewalHistoryNestedInput
  }

  export type ProductRenewalHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProductHistoryId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryCreateManyInput = {
    id?: string
    customerProductHistoryId: string
    productId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProductHistoryId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutCustomersInput
    partner?: PartnerCreateNestedOneWithoutCustomersInput
    product?: CustomerProductHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    partnerId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: CustomerProductHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutCustomersNestedInput
    partner?: PartnerUpdateOneWithoutCustomersNestedInput
    product?: CustomerProductHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CustomerProductHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    partnerId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductHistoryCreateInput = {
    id?: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProductInput
    admin: AdminCreateNestedOneWithoutProductHistoriesInput
    product: ProductCreateNestedOneWithoutCustomerProductHistoryInput
    renewals?: ProductRenewalHistoryCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUncheckedCreateInput = {
    id?: string
    customerId: string
    adminId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    renewals?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProductNestedInput
    admin?: AdminUpdateOneRequiredWithoutProductHistoriesNestedInput
    product?: ProductUpdateOneRequiredWithoutCustomerProductHistoryNestedInput
    renewals?: ProductRenewalHistoryUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renewals?: ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryCreateManyInput = {
    id?: string
    customerId: string
    adminId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldCreateInput = {
    id?: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutCustomFieldsInput
  }

  export type AdminCustomFieldUncheckedCreateInput = {
    id?: string
    adminId: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCustomFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutCustomFieldsNestedInput
  }

  export type AdminCustomFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldCreateManyInput = {
    id?: string
    adminId: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCustomFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditCreateInput = {
    id?: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
    loginCredential: LoginCredentialCreateNestedOneWithoutLoginAuditsInput
  }

  export type LoginAuditUncheckedCreateInput = {
    id?: string
    loginCredentialId: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LoginAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginCredential?: LoginCredentialUpdateOneRequiredWithoutLoginAuditsNestedInput
  }

  export type LoginAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginCredentialId?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditCreateManyInput = {
    id?: string
    loginCredentialId: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LoginAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    loginCredentialId?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordOtpCreateInput = {
    id?: string
    userId: string
    otp: string
    purpose: string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordOtpUncheckedCreateInput = {
    id?: string
    userId: string
    otp: string
    purpose: string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordOtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordOtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordOtpCreateManyInput = {
    id?: string
    userId: string
    otp: string
    purpose: string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordOtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordOtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type LoginCredentialListRelationFilter = {
    every?: LoginCredentialWhereInput
    some?: LoginCredentialWhereInput
    none?: LoginCredentialWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LoginCredentialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SuperAdminCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SuperAdminMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type PartnerListRelationFilter = {
    every?: PartnerWhereInput
    some?: PartnerWhereInput
    none?: PartnerWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type AdminCustomFieldListRelationFilter = {
    every?: AdminCustomFieldWhereInput
    some?: AdminCustomFieldWhereInput
    none?: AdminCustomFieldWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type CustomerProductHistoryListRelationFilter = {
    every?: CustomerProductHistoryWhereInput
    some?: CustomerProductHistoryWhereInput
    none?: CustomerProductHistoryWhereInput
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PartnerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCustomFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerProductHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    address?: SortOrder
    contactInfo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    companyName?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type AdminScalarRelationFilter = {
    is?: AdminWhereInput
    isNot?: AdminWhereInput
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    department?: SortOrder
    position?: SortOrder
    status?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    department?: SortOrder
    position?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    department?: SortOrder
    position?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactInfo?: SortOrder
    address?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    role?: SortOrder
    companyName?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type SuperAdminNullableScalarRelationFilter = {
    is?: SuperAdminWhereInput | null
    isNot?: SuperAdminWhereInput | null
  }

  export type LoginAuditListRelationFilter = {
    every?: LoginAuditWhereInput
    some?: LoginAuditWhereInput
    none?: LoginAuditWhereInput
  }

  export type LoginAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginCredentialCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userProfileId?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type LoginCredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userProfileId?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type LoginCredentialMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    userProfileId?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    superAdminId?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PlanOfferListRelationFilter = {
    every?: PlanOfferWhereInput
    some?: PlanOfferWhereInput
    none?: PlanOfferWhereInput
  }

  export type PlanSpecListRelationFilter = {
    every?: PlanSpecWhereInput
    some?: PlanSpecWhereInput
    none?: PlanSpecWhereInput
  }

  export type PlanDescriptionListRelationFilter = {
    every?: PlanDescriptionWhereInput
    some?: PlanDescriptionWhereInput
    none?: PlanDescriptionWhereInput
  }

  export type PlanOfferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanSpecOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanDescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    duration?: SortOrder
    price?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumOfferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferTypeFilter<$PrismaModel> | $Enums.OfferType
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PlanScalarRelationFilter = {
    is?: PlanWhereInput
    isNot?: PlanWhereInput
  }

  export type PlanOfferCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    offerType?: SortOrder
    value?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOfferAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PlanOfferMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    offerType?: SortOrder
    value?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOfferMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    offerType?: SortOrder
    value?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanOfferSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumOfferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel> | $Enums.OfferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferTypeFilter<$PrismaModel>
    _max?: NestedEnumOfferTypeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PlanSpecCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    specName?: SortOrder
    specValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSpecMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    specName?: SortOrder
    specValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSpecMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    specName?: SortOrder
    specValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanDescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanDescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanDescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type SubscriptionPaymentListRelationFilter = {
    every?: SubscriptionPaymentWhereInput
    some?: SubscriptionPaymentWhereInput
    none?: SubscriptionPaymentWhereInput
  }

  export type SubscriptionEventListRelationFilter = {
    every?: SubscriptionEventWhereInput
    some?: SubscriptionEventWhereInput
    none?: SubscriptionEventWhereInput
  }

  export type SubscriptionPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    renewedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    renewedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    planId?: SortOrder
    status?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    renewedAt?: SortOrder
    cancelledAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type SubscriptionPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    gatewayResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SubscriptionEventCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    eventType?: SortOrder
    eventAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionEventMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    eventType?: SortOrder
    eventAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionEventMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    eventType?: SortOrder
    eventAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProductRenewalHistoryListRelationFilter = {
    every?: ProductRenewalHistoryWhereInput
    some?: ProductRenewalHistoryWhereInput
    none?: ProductRenewalHistoryWhereInput
  }

  export type ProductRenewalHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    productCategory?: SortOrder
    productPrice?: SortOrder
    description?: SortOrder
    productLink?: SortOrder
    tags?: SortOrder
    specifications?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    productPrice?: SortOrder
    description?: SortOrder
    productLink?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    productName?: SortOrder
    productPrice?: SortOrder
    description?: SortOrder
    productLink?: SortOrder
    adminId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type CustomerProductHistoryScalarRelationFilter = {
    is?: CustomerProductHistoryWhereInput
    isNot?: CustomerProductHistoryWhereInput
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductRenewalHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    customerProductHistoryId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewalDate?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRenewalHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    customerProductHistoryId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewalDate?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductRenewalHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    customerProductHistoryId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewalDate?: SortOrder
    expiryDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PartnerNullableScalarRelationFilter = {
    is?: PartnerWhereInput | null
    isNot?: PartnerWhereInput | null
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    mobileNumber?: SortOrder
    email?: SortOrder
    serialNo?: SortOrder
    prime?: SortOrder
    blacklisted?: SortOrder
    remark?: SortOrder
    adminCustomFields?: SortOrder
    address?: SortOrder
    joiningDate?: SortOrder
    hasReference?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    mobileNumber?: SortOrder
    email?: SortOrder
    serialNo?: SortOrder
    prime?: SortOrder
    blacklisted?: SortOrder
    remark?: SortOrder
    joiningDate?: SortOrder
    hasReference?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    companyName?: SortOrder
    contactPerson?: SortOrder
    mobileNumber?: SortOrder
    email?: SortOrder
    serialNo?: SortOrder
    prime?: SortOrder
    blacklisted?: SortOrder
    remark?: SortOrder
    joiningDate?: SortOrder
    hasReference?: SortOrder
    partnerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumrenewPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.renewPeriod | EnumrenewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumrenewPeriodFilter<$PrismaModel> | $Enums.renewPeriod
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerProductHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    adminId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewal?: SortOrder
    renewPeriod?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    adminId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewal?: SortOrder
    renewPeriod?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerProductHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    adminId?: SortOrder
    productId?: SortOrder
    purchaseDate?: SortOrder
    renewal?: SortOrder
    renewPeriod?: SortOrder
    expiryDate?: SortOrder
    renewalDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumrenewPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.renewPeriod | EnumrenewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumrenewPeriodWithAggregatesFilter<$PrismaModel> | $Enums.renewPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrenewPeriodFilter<$PrismaModel>
    _max?: NestedEnumrenewPeriodFilter<$PrismaModel>
  }

  export type AdminCustomFieldCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    options?: SortOrder
    isMultiSelect?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminCustomFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    isMultiSelect?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminCustomFieldMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    fieldName?: SortOrder
    fieldType?: SortOrder
    isRequired?: SortOrder
    isMultiSelect?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LoginCredentialScalarRelationFilter = {
    is?: LoginCredentialWhereInput
    isNot?: LoginCredentialWhereInput
  }

  export type LoginAuditCountOrderByAggregateInput = {
    id?: SortOrder
    loginCredentialId?: SortOrder
    attemptTime?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    loginCredentialId?: SortOrder
    attemptTime?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAuditMinOrderByAggregateInput = {
    id?: SortOrder
    loginCredentialId?: SortOrder
    attemptTime?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordOtpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    purpose?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordOtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    purpose?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordOtpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    purpose?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginCredentialCreateNestedManyWithoutSuperadminInput = {
    create?: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput> | LoginCredentialCreateWithoutSuperadminInput[] | LoginCredentialUncheckedCreateWithoutSuperadminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutSuperadminInput | LoginCredentialCreateOrConnectWithoutSuperadminInput[]
    createMany?: LoginCredentialCreateManySuperadminInputEnvelope
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
  }

  export type LoginCredentialUncheckedCreateNestedManyWithoutSuperadminInput = {
    create?: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput> | LoginCredentialCreateWithoutSuperadminInput[] | LoginCredentialUncheckedCreateWithoutSuperadminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutSuperadminInput | LoginCredentialCreateOrConnectWithoutSuperadminInput[]
    createMany?: LoginCredentialCreateManySuperadminInputEnvelope
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type LoginCredentialUpdateManyWithoutSuperadminNestedInput = {
    create?: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput> | LoginCredentialCreateWithoutSuperadminInput[] | LoginCredentialUncheckedCreateWithoutSuperadminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutSuperadminInput | LoginCredentialCreateOrConnectWithoutSuperadminInput[]
    upsert?: LoginCredentialUpsertWithWhereUniqueWithoutSuperadminInput | LoginCredentialUpsertWithWhereUniqueWithoutSuperadminInput[]
    createMany?: LoginCredentialCreateManySuperadminInputEnvelope
    set?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    disconnect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    delete?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    update?: LoginCredentialUpdateWithWhereUniqueWithoutSuperadminInput | LoginCredentialUpdateWithWhereUniqueWithoutSuperadminInput[]
    updateMany?: LoginCredentialUpdateManyWithWhereWithoutSuperadminInput | LoginCredentialUpdateManyWithWhereWithoutSuperadminInput[]
    deleteMany?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
  }

  export type LoginCredentialUncheckedUpdateManyWithoutSuperadminNestedInput = {
    create?: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput> | LoginCredentialCreateWithoutSuperadminInput[] | LoginCredentialUncheckedCreateWithoutSuperadminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutSuperadminInput | LoginCredentialCreateOrConnectWithoutSuperadminInput[]
    upsert?: LoginCredentialUpsertWithWhereUniqueWithoutSuperadminInput | LoginCredentialUpsertWithWhereUniqueWithoutSuperadminInput[]
    createMany?: LoginCredentialCreateManySuperadminInputEnvelope
    set?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    disconnect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    delete?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    update?: LoginCredentialUpdateWithWhereUniqueWithoutSuperadminInput | LoginCredentialUpdateWithWhereUniqueWithoutSuperadminInput[]
    updateMany?: LoginCredentialUpdateManyWithWhereWithoutSuperadminInput | LoginCredentialUpdateManyWithWhereWithoutSuperadminInput[]
    deleteMany?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
  }

  export type TeamMemberCreateNestedManyWithoutAdminInput = {
    create?: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput> | TeamMemberCreateWithoutAdminInput[] | TeamMemberUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutAdminInput | TeamMemberCreateOrConnectWithoutAdminInput[]
    createMany?: TeamMemberCreateManyAdminInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PartnerCreateNestedManyWithoutAdminInput = {
    create?: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput> | PartnerCreateWithoutAdminInput[] | PartnerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutAdminInput | PartnerCreateOrConnectWithoutAdminInput[]
    createMany?: PartnerCreateManyAdminInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type CustomerCreateNestedManyWithoutAdminInput = {
    create?: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput> | CustomerCreateWithoutAdminInput[] | CustomerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAdminInput | CustomerCreateOrConnectWithoutAdminInput[]
    createMany?: CustomerCreateManyAdminInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AdminCustomFieldCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput> | AdminCustomFieldCreateWithoutAdminInput[] | AdminCustomFieldUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminCustomFieldCreateOrConnectWithoutAdminInput | AdminCustomFieldCreateOrConnectWithoutAdminInput[]
    createMany?: AdminCustomFieldCreateManyAdminInputEnvelope
    connect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutAdminInput = {
    create?: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput> | ProductCreateWithoutAdminInput[] | ProductUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdminInput | ProductCreateOrConnectWithoutAdminInput[]
    createMany?: ProductCreateManyAdminInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutAdminInput = {
    create?: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput> | SubscriptionCreateWithoutAdminInput[] | SubscriptionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAdminInput | SubscriptionCreateOrConnectWithoutAdminInput[]
    createMany?: SubscriptionCreateManyAdminInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type LoginCredentialCreateNestedManyWithoutAdminInput = {
    create?: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput> | LoginCredentialCreateWithoutAdminInput[] | LoginCredentialUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutAdminInput | LoginCredentialCreateOrConnectWithoutAdminInput[]
    createMany?: LoginCredentialCreateManyAdminInputEnvelope
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
  }

  export type CustomerProductHistoryCreateNestedManyWithoutAdminInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput> | CustomerProductHistoryCreateWithoutAdminInput[] | CustomerProductHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutAdminInput | CustomerProductHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: CustomerProductHistoryCreateManyAdminInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput> | TeamMemberCreateWithoutAdminInput[] | TeamMemberUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutAdminInput | TeamMemberCreateOrConnectWithoutAdminInput[]
    createMany?: TeamMemberCreateManyAdminInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type PartnerUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput> | PartnerCreateWithoutAdminInput[] | PartnerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutAdminInput | PartnerCreateOrConnectWithoutAdminInput[]
    createMany?: PartnerCreateManyAdminInputEnvelope
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput> | CustomerCreateWithoutAdminInput[] | CustomerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAdminInput | CustomerCreateOrConnectWithoutAdminInput[]
    createMany?: CustomerCreateManyAdminInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput> | AdminCustomFieldCreateWithoutAdminInput[] | AdminCustomFieldUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminCustomFieldCreateOrConnectWithoutAdminInput | AdminCustomFieldCreateOrConnectWithoutAdminInput[]
    createMany?: AdminCustomFieldCreateManyAdminInputEnvelope
    connect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput> | ProductCreateWithoutAdminInput[] | ProductUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdminInput | ProductCreateOrConnectWithoutAdminInput[]
    createMany?: ProductCreateManyAdminInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput> | SubscriptionCreateWithoutAdminInput[] | SubscriptionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAdminInput | SubscriptionCreateOrConnectWithoutAdminInput[]
    createMany?: SubscriptionCreateManyAdminInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type LoginCredentialUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput> | LoginCredentialCreateWithoutAdminInput[] | LoginCredentialUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutAdminInput | LoginCredentialCreateOrConnectWithoutAdminInput[]
    createMany?: LoginCredentialCreateManyAdminInputEnvelope
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
  }

  export type CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput> | CustomerProductHistoryCreateWithoutAdminInput[] | CustomerProductHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutAdminInput | CustomerProductHistoryCreateOrConnectWithoutAdminInput[]
    createMany?: CustomerProductHistoryCreateManyAdminInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type TeamMemberUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput> | TeamMemberCreateWithoutAdminInput[] | TeamMemberUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutAdminInput | TeamMemberCreateOrConnectWithoutAdminInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutAdminInput | TeamMemberUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TeamMemberCreateManyAdminInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutAdminInput | TeamMemberUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutAdminInput | TeamMemberUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PartnerUpdateManyWithoutAdminNestedInput = {
    create?: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput> | PartnerCreateWithoutAdminInput[] | PartnerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutAdminInput | PartnerCreateOrConnectWithoutAdminInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutAdminInput | PartnerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: PartnerCreateManyAdminInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutAdminInput | PartnerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutAdminInput | PartnerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type CustomerUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput> | CustomerCreateWithoutAdminInput[] | CustomerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAdminInput | CustomerCreateOrConnectWithoutAdminInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAdminInput | CustomerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CustomerCreateManyAdminInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAdminInput | CustomerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAdminInput | CustomerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AdminCustomFieldUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput> | AdminCustomFieldCreateWithoutAdminInput[] | AdminCustomFieldUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminCustomFieldCreateOrConnectWithoutAdminInput | AdminCustomFieldCreateOrConnectWithoutAdminInput[]
    upsert?: AdminCustomFieldUpsertWithWhereUniqueWithoutAdminInput | AdminCustomFieldUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminCustomFieldCreateManyAdminInputEnvelope
    set?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    disconnect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    delete?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    connect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    update?: AdminCustomFieldUpdateWithWhereUniqueWithoutAdminInput | AdminCustomFieldUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminCustomFieldUpdateManyWithWhereWithoutAdminInput | AdminCustomFieldUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminCustomFieldScalarWhereInput | AdminCustomFieldScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput> | ProductCreateWithoutAdminInput[] | ProductUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdminInput | ProductCreateOrConnectWithoutAdminInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutAdminInput | ProductUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ProductCreateManyAdminInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutAdminInput | ProductUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutAdminInput | ProductUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput> | SubscriptionCreateWithoutAdminInput[] | SubscriptionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAdminInput | SubscriptionCreateOrConnectWithoutAdminInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutAdminInput | SubscriptionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SubscriptionCreateManyAdminInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutAdminInput | SubscriptionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutAdminInput | SubscriptionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type LoginCredentialUpdateManyWithoutAdminNestedInput = {
    create?: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput> | LoginCredentialCreateWithoutAdminInput[] | LoginCredentialUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutAdminInput | LoginCredentialCreateOrConnectWithoutAdminInput[]
    upsert?: LoginCredentialUpsertWithWhereUniqueWithoutAdminInput | LoginCredentialUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: LoginCredentialCreateManyAdminInputEnvelope
    set?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    disconnect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    delete?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    update?: LoginCredentialUpdateWithWhereUniqueWithoutAdminInput | LoginCredentialUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: LoginCredentialUpdateManyWithWhereWithoutAdminInput | LoginCredentialUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
  }

  export type CustomerProductHistoryUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput> | CustomerProductHistoryCreateWithoutAdminInput[] | CustomerProductHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutAdminInput | CustomerProductHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutAdminInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CustomerProductHistoryCreateManyAdminInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutAdminInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutAdminInput | CustomerProductHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput> | TeamMemberCreateWithoutAdminInput[] | TeamMemberUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutAdminInput | TeamMemberCreateOrConnectWithoutAdminInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutAdminInput | TeamMemberUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: TeamMemberCreateManyAdminInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutAdminInput | TeamMemberUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutAdminInput | TeamMemberUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type PartnerUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput> | PartnerCreateWithoutAdminInput[] | PartnerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: PartnerCreateOrConnectWithoutAdminInput | PartnerCreateOrConnectWithoutAdminInput[]
    upsert?: PartnerUpsertWithWhereUniqueWithoutAdminInput | PartnerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: PartnerCreateManyAdminInputEnvelope
    set?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    disconnect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    delete?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    connect?: PartnerWhereUniqueInput | PartnerWhereUniqueInput[]
    update?: PartnerUpdateWithWhereUniqueWithoutAdminInput | PartnerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: PartnerUpdateManyWithWhereWithoutAdminInput | PartnerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput> | CustomerCreateWithoutAdminInput[] | CustomerUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAdminInput | CustomerCreateOrConnectWithoutAdminInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAdminInput | CustomerUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CustomerCreateManyAdminInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAdminInput | CustomerUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAdminInput | CustomerUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput> | AdminCustomFieldCreateWithoutAdminInput[] | AdminCustomFieldUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminCustomFieldCreateOrConnectWithoutAdminInput | AdminCustomFieldCreateOrConnectWithoutAdminInput[]
    upsert?: AdminCustomFieldUpsertWithWhereUniqueWithoutAdminInput | AdminCustomFieldUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminCustomFieldCreateManyAdminInputEnvelope
    set?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    disconnect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    delete?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    connect?: AdminCustomFieldWhereUniqueInput | AdminCustomFieldWhereUniqueInput[]
    update?: AdminCustomFieldUpdateWithWhereUniqueWithoutAdminInput | AdminCustomFieldUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminCustomFieldUpdateManyWithWhereWithoutAdminInput | AdminCustomFieldUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminCustomFieldScalarWhereInput | AdminCustomFieldScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput> | ProductCreateWithoutAdminInput[] | ProductUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutAdminInput | ProductCreateOrConnectWithoutAdminInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutAdminInput | ProductUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: ProductCreateManyAdminInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutAdminInput | ProductUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutAdminInput | ProductUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput> | SubscriptionCreateWithoutAdminInput[] | SubscriptionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutAdminInput | SubscriptionCreateOrConnectWithoutAdminInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutAdminInput | SubscriptionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: SubscriptionCreateManyAdminInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutAdminInput | SubscriptionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutAdminInput | SubscriptionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput> | LoginCredentialCreateWithoutAdminInput[] | LoginCredentialUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutAdminInput | LoginCredentialCreateOrConnectWithoutAdminInput[]
    upsert?: LoginCredentialUpsertWithWhereUniqueWithoutAdminInput | LoginCredentialUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: LoginCredentialCreateManyAdminInputEnvelope
    set?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    disconnect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    delete?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    connect?: LoginCredentialWhereUniqueInput | LoginCredentialWhereUniqueInput[]
    update?: LoginCredentialUpdateWithWhereUniqueWithoutAdminInput | LoginCredentialUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: LoginCredentialUpdateManyWithWhereWithoutAdminInput | LoginCredentialUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput> | CustomerProductHistoryCreateWithoutAdminInput[] | CustomerProductHistoryUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutAdminInput | CustomerProductHistoryCreateOrConnectWithoutAdminInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutAdminInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: CustomerProductHistoryCreateManyAdminInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutAdminInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutAdminInput | CustomerProductHistoryUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutTeamMembersInput = {
    create?: XOR<AdminCreateWithoutTeamMembersInput, AdminUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTeamMembersInput
    connect?: AdminWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AdminUpdateOneRequiredWithoutTeamMembersNestedInput = {
    create?: XOR<AdminCreateWithoutTeamMembersInput, AdminUncheckedCreateWithoutTeamMembersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutTeamMembersInput
    upsert?: AdminUpsertWithoutTeamMembersInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutTeamMembersInput, AdminUpdateWithoutTeamMembersInput>, AdminUncheckedUpdateWithoutTeamMembersInput>
  }

  export type AdminCreateNestedOneWithoutPartnersInput = {
    create?: XOR<AdminCreateWithoutPartnersInput, AdminUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPartnersInput
    connect?: AdminWhereUniqueInput
  }

  export type CustomerCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput> | CustomerCreateWithoutPartnerInput[] | CustomerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutPartnerInput | CustomerCreateOrConnectWithoutPartnerInput[]
    createMany?: CustomerCreateManyPartnerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput> | CustomerCreateWithoutPartnerInput[] | CustomerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutPartnerInput | CustomerCreateOrConnectWithoutPartnerInput[]
    createMany?: CustomerCreateManyPartnerInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutPartnersNestedInput = {
    create?: XOR<AdminCreateWithoutPartnersInput, AdminUncheckedCreateWithoutPartnersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutPartnersInput
    upsert?: AdminUpsertWithoutPartnersInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutPartnersInput, AdminUpdateWithoutPartnersInput>, AdminUncheckedUpdateWithoutPartnersInput>
  }

  export type CustomerUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput> | CustomerCreateWithoutPartnerInput[] | CustomerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutPartnerInput | CustomerCreateOrConnectWithoutPartnerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutPartnerInput | CustomerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CustomerCreateManyPartnerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutPartnerInput | CustomerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutPartnerInput | CustomerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput> | CustomerCreateWithoutPartnerInput[] | CustomerUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutPartnerInput | CustomerCreateOrConnectWithoutPartnerInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutPartnerInput | CustomerUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: CustomerCreateManyPartnerInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutPartnerInput | CustomerUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutPartnerInput | CustomerUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AdminCreateNestedOneWithoutLoginCredsInput = {
    create?: XOR<AdminCreateWithoutLoginCredsInput, AdminUncheckedCreateWithoutLoginCredsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLoginCredsInput
    connect?: AdminWhereUniqueInput
  }

  export type SuperAdminCreateNestedOneWithoutLoginCredsInput = {
    create?: XOR<SuperAdminCreateWithoutLoginCredsInput, SuperAdminUncheckedCreateWithoutLoginCredsInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutLoginCredsInput
    connect?: SuperAdminWhereUniqueInput
  }

  export type LoginAuditCreateNestedManyWithoutLoginCredentialInput = {
    create?: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput> | LoginAuditCreateWithoutLoginCredentialInput[] | LoginAuditUncheckedCreateWithoutLoginCredentialInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutLoginCredentialInput | LoginAuditCreateOrConnectWithoutLoginCredentialInput[]
    createMany?: LoginAuditCreateManyLoginCredentialInputEnvelope
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
  }

  export type LoginAuditUncheckedCreateNestedManyWithoutLoginCredentialInput = {
    create?: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput> | LoginAuditCreateWithoutLoginCredentialInput[] | LoginAuditUncheckedCreateWithoutLoginCredentialInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutLoginCredentialInput | LoginAuditCreateOrConnectWithoutLoginCredentialInput[]
    createMany?: LoginAuditCreateManyLoginCredentialInputEnvelope
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
  }

  export type AdminUpdateOneWithoutLoginCredsNestedInput = {
    create?: XOR<AdminCreateWithoutLoginCredsInput, AdminUncheckedCreateWithoutLoginCredsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutLoginCredsInput
    upsert?: AdminUpsertWithoutLoginCredsInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutLoginCredsInput, AdminUpdateWithoutLoginCredsInput>, AdminUncheckedUpdateWithoutLoginCredsInput>
  }

  export type SuperAdminUpdateOneWithoutLoginCredsNestedInput = {
    create?: XOR<SuperAdminCreateWithoutLoginCredsInput, SuperAdminUncheckedCreateWithoutLoginCredsInput>
    connectOrCreate?: SuperAdminCreateOrConnectWithoutLoginCredsInput
    upsert?: SuperAdminUpsertWithoutLoginCredsInput
    disconnect?: SuperAdminWhereInput | boolean
    delete?: SuperAdminWhereInput | boolean
    connect?: SuperAdminWhereUniqueInput
    update?: XOR<XOR<SuperAdminUpdateToOneWithWhereWithoutLoginCredsInput, SuperAdminUpdateWithoutLoginCredsInput>, SuperAdminUncheckedUpdateWithoutLoginCredsInput>
  }

  export type LoginAuditUpdateManyWithoutLoginCredentialNestedInput = {
    create?: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput> | LoginAuditCreateWithoutLoginCredentialInput[] | LoginAuditUncheckedCreateWithoutLoginCredentialInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutLoginCredentialInput | LoginAuditCreateOrConnectWithoutLoginCredentialInput[]
    upsert?: LoginAuditUpsertWithWhereUniqueWithoutLoginCredentialInput | LoginAuditUpsertWithWhereUniqueWithoutLoginCredentialInput[]
    createMany?: LoginAuditCreateManyLoginCredentialInputEnvelope
    set?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    disconnect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    delete?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    update?: LoginAuditUpdateWithWhereUniqueWithoutLoginCredentialInput | LoginAuditUpdateWithWhereUniqueWithoutLoginCredentialInput[]
    updateMany?: LoginAuditUpdateManyWithWhereWithoutLoginCredentialInput | LoginAuditUpdateManyWithWhereWithoutLoginCredentialInput[]
    deleteMany?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
  }

  export type LoginAuditUncheckedUpdateManyWithoutLoginCredentialNestedInput = {
    create?: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput> | LoginAuditCreateWithoutLoginCredentialInput[] | LoginAuditUncheckedCreateWithoutLoginCredentialInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutLoginCredentialInput | LoginAuditCreateOrConnectWithoutLoginCredentialInput[]
    upsert?: LoginAuditUpsertWithWhereUniqueWithoutLoginCredentialInput | LoginAuditUpsertWithWhereUniqueWithoutLoginCredentialInput[]
    createMany?: LoginAuditCreateManyLoginCredentialInputEnvelope
    set?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    disconnect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    delete?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    update?: LoginAuditUpdateWithWhereUniqueWithoutLoginCredentialInput | LoginAuditUpdateWithWhereUniqueWithoutLoginCredentialInput[]
    updateMany?: LoginAuditUpdateManyWithWhereWithoutLoginCredentialInput | LoginAuditUpdateManyWithWhereWithoutLoginCredentialInput[]
    deleteMany?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
  }

  export type PlanOfferCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput> | PlanOfferCreateWithoutPlanInput[] | PlanOfferUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanOfferCreateOrConnectWithoutPlanInput | PlanOfferCreateOrConnectWithoutPlanInput[]
    createMany?: PlanOfferCreateManyPlanInputEnvelope
    connect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
  }

  export type PlanSpecCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput> | PlanSpecCreateWithoutPlanInput[] | PlanSpecUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanSpecCreateOrConnectWithoutPlanInput | PlanSpecCreateOrConnectWithoutPlanInput[]
    createMany?: PlanSpecCreateManyPlanInputEnvelope
    connect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
  }

  export type PlanDescriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput> | PlanDescriptionCreateWithoutPlanInput[] | PlanDescriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanDescriptionCreateOrConnectWithoutPlanInput | PlanDescriptionCreateOrConnectWithoutPlanInput[]
    createMany?: PlanDescriptionCreateManyPlanInputEnvelope
    connect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type PlanOfferUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput> | PlanOfferCreateWithoutPlanInput[] | PlanOfferUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanOfferCreateOrConnectWithoutPlanInput | PlanOfferCreateOrConnectWithoutPlanInput[]
    createMany?: PlanOfferCreateManyPlanInputEnvelope
    connect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
  }

  export type PlanSpecUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput> | PlanSpecCreateWithoutPlanInput[] | PlanSpecUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanSpecCreateOrConnectWithoutPlanInput | PlanSpecCreateOrConnectWithoutPlanInput[]
    createMany?: PlanSpecCreateManyPlanInputEnvelope
    connect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
  }

  export type PlanDescriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput> | PlanDescriptionCreateWithoutPlanInput[] | PlanDescriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanDescriptionCreateOrConnectWithoutPlanInput | PlanDescriptionCreateOrConnectWithoutPlanInput[]
    createMany?: PlanDescriptionCreateManyPlanInputEnvelope
    connect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlanOfferUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput> | PlanOfferCreateWithoutPlanInput[] | PlanOfferUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanOfferCreateOrConnectWithoutPlanInput | PlanOfferCreateOrConnectWithoutPlanInput[]
    upsert?: PlanOfferUpsertWithWhereUniqueWithoutPlanInput | PlanOfferUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanOfferCreateManyPlanInputEnvelope
    set?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    disconnect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    delete?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    connect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    update?: PlanOfferUpdateWithWhereUniqueWithoutPlanInput | PlanOfferUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanOfferUpdateManyWithWhereWithoutPlanInput | PlanOfferUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanOfferScalarWhereInput | PlanOfferScalarWhereInput[]
  }

  export type PlanSpecUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput> | PlanSpecCreateWithoutPlanInput[] | PlanSpecUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanSpecCreateOrConnectWithoutPlanInput | PlanSpecCreateOrConnectWithoutPlanInput[]
    upsert?: PlanSpecUpsertWithWhereUniqueWithoutPlanInput | PlanSpecUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanSpecCreateManyPlanInputEnvelope
    set?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    disconnect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    delete?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    connect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    update?: PlanSpecUpdateWithWhereUniqueWithoutPlanInput | PlanSpecUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanSpecUpdateManyWithWhereWithoutPlanInput | PlanSpecUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanSpecScalarWhereInput | PlanSpecScalarWhereInput[]
  }

  export type PlanDescriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput> | PlanDescriptionCreateWithoutPlanInput[] | PlanDescriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanDescriptionCreateOrConnectWithoutPlanInput | PlanDescriptionCreateOrConnectWithoutPlanInput[]
    upsert?: PlanDescriptionUpsertWithWhereUniqueWithoutPlanInput | PlanDescriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanDescriptionCreateManyPlanInputEnvelope
    set?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    disconnect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    delete?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    connect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    update?: PlanDescriptionUpdateWithWhereUniqueWithoutPlanInput | PlanDescriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanDescriptionUpdateManyWithWhereWithoutPlanInput | PlanDescriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanDescriptionScalarWhereInput | PlanDescriptionScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanOfferUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput> | PlanOfferCreateWithoutPlanInput[] | PlanOfferUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanOfferCreateOrConnectWithoutPlanInput | PlanOfferCreateOrConnectWithoutPlanInput[]
    upsert?: PlanOfferUpsertWithWhereUniqueWithoutPlanInput | PlanOfferUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanOfferCreateManyPlanInputEnvelope
    set?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    disconnect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    delete?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    connect?: PlanOfferWhereUniqueInput | PlanOfferWhereUniqueInput[]
    update?: PlanOfferUpdateWithWhereUniqueWithoutPlanInput | PlanOfferUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanOfferUpdateManyWithWhereWithoutPlanInput | PlanOfferUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanOfferScalarWhereInput | PlanOfferScalarWhereInput[]
  }

  export type PlanSpecUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput> | PlanSpecCreateWithoutPlanInput[] | PlanSpecUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanSpecCreateOrConnectWithoutPlanInput | PlanSpecCreateOrConnectWithoutPlanInput[]
    upsert?: PlanSpecUpsertWithWhereUniqueWithoutPlanInput | PlanSpecUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanSpecCreateManyPlanInputEnvelope
    set?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    disconnect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    delete?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    connect?: PlanSpecWhereUniqueInput | PlanSpecWhereUniqueInput[]
    update?: PlanSpecUpdateWithWhereUniqueWithoutPlanInput | PlanSpecUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanSpecUpdateManyWithWhereWithoutPlanInput | PlanSpecUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanSpecScalarWhereInput | PlanSpecScalarWhereInput[]
  }

  export type PlanDescriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput> | PlanDescriptionCreateWithoutPlanInput[] | PlanDescriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: PlanDescriptionCreateOrConnectWithoutPlanInput | PlanDescriptionCreateOrConnectWithoutPlanInput[]
    upsert?: PlanDescriptionUpsertWithWhereUniqueWithoutPlanInput | PlanDescriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: PlanDescriptionCreateManyPlanInputEnvelope
    set?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    disconnect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    delete?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    connect?: PlanDescriptionWhereUniqueInput | PlanDescriptionWhereUniqueInput[]
    update?: PlanDescriptionUpdateWithWhereUniqueWithoutPlanInput | PlanDescriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: PlanDescriptionUpdateManyWithWhereWithoutPlanInput | PlanDescriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: PlanDescriptionScalarWhereInput | PlanDescriptionScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput> | SubscriptionCreateWithoutPlanInput[] | SubscriptionUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPlanInput | SubscriptionCreateOrConnectWithoutPlanInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutPlanInput | SubscriptionUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: SubscriptionCreateManyPlanInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutPlanInput | SubscriptionUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutPlanInput | SubscriptionUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type PlanCreateNestedOneWithoutOffersInput = {
    create?: XOR<PlanCreateWithoutOffersInput, PlanUncheckedCreateWithoutOffersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutOffersInput
    connect?: PlanWhereUniqueInput
  }

  export type EnumOfferTypeFieldUpdateOperationsInput = {
    set?: $Enums.OfferType
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PlanUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<PlanCreateWithoutOffersInput, PlanUncheckedCreateWithoutOffersInput>
    connectOrCreate?: PlanCreateOrConnectWithoutOffersInput
    upsert?: PlanUpsertWithoutOffersInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutOffersInput, PlanUpdateWithoutOffersInput>, PlanUncheckedUpdateWithoutOffersInput>
  }

  export type PlanCreateNestedOneWithoutSpecsInput = {
    create?: XOR<PlanCreateWithoutSpecsInput, PlanUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSpecsInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutSpecsNestedInput = {
    create?: XOR<PlanCreateWithoutSpecsInput, PlanUncheckedCreateWithoutSpecsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSpecsInput
    upsert?: PlanUpsertWithoutSpecsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSpecsInput, PlanUpdateWithoutSpecsInput>, PlanUncheckedUpdateWithoutSpecsInput>
  }

  export type PlanCreateNestedOneWithoutDescriptionsInput = {
    create?: XOR<PlanCreateWithoutDescriptionsInput, PlanUncheckedCreateWithoutDescriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutDescriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type PlanUpdateOneRequiredWithoutDescriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutDescriptionsInput, PlanUncheckedCreateWithoutDescriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutDescriptionsInput
    upsert?: PlanUpsertWithoutDescriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutDescriptionsInput, PlanUpdateWithoutDescriptionsInput>, PlanUncheckedUpdateWithoutDescriptionsInput>
  }

  export type AdminCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<AdminCreateWithoutSubscriptionsInput, AdminUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSubscriptionsInput
    connect?: AdminWhereUniqueInput
  }

  export type PlanCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
  }

  export type SubscriptionPaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput> | SubscriptionPaymentCreateWithoutSubscriptionInput[] | SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput | SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionPaymentCreateManySubscriptionInputEnvelope
    connect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
  }

  export type SubscriptionEventCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput> | SubscriptionEventCreateWithoutSubscriptionInput[] | SubscriptionEventUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionEventCreateOrConnectWithoutSubscriptionInput | SubscriptionEventCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionEventCreateManySubscriptionInputEnvelope
    connect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
  }

  export type SubscriptionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput> | SubscriptionPaymentCreateWithoutSubscriptionInput[] | SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput | SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionPaymentCreateManySubscriptionInputEnvelope
    connect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
  }

  export type SubscriptionEventUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput> | SubscriptionEventCreateWithoutSubscriptionInput[] | SubscriptionEventUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionEventCreateOrConnectWithoutSubscriptionInput | SubscriptionEventCreateOrConnectWithoutSubscriptionInput[]
    createMany?: SubscriptionEventCreateManySubscriptionInputEnvelope
    connect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type AdminUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<AdminCreateWithoutSubscriptionsInput, AdminUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutSubscriptionsInput
    upsert?: AdminUpsertWithoutSubscriptionsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutSubscriptionsInput, AdminUpdateWithoutSubscriptionsInput>, AdminUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: PlanCreateOrConnectWithoutSubscriptionsInput
    upsert?: PlanUpsertWithoutSubscriptionsInput
    connect?: PlanWhereUniqueInput
    update?: XOR<XOR<PlanUpdateToOneWithWhereWithoutSubscriptionsInput, PlanUpdateWithoutSubscriptionsInput>, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type SubscriptionPaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput> | SubscriptionPaymentCreateWithoutSubscriptionInput[] | SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput | SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionPaymentCreateManySubscriptionInputEnvelope
    set?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    disconnect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    delete?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    connect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    update?: SubscriptionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionPaymentUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionPaymentScalarWhereInput | SubscriptionPaymentScalarWhereInput[]
  }

  export type SubscriptionEventUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput> | SubscriptionEventCreateWithoutSubscriptionInput[] | SubscriptionEventUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionEventCreateOrConnectWithoutSubscriptionInput | SubscriptionEventCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionEventUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionEventUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionEventCreateManySubscriptionInputEnvelope
    set?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    disconnect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    delete?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    connect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    update?: SubscriptionEventUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionEventUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionEventUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionEventUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionEventScalarWhereInput | SubscriptionEventScalarWhereInput[]
  }

  export type SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput> | SubscriptionPaymentCreateWithoutSubscriptionInput[] | SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput | SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionPaymentCreateManySubscriptionInputEnvelope
    set?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    disconnect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    delete?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    connect?: SubscriptionPaymentWhereUniqueInput | SubscriptionPaymentWhereUniqueInput[]
    update?: SubscriptionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionPaymentUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionPaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionPaymentScalarWhereInput | SubscriptionPaymentScalarWhereInput[]
  }

  export type SubscriptionEventUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput> | SubscriptionEventCreateWithoutSubscriptionInput[] | SubscriptionEventUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: SubscriptionEventCreateOrConnectWithoutSubscriptionInput | SubscriptionEventCreateOrConnectWithoutSubscriptionInput[]
    upsert?: SubscriptionEventUpsertWithWhereUniqueWithoutSubscriptionInput | SubscriptionEventUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: SubscriptionEventCreateManySubscriptionInputEnvelope
    set?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    disconnect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    delete?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    connect?: SubscriptionEventWhereUniqueInput | SubscriptionEventWhereUniqueInput[]
    update?: SubscriptionEventUpdateWithWhereUniqueWithoutSubscriptionInput | SubscriptionEventUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: SubscriptionEventUpdateManyWithWhereWithoutSubscriptionInput | SubscriptionEventUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: SubscriptionEventScalarWhereInput | SubscriptionEventScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionCreateNestedOneWithoutEventsInput = {
    create?: XOR<SubscriptionCreateWithoutEventsInput, SubscriptionUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutEventsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type SubscriptionUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutEventsInput, SubscriptionUncheckedCreateWithoutEventsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutEventsInput
    upsert?: SubscriptionUpsertWithoutEventsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutEventsInput, SubscriptionUpdateWithoutEventsInput>, SubscriptionUncheckedUpdateWithoutEventsInput>
  }

  export type ProductCreatetagsInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutProductsInput = {
    create?: XOR<AdminCreateWithoutProductsInput, AdminUncheckedCreateWithoutProductsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutProductsInput
    connect?: AdminWhereUniqueInput
  }

  export type CustomerProductHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput> | CustomerProductHistoryCreateWithoutProductInput[] | CustomerProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutProductInput | CustomerProductHistoryCreateOrConnectWithoutProductInput[]
    createMany?: CustomerProductHistoryCreateManyProductInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type ProductRenewalHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput> | ProductRenewalHistoryCreateWithoutProductInput[] | ProductRenewalHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutProductInput | ProductRenewalHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductRenewalHistoryCreateManyProductInputEnvelope
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
  }

  export type CustomerProductHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput> | CustomerProductHistoryCreateWithoutProductInput[] | CustomerProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutProductInput | CustomerProductHistoryCreateOrConnectWithoutProductInput[]
    createMany?: CustomerProductHistoryCreateManyProductInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type ProductRenewalHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput> | ProductRenewalHistoryCreateWithoutProductInput[] | ProductRenewalHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutProductInput | ProductRenewalHistoryCreateOrConnectWithoutProductInput[]
    createMany?: ProductRenewalHistoryCreateManyProductInputEnvelope
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
  }

  export type ProductUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<AdminCreateWithoutProductsInput, AdminUncheckedCreateWithoutProductsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutProductsInput
    upsert?: AdminUpsertWithoutProductsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutProductsInput, AdminUpdateWithoutProductsInput>, AdminUncheckedUpdateWithoutProductsInput>
  }

  export type CustomerProductHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput> | CustomerProductHistoryCreateWithoutProductInput[] | CustomerProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutProductInput | CustomerProductHistoryCreateOrConnectWithoutProductInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutProductInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerProductHistoryCreateManyProductInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutProductInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutProductInput | CustomerProductHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type ProductRenewalHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput> | ProductRenewalHistoryCreateWithoutProductInput[] | ProductRenewalHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutProductInput | ProductRenewalHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductRenewalHistoryUpsertWithWhereUniqueWithoutProductInput | ProductRenewalHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRenewalHistoryCreateManyProductInputEnvelope
    set?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    disconnect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    delete?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    update?: ProductRenewalHistoryUpdateWithWhereUniqueWithoutProductInput | ProductRenewalHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRenewalHistoryUpdateManyWithWhereWithoutProductInput | ProductRenewalHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput> | CustomerProductHistoryCreateWithoutProductInput[] | CustomerProductHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutProductInput | CustomerProductHistoryCreateOrConnectWithoutProductInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutProductInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CustomerProductHistoryCreateManyProductInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutProductInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutProductInput | CustomerProductHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type ProductRenewalHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput> | ProductRenewalHistoryCreateWithoutProductInput[] | ProductRenewalHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutProductInput | ProductRenewalHistoryCreateOrConnectWithoutProductInput[]
    upsert?: ProductRenewalHistoryUpsertWithWhereUniqueWithoutProductInput | ProductRenewalHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductRenewalHistoryCreateManyProductInputEnvelope
    set?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    disconnect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    delete?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    update?: ProductRenewalHistoryUpdateWithWhereUniqueWithoutProductInput | ProductRenewalHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductRenewalHistoryUpdateManyWithWhereWithoutProductInput | ProductRenewalHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
  }

  export type CustomerProductHistoryCreateNestedOneWithoutRenewalsInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutRenewalsInput, CustomerProductHistoryUncheckedCreateWithoutRenewalsInput>
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutRenewalsInput
    connect?: CustomerProductHistoryWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRenewalHistoryInput = {
    create?: XOR<ProductCreateWithoutRenewalHistoryInput, ProductUncheckedCreateWithoutRenewalHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRenewalHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type CustomerProductHistoryUpdateOneRequiredWithoutRenewalsNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutRenewalsInput, CustomerProductHistoryUncheckedCreateWithoutRenewalsInput>
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutRenewalsInput
    upsert?: CustomerProductHistoryUpsertWithoutRenewalsInput
    connect?: CustomerProductHistoryWhereUniqueInput
    update?: XOR<XOR<CustomerProductHistoryUpdateToOneWithWhereWithoutRenewalsInput, CustomerProductHistoryUpdateWithoutRenewalsInput>, CustomerProductHistoryUncheckedUpdateWithoutRenewalsInput>
  }

  export type ProductUpdateOneRequiredWithoutRenewalHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutRenewalHistoryInput, ProductUncheckedCreateWithoutRenewalHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRenewalHistoryInput
    upsert?: ProductUpsertWithoutRenewalHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRenewalHistoryInput, ProductUpdateWithoutRenewalHistoryInput>, ProductUncheckedUpdateWithoutRenewalHistoryInput>
  }

  export type AdminCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AdminCreateWithoutCustomersInput, AdminUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCustomersInput
    connect?: AdminWhereUniqueInput
  }

  export type PartnerCreateNestedOneWithoutCustomersInput = {
    create?: XOR<PartnerCreateWithoutCustomersInput, PartnerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCustomersInput
    connect?: PartnerWhereUniqueInput
  }

  export type CustomerProductHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput> | CustomerProductHistoryCreateWithoutCustomerInput[] | CustomerProductHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutCustomerInput | CustomerProductHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProductHistoryCreateManyCustomerInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type CustomerProductHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput> | CustomerProductHistoryCreateWithoutCustomerInput[] | CustomerProductHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutCustomerInput | CustomerProductHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerProductHistoryCreateManyCustomerInputEnvelope
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
  }

  export type AdminUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<AdminCreateWithoutCustomersInput, AdminUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCustomersInput
    upsert?: AdminUpsertWithoutCustomersInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCustomersInput, AdminUpdateWithoutCustomersInput>, AdminUncheckedUpdateWithoutCustomersInput>
  }

  export type PartnerUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<PartnerCreateWithoutCustomersInput, PartnerUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutCustomersInput
    upsert?: PartnerUpsertWithoutCustomersInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutCustomersInput, PartnerUpdateWithoutCustomersInput>, PartnerUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerProductHistoryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput> | CustomerProductHistoryCreateWithoutCustomerInput[] | CustomerProductHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutCustomerInput | CustomerProductHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutCustomerInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProductHistoryCreateManyCustomerInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutCustomerInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutCustomerInput | CustomerProductHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput> | CustomerProductHistoryCreateWithoutCustomerInput[] | CustomerProductHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerProductHistoryCreateOrConnectWithoutCustomerInput | CustomerProductHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerProductHistoryUpsertWithWhereUniqueWithoutCustomerInput | CustomerProductHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerProductHistoryCreateManyCustomerInputEnvelope
    set?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    disconnect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    delete?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    connect?: CustomerProductHistoryWhereUniqueInput | CustomerProductHistoryWhereUniqueInput[]
    update?: CustomerProductHistoryUpdateWithWhereUniqueWithoutCustomerInput | CustomerProductHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerProductHistoryUpdateManyWithWhereWithoutCustomerInput | CustomerProductHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutProductInput = {
    create?: XOR<CustomerCreateWithoutProductInput, CustomerUncheckedCreateWithoutProductInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProductInput
    connect?: CustomerWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutProductHistoriesInput = {
    create?: XOR<AdminCreateWithoutProductHistoriesInput, AdminUncheckedCreateWithoutProductHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutProductHistoriesInput
    connect?: AdminWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCustomerProductHistoryInput = {
    create?: XOR<ProductCreateWithoutCustomerProductHistoryInput, ProductUncheckedCreateWithoutCustomerProductHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductRenewalHistoryCreateNestedManyWithoutCustomerProductHistoryInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput> | ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput[] | ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput | ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput[]
    createMany?: ProductRenewalHistoryCreateManyCustomerProductHistoryInputEnvelope
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
  }

  export type ProductRenewalHistoryUncheckedCreateNestedManyWithoutCustomerProductHistoryInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput> | ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput[] | ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput | ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput[]
    createMany?: ProductRenewalHistoryCreateManyCustomerProductHistoryInputEnvelope
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
  }

  export type EnumrenewPeriodFieldUpdateOperationsInput = {
    set?: $Enums.renewPeriod
  }

  export type CustomerUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<CustomerCreateWithoutProductInput, CustomerUncheckedCreateWithoutProductInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutProductInput
    upsert?: CustomerUpsertWithoutProductInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutProductInput, CustomerUpdateWithoutProductInput>, CustomerUncheckedUpdateWithoutProductInput>
  }

  export type AdminUpdateOneRequiredWithoutProductHistoriesNestedInput = {
    create?: XOR<AdminCreateWithoutProductHistoriesInput, AdminUncheckedCreateWithoutProductHistoriesInput>
    connectOrCreate?: AdminCreateOrConnectWithoutProductHistoriesInput
    upsert?: AdminUpsertWithoutProductHistoriesInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutProductHistoriesInput, AdminUpdateWithoutProductHistoriesInput>, AdminUncheckedUpdateWithoutProductHistoriesInput>
  }

  export type ProductUpdateOneRequiredWithoutCustomerProductHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutCustomerProductHistoryInput, ProductUncheckedCreateWithoutCustomerProductHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCustomerProductHistoryInput
    upsert?: ProductUpsertWithoutCustomerProductHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCustomerProductHistoryInput, ProductUpdateWithoutCustomerProductHistoryInput>, ProductUncheckedUpdateWithoutCustomerProductHistoryInput>
  }

  export type ProductRenewalHistoryUpdateManyWithoutCustomerProductHistoryNestedInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput> | ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput[] | ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput | ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput[]
    upsert?: ProductRenewalHistoryUpsertWithWhereUniqueWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpsertWithWhereUniqueWithoutCustomerProductHistoryInput[]
    createMany?: ProductRenewalHistoryCreateManyCustomerProductHistoryInputEnvelope
    set?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    disconnect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    delete?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    update?: ProductRenewalHistoryUpdateWithWhereUniqueWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpdateWithWhereUniqueWithoutCustomerProductHistoryInput[]
    updateMany?: ProductRenewalHistoryUpdateManyWithWhereWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpdateManyWithWhereWithoutCustomerProductHistoryInput[]
    deleteMany?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
  }

  export type ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryNestedInput = {
    create?: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput> | ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput[] | ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput[]
    connectOrCreate?: ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput | ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput[]
    upsert?: ProductRenewalHistoryUpsertWithWhereUniqueWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpsertWithWhereUniqueWithoutCustomerProductHistoryInput[]
    createMany?: ProductRenewalHistoryCreateManyCustomerProductHistoryInputEnvelope
    set?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    disconnect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    delete?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    connect?: ProductRenewalHistoryWhereUniqueInput | ProductRenewalHistoryWhereUniqueInput[]
    update?: ProductRenewalHistoryUpdateWithWhereUniqueWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpdateWithWhereUniqueWithoutCustomerProductHistoryInput[]
    updateMany?: ProductRenewalHistoryUpdateManyWithWhereWithoutCustomerProductHistoryInput | ProductRenewalHistoryUpdateManyWithWhereWithoutCustomerProductHistoryInput[]
    deleteMany?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
  }

  export type AdminCustomFieldCreateoptionsInput = {
    set: string[]
  }

  export type AdminCreateNestedOneWithoutCustomFieldsInput = {
    create?: XOR<AdminCreateWithoutCustomFieldsInput, AdminUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCustomFieldsInput
    connect?: AdminWhereUniqueInput
  }

  export type AdminCustomFieldUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AdminUpdateOneRequiredWithoutCustomFieldsNestedInput = {
    create?: XOR<AdminCreateWithoutCustomFieldsInput, AdminUncheckedCreateWithoutCustomFieldsInput>
    connectOrCreate?: AdminCreateOrConnectWithoutCustomFieldsInput
    upsert?: AdminUpsertWithoutCustomFieldsInput
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutCustomFieldsInput, AdminUpdateWithoutCustomFieldsInput>, AdminUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type LoginCredentialCreateNestedOneWithoutLoginAuditsInput = {
    create?: XOR<LoginCredentialCreateWithoutLoginAuditsInput, LoginCredentialUncheckedCreateWithoutLoginAuditsInput>
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutLoginAuditsInput
    connect?: LoginCredentialWhereUniqueInput
  }

  export type LoginCredentialUpdateOneRequiredWithoutLoginAuditsNestedInput = {
    create?: XOR<LoginCredentialCreateWithoutLoginAuditsInput, LoginCredentialUncheckedCreateWithoutLoginAuditsInput>
    connectOrCreate?: LoginCredentialCreateOrConnectWithoutLoginAuditsInput
    upsert?: LoginCredentialUpsertWithoutLoginAuditsInput
    connect?: LoginCredentialWhereUniqueInput
    update?: XOR<XOR<LoginCredentialUpdateToOneWithWhereWithoutLoginAuditsInput, LoginCredentialUpdateWithoutLoginAuditsInput>, LoginCredentialUncheckedUpdateWithoutLoginAuditsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOfferTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferTypeFilter<$PrismaModel> | $Enums.OfferType
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OfferType | EnumOfferTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OfferType[] | ListEnumOfferTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOfferTypeWithAggregatesFilter<$PrismaModel> | $Enums.OfferType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOfferTypeFilter<$PrismaModel>
    _max?: NestedEnumOfferTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumrenewPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.renewPeriod | EnumrenewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumrenewPeriodFilter<$PrismaModel> | $Enums.renewPeriod
  }

  export type NestedEnumrenewPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.renewPeriod | EnumrenewPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    notIn?: $Enums.renewPeriod[] | ListEnumrenewPeriodFieldRefInput<$PrismaModel>
    not?: NestedEnumrenewPeriodWithAggregatesFilter<$PrismaModel> | $Enums.renewPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrenewPeriodFilter<$PrismaModel>
    _max?: NestedEnumrenewPeriodFilter<$PrismaModel>
  }

  export type LoginCredentialCreateWithoutSuperadminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutLoginCredsInput
    loginAudits?: LoginAuditCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialUncheckedCreateWithoutSuperadminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialCreateOrConnectWithoutSuperadminInput = {
    where: LoginCredentialWhereUniqueInput
    create: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput>
  }

  export type LoginCredentialCreateManySuperadminInputEnvelope = {
    data: LoginCredentialCreateManySuperadminInput | LoginCredentialCreateManySuperadminInput[]
    skipDuplicates?: boolean
  }

  export type LoginCredentialUpsertWithWhereUniqueWithoutSuperadminInput = {
    where: LoginCredentialWhereUniqueInput
    update: XOR<LoginCredentialUpdateWithoutSuperadminInput, LoginCredentialUncheckedUpdateWithoutSuperadminInput>
    create: XOR<LoginCredentialCreateWithoutSuperadminInput, LoginCredentialUncheckedCreateWithoutSuperadminInput>
  }

  export type LoginCredentialUpdateWithWhereUniqueWithoutSuperadminInput = {
    where: LoginCredentialWhereUniqueInput
    data: XOR<LoginCredentialUpdateWithoutSuperadminInput, LoginCredentialUncheckedUpdateWithoutSuperadminInput>
  }

  export type LoginCredentialUpdateManyWithWhereWithoutSuperadminInput = {
    where: LoginCredentialScalarWhereInput
    data: XOR<LoginCredentialUpdateManyMutationInput, LoginCredentialUncheckedUpdateManyWithoutSuperadminInput>
  }

  export type LoginCredentialScalarWhereInput = {
    AND?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
    OR?: LoginCredentialScalarWhereInput[]
    NOT?: LoginCredentialScalarWhereInput | LoginCredentialScalarWhereInput[]
    id?: UuidFilter<"LoginCredential"> | string
    role?: EnumRoleFilter<"LoginCredential"> | $Enums.Role
    email?: StringFilter<"LoginCredential"> | string
    passwordHash?: StringFilter<"LoginCredential"> | string
    userProfileId?: UuidFilter<"LoginCredential"> | string
    adminId?: UuidNullableFilter<"LoginCredential"> | string | null
    status?: BoolFilter<"LoginCredential"> | boolean
    createdAt?: DateTimeFilter<"LoginCredential"> | Date | string
    updatedAt?: DateTimeFilter<"LoginCredential"> | Date | string
    superAdminId?: UuidNullableFilter<"LoginCredential"> | string | null
  }

  export type TeamMemberCreateWithoutAdminInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUncheckedCreateWithoutAdminInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutAdminInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput>
  }

  export type TeamMemberCreateManyAdminInputEnvelope = {
    data: TeamMemberCreateManyAdminInput | TeamMemberCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type PartnerCreateWithoutAdminInput = {
    id?: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutAdminInput = {
    id?: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutAdminInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput>
  }

  export type PartnerCreateManyAdminInputEnvelope = {
    data: PartnerCreateManyAdminInput | PartnerCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type CustomerCreateWithoutAdminInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutCustomersInput
    product?: CustomerProductHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAdminInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    partnerId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: CustomerProductHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAdminInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput>
  }

  export type CustomerCreateManyAdminInputEnvelope = {
    data: CustomerCreateManyAdminInput | CustomerCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminCustomFieldCreateWithoutAdminInput = {
    id?: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCustomFieldUncheckedCreateWithoutAdminInput = {
    id?: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCustomFieldCreateOrConnectWithoutAdminInput = {
    where: AdminCustomFieldWhereUniqueInput
    create: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput>
  }

  export type AdminCustomFieldCreateManyAdminInputEnvelope = {
    data: AdminCustomFieldCreateManyAdminInput | AdminCustomFieldCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutAdminInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory?: CustomerProductHistoryCreateNestedManyWithoutProductInput
    renewalHistory?: ProductRenewalHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdminInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedCreateNestedManyWithoutProductInput
    renewalHistory?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdminInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput>
  }

  export type ProductCreateManyAdminInputEnvelope = {
    data: ProductCreateManyAdminInput | ProductCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutAdminInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: SubscriptionPaymentCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutAdminInput = {
    id?: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SubscriptionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutAdminInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput>
  }

  export type SubscriptionCreateManyAdminInputEnvelope = {
    data: SubscriptionCreateManyAdminInput | SubscriptionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type LoginCredentialCreateWithoutAdminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superadmin?: SuperAdminCreateNestedOneWithoutLoginCredsInput
    loginAudits?: LoginAuditCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialUncheckedCreateWithoutAdminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId?: string | null
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutLoginCredentialInput
  }

  export type LoginCredentialCreateOrConnectWithoutAdminInput = {
    where: LoginCredentialWhereUniqueInput
    create: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput>
  }

  export type LoginCredentialCreateManyAdminInputEnvelope = {
    data: LoginCredentialCreateManyAdminInput | LoginCredentialCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type CustomerProductHistoryCreateWithoutAdminInput = {
    id?: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProductInput
    product: ProductCreateNestedOneWithoutCustomerProductHistoryInput
    renewals?: ProductRenewalHistoryCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUncheckedCreateWithoutAdminInput = {
    id?: string
    customerId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    renewals?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryCreateOrConnectWithoutAdminInput = {
    where: CustomerProductHistoryWhereUniqueInput
    create: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput>
  }

  export type CustomerProductHistoryCreateManyAdminInputEnvelope = {
    data: CustomerProductHistoryCreateManyAdminInput | CustomerProductHistoryCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutAdminInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutAdminInput, TeamMemberUncheckedUpdateWithoutAdminInput>
    create: XOR<TeamMemberCreateWithoutAdminInput, TeamMemberUncheckedCreateWithoutAdminInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutAdminInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutAdminInput, TeamMemberUncheckedUpdateWithoutAdminInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutAdminInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutAdminInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: UuidFilter<"TeamMember"> | string
    adminId?: UuidFilter<"TeamMember"> | string
    role?: EnumRoleFilter<"TeamMember"> | $Enums.Role
    firstName?: StringFilter<"TeamMember"> | string
    lastName?: StringFilter<"TeamMember"> | string
    email?: StringFilter<"TeamMember"> | string
    passwordHash?: StringFilter<"TeamMember"> | string
    department?: StringNullableFilter<"TeamMember"> | string | null
    position?: StringNullableFilter<"TeamMember"> | string | null
    status?: BoolFilter<"TeamMember"> | boolean
    contactInfo?: JsonNullableFilter<"TeamMember">
    address?: JsonNullableFilter<"TeamMember">
    createdAt?: DateTimeFilter<"TeamMember"> | Date | string
    updatedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type PartnerUpsertWithWhereUniqueWithoutAdminInput = {
    where: PartnerWhereUniqueInput
    update: XOR<PartnerUpdateWithoutAdminInput, PartnerUncheckedUpdateWithoutAdminInput>
    create: XOR<PartnerCreateWithoutAdminInput, PartnerUncheckedCreateWithoutAdminInput>
  }

  export type PartnerUpdateWithWhereUniqueWithoutAdminInput = {
    where: PartnerWhereUniqueInput
    data: XOR<PartnerUpdateWithoutAdminInput, PartnerUncheckedUpdateWithoutAdminInput>
  }

  export type PartnerUpdateManyWithWhereWithoutAdminInput = {
    where: PartnerScalarWhereInput
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyWithoutAdminInput>
  }

  export type PartnerScalarWhereInput = {
    AND?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    OR?: PartnerScalarWhereInput[]
    NOT?: PartnerScalarWhereInput | PartnerScalarWhereInput[]
    id?: UuidFilter<"Partner"> | string
    adminId?: UuidFilter<"Partner"> | string
    role?: EnumRoleFilter<"Partner"> | $Enums.Role
    companyName?: StringFilter<"Partner"> | string
    firstName?: StringFilter<"Partner"> | string
    lastName?: StringFilter<"Partner"> | string
    contactInfo?: JsonNullableFilter<"Partner">
    address?: JsonNullableFilter<"Partner">
    email?: StringFilter<"Partner"> | string
    passwordHash?: StringFilter<"Partner"> | string
    status?: BoolFilter<"Partner"> | boolean
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    updatedAt?: DateTimeFilter<"Partner"> | Date | string
  }

  export type CustomerUpsertWithWhereUniqueWithoutAdminInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAdminInput, CustomerUncheckedUpdateWithoutAdminInput>
    create: XOR<CustomerCreateWithoutAdminInput, CustomerUncheckedCreateWithoutAdminInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAdminInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAdminInput, CustomerUncheckedUpdateWithoutAdminInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAdminInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutAdminInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: UuidFilter<"Customer"> | string
    adminId?: UuidFilter<"Customer"> | string
    companyName?: StringFilter<"Customer"> | string
    contactPerson?: StringFilter<"Customer"> | string
    mobileNumber?: StringFilter<"Customer"> | string
    email?: StringFilter<"Customer"> | string
    serialNo?: StringFilter<"Customer"> | string
    prime?: BoolFilter<"Customer"> | boolean
    blacklisted?: BoolFilter<"Customer"> | boolean
    remark?: StringNullableFilter<"Customer"> | string | null
    adminCustomFields?: JsonNullableFilter<"Customer">
    address?: JsonFilter<"Customer">
    joiningDate?: DateTimeFilter<"Customer"> | Date | string
    hasReference?: BoolFilter<"Customer"> | boolean
    partnerId?: UuidNullableFilter<"Customer"> | string | null
    status?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type AdminCustomFieldUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminCustomFieldWhereUniqueInput
    update: XOR<AdminCustomFieldUpdateWithoutAdminInput, AdminCustomFieldUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminCustomFieldCreateWithoutAdminInput, AdminCustomFieldUncheckedCreateWithoutAdminInput>
  }

  export type AdminCustomFieldUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminCustomFieldWhereUniqueInput
    data: XOR<AdminCustomFieldUpdateWithoutAdminInput, AdminCustomFieldUncheckedUpdateWithoutAdminInput>
  }

  export type AdminCustomFieldUpdateManyWithWhereWithoutAdminInput = {
    where: AdminCustomFieldScalarWhereInput
    data: XOR<AdminCustomFieldUpdateManyMutationInput, AdminCustomFieldUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminCustomFieldScalarWhereInput = {
    AND?: AdminCustomFieldScalarWhereInput | AdminCustomFieldScalarWhereInput[]
    OR?: AdminCustomFieldScalarWhereInput[]
    NOT?: AdminCustomFieldScalarWhereInput | AdminCustomFieldScalarWhereInput[]
    id?: UuidFilter<"AdminCustomField"> | string
    adminId?: UuidFilter<"AdminCustomField"> | string
    fieldName?: StringFilter<"AdminCustomField"> | string
    fieldType?: StringFilter<"AdminCustomField"> | string
    isRequired?: BoolFilter<"AdminCustomField"> | boolean
    options?: StringNullableListFilter<"AdminCustomField">
    isMultiSelect?: BoolFilter<"AdminCustomField"> | boolean
    status?: BoolFilter<"AdminCustomField"> | boolean
    createdAt?: DateTimeFilter<"AdminCustomField"> | Date | string
    updatedAt?: DateTimeFilter<"AdminCustomField"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutAdminInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutAdminInput, ProductUncheckedUpdateWithoutAdminInput>
    create: XOR<ProductCreateWithoutAdminInput, ProductUncheckedCreateWithoutAdminInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutAdminInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutAdminInput, ProductUncheckedUpdateWithoutAdminInput>
  }

  export type ProductUpdateManyWithWhereWithoutAdminInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutAdminInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    productName?: StringFilter<"Product"> | string
    productCategory?: JsonFilter<"Product">
    productPrice?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    productLink?: StringNullableFilter<"Product"> | string | null
    tags?: StringNullableListFilter<"Product">
    specifications?: JsonFilter<"Product">
    adminId?: UuidFilter<"Product"> | string
    status?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutAdminInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutAdminInput, SubscriptionUncheckedUpdateWithoutAdminInput>
    create: XOR<SubscriptionCreateWithoutAdminInput, SubscriptionUncheckedCreateWithoutAdminInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutAdminInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutAdminInput, SubscriptionUncheckedUpdateWithoutAdminInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutAdminInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutAdminInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: UuidFilter<"Subscription"> | string
    adminId?: UuidFilter<"Subscription"> | string
    planId?: UuidFilter<"Subscription"> | string
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startsAt?: DateTimeFilter<"Subscription"> | Date | string
    endsAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    renewedAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type LoginCredentialUpsertWithWhereUniqueWithoutAdminInput = {
    where: LoginCredentialWhereUniqueInput
    update: XOR<LoginCredentialUpdateWithoutAdminInput, LoginCredentialUncheckedUpdateWithoutAdminInput>
    create: XOR<LoginCredentialCreateWithoutAdminInput, LoginCredentialUncheckedCreateWithoutAdminInput>
  }

  export type LoginCredentialUpdateWithWhereUniqueWithoutAdminInput = {
    where: LoginCredentialWhereUniqueInput
    data: XOR<LoginCredentialUpdateWithoutAdminInput, LoginCredentialUncheckedUpdateWithoutAdminInput>
  }

  export type LoginCredentialUpdateManyWithWhereWithoutAdminInput = {
    where: LoginCredentialScalarWhereInput
    data: XOR<LoginCredentialUpdateManyMutationInput, LoginCredentialUncheckedUpdateManyWithoutAdminInput>
  }

  export type CustomerProductHistoryUpsertWithWhereUniqueWithoutAdminInput = {
    where: CustomerProductHistoryWhereUniqueInput
    update: XOR<CustomerProductHistoryUpdateWithoutAdminInput, CustomerProductHistoryUncheckedUpdateWithoutAdminInput>
    create: XOR<CustomerProductHistoryCreateWithoutAdminInput, CustomerProductHistoryUncheckedCreateWithoutAdminInput>
  }

  export type CustomerProductHistoryUpdateWithWhereUniqueWithoutAdminInput = {
    where: CustomerProductHistoryWhereUniqueInput
    data: XOR<CustomerProductHistoryUpdateWithoutAdminInput, CustomerProductHistoryUncheckedUpdateWithoutAdminInput>
  }

  export type CustomerProductHistoryUpdateManyWithWhereWithoutAdminInput = {
    where: CustomerProductHistoryScalarWhereInput
    data: XOR<CustomerProductHistoryUpdateManyMutationInput, CustomerProductHistoryUncheckedUpdateManyWithoutAdminInput>
  }

  export type CustomerProductHistoryScalarWhereInput = {
    AND?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
    OR?: CustomerProductHistoryScalarWhereInput[]
    NOT?: CustomerProductHistoryScalarWhereInput | CustomerProductHistoryScalarWhereInput[]
    id?: UuidFilter<"CustomerProductHistory"> | string
    customerId?: UuidFilter<"CustomerProductHistory"> | string
    adminId?: UuidFilter<"CustomerProductHistory"> | string
    productId?: UuidFilter<"CustomerProductHistory"> | string
    purchaseDate?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    renewal?: BoolFilter<"CustomerProductHistory"> | boolean
    renewPeriod?: EnumrenewPeriodFilter<"CustomerProductHistory"> | $Enums.renewPeriod
    expiryDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    renewalDate?: DateTimeNullableFilter<"CustomerProductHistory"> | Date | string | null
    status?: BoolFilter<"CustomerProductHistory"> | boolean
    createdAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerProductHistory"> | Date | string
  }

  export type AdminCreateWithoutTeamMembersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutTeamMembersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutTeamMembersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutTeamMembersInput, AdminUncheckedCreateWithoutTeamMembersInput>
  }

  export type AdminUpsertWithoutTeamMembersInput = {
    update: XOR<AdminUpdateWithoutTeamMembersInput, AdminUncheckedUpdateWithoutTeamMembersInput>
    create: XOR<AdminCreateWithoutTeamMembersInput, AdminUncheckedCreateWithoutTeamMembersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutTeamMembersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutTeamMembersInput, AdminUncheckedUpdateWithoutTeamMembersInput>
  }

  export type AdminUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutTeamMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type AdminCreateWithoutPartnersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutPartnersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutPartnersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutPartnersInput, AdminUncheckedCreateWithoutPartnersInput>
  }

  export type CustomerCreateWithoutPartnerInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutCustomersInput
    product?: CustomerProductHistoryCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPartnerInput = {
    id?: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product?: CustomerProductHistoryUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPartnerInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput>
  }

  export type CustomerCreateManyPartnerInputEnvelope = {
    data: CustomerCreateManyPartnerInput | CustomerCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutPartnersInput = {
    update: XOR<AdminUpdateWithoutPartnersInput, AdminUncheckedUpdateWithoutPartnersInput>
    create: XOR<AdminCreateWithoutPartnersInput, AdminUncheckedCreateWithoutPartnersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutPartnersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutPartnersInput, AdminUncheckedUpdateWithoutPartnersInput>
  }

  export type AdminUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutPartnersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type CustomerUpsertWithWhereUniqueWithoutPartnerInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutPartnerInput, CustomerUncheckedUpdateWithoutPartnerInput>
    create: XOR<CustomerCreateWithoutPartnerInput, CustomerUncheckedCreateWithoutPartnerInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutPartnerInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutPartnerInput, CustomerUncheckedUpdateWithoutPartnerInput>
  }

  export type CustomerUpdateManyWithWhereWithoutPartnerInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutPartnerInput>
  }

  export type AdminCreateWithoutLoginCredsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutLoginCredsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutLoginCredsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutLoginCredsInput, AdminUncheckedCreateWithoutLoginCredsInput>
  }

  export type SuperAdminCreateWithoutLoginCredsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminUncheckedCreateWithoutLoginCredsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SuperAdminCreateOrConnectWithoutLoginCredsInput = {
    where: SuperAdminWhereUniqueInput
    create: XOR<SuperAdminCreateWithoutLoginCredsInput, SuperAdminUncheckedCreateWithoutLoginCredsInput>
  }

  export type LoginAuditCreateWithoutLoginCredentialInput = {
    id?: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LoginAuditUncheckedCreateWithoutLoginCredentialInput = {
    id?: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LoginAuditCreateOrConnectWithoutLoginCredentialInput = {
    where: LoginAuditWhereUniqueInput
    create: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput>
  }

  export type LoginAuditCreateManyLoginCredentialInputEnvelope = {
    data: LoginAuditCreateManyLoginCredentialInput | LoginAuditCreateManyLoginCredentialInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutLoginCredsInput = {
    update: XOR<AdminUpdateWithoutLoginCredsInput, AdminUncheckedUpdateWithoutLoginCredsInput>
    create: XOR<AdminCreateWithoutLoginCredsInput, AdminUncheckedCreateWithoutLoginCredsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutLoginCredsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutLoginCredsInput, AdminUncheckedUpdateWithoutLoginCredsInput>
  }

  export type AdminUpdateWithoutLoginCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutLoginCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type SuperAdminUpsertWithoutLoginCredsInput = {
    update: XOR<SuperAdminUpdateWithoutLoginCredsInput, SuperAdminUncheckedUpdateWithoutLoginCredsInput>
    create: XOR<SuperAdminCreateWithoutLoginCredsInput, SuperAdminUncheckedCreateWithoutLoginCredsInput>
    where?: SuperAdminWhereInput
  }

  export type SuperAdminUpdateToOneWithWhereWithoutLoginCredsInput = {
    where?: SuperAdminWhereInput
    data: XOR<SuperAdminUpdateWithoutLoginCredsInput, SuperAdminUncheckedUpdateWithoutLoginCredsInput>
  }

  export type SuperAdminUpdateWithoutLoginCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SuperAdminUncheckedUpdateWithoutLoginCredsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUpsertWithWhereUniqueWithoutLoginCredentialInput = {
    where: LoginAuditWhereUniqueInput
    update: XOR<LoginAuditUpdateWithoutLoginCredentialInput, LoginAuditUncheckedUpdateWithoutLoginCredentialInput>
    create: XOR<LoginAuditCreateWithoutLoginCredentialInput, LoginAuditUncheckedCreateWithoutLoginCredentialInput>
  }

  export type LoginAuditUpdateWithWhereUniqueWithoutLoginCredentialInput = {
    where: LoginAuditWhereUniqueInput
    data: XOR<LoginAuditUpdateWithoutLoginCredentialInput, LoginAuditUncheckedUpdateWithoutLoginCredentialInput>
  }

  export type LoginAuditUpdateManyWithWhereWithoutLoginCredentialInput = {
    where: LoginAuditScalarWhereInput
    data: XOR<LoginAuditUpdateManyMutationInput, LoginAuditUncheckedUpdateManyWithoutLoginCredentialInput>
  }

  export type LoginAuditScalarWhereInput = {
    AND?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
    OR?: LoginAuditScalarWhereInput[]
    NOT?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
    id?: UuidFilter<"LoginAudit"> | string
    loginCredentialId?: UuidFilter<"LoginAudit"> | string
    attemptTime?: DateTimeFilter<"LoginAudit"> | Date | string
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringFilter<"LoginAudit"> | string
    userAgent?: StringFilter<"LoginAudit"> | string
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
  }

  export type PlanOfferCreateWithoutPlanInput = {
    id?: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOfferUncheckedCreateWithoutPlanInput = {
    id?: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOfferCreateOrConnectWithoutPlanInput = {
    where: PlanOfferWhereUniqueInput
    create: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput>
  }

  export type PlanOfferCreateManyPlanInputEnvelope = {
    data: PlanOfferCreateManyPlanInput | PlanOfferCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanSpecCreateWithoutPlanInput = {
    id?: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanSpecUncheckedCreateWithoutPlanInput = {
    id?: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanSpecCreateOrConnectWithoutPlanInput = {
    where: PlanSpecWhereUniqueInput
    create: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput>
  }

  export type PlanSpecCreateManyPlanInputEnvelope = {
    data: PlanSpecCreateManyPlanInput | PlanSpecCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanDescriptionCreateWithoutPlanInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanDescriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanDescriptionCreateOrConnectWithoutPlanInput = {
    where: PlanDescriptionWhereUniqueInput
    create: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput>
  }

  export type PlanDescriptionCreateManyPlanInputEnvelope = {
    data: PlanDescriptionCreateManyPlanInput | PlanDescriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionCreateWithoutPlanInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutSubscriptionsInput
    payments?: SubscriptionPaymentCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPlanInput = {
    id?: string
    adminId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SubscriptionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
    events?: SubscriptionEventUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionCreateManyPlanInputEnvelope = {
    data: SubscriptionCreateManyPlanInput | SubscriptionCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type PlanOfferUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanOfferWhereUniqueInput
    update: XOR<PlanOfferUpdateWithoutPlanInput, PlanOfferUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanOfferCreateWithoutPlanInput, PlanOfferUncheckedCreateWithoutPlanInput>
  }

  export type PlanOfferUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanOfferWhereUniqueInput
    data: XOR<PlanOfferUpdateWithoutPlanInput, PlanOfferUncheckedUpdateWithoutPlanInput>
  }

  export type PlanOfferUpdateManyWithWhereWithoutPlanInput = {
    where: PlanOfferScalarWhereInput
    data: XOR<PlanOfferUpdateManyMutationInput, PlanOfferUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanOfferScalarWhereInput = {
    AND?: PlanOfferScalarWhereInput | PlanOfferScalarWhereInput[]
    OR?: PlanOfferScalarWhereInput[]
    NOT?: PlanOfferScalarWhereInput | PlanOfferScalarWhereInput[]
    id?: UuidFilter<"PlanOffer"> | string
    planId?: UuidFilter<"PlanOffer"> | string
    offerType?: EnumOfferTypeFilter<"PlanOffer"> | $Enums.OfferType
    value?: FloatNullableFilter<"PlanOffer"> | number | null
    startsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"PlanOffer"> | Date | string | null
    createdAt?: DateTimeFilter<"PlanOffer"> | Date | string
    updatedAt?: DateTimeFilter<"PlanOffer"> | Date | string
  }

  export type PlanSpecUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanSpecWhereUniqueInput
    update: XOR<PlanSpecUpdateWithoutPlanInput, PlanSpecUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanSpecCreateWithoutPlanInput, PlanSpecUncheckedCreateWithoutPlanInput>
  }

  export type PlanSpecUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanSpecWhereUniqueInput
    data: XOR<PlanSpecUpdateWithoutPlanInput, PlanSpecUncheckedUpdateWithoutPlanInput>
  }

  export type PlanSpecUpdateManyWithWhereWithoutPlanInput = {
    where: PlanSpecScalarWhereInput
    data: XOR<PlanSpecUpdateManyMutationInput, PlanSpecUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanSpecScalarWhereInput = {
    AND?: PlanSpecScalarWhereInput | PlanSpecScalarWhereInput[]
    OR?: PlanSpecScalarWhereInput[]
    NOT?: PlanSpecScalarWhereInput | PlanSpecScalarWhereInput[]
    id?: UuidFilter<"PlanSpec"> | string
    planId?: UuidFilter<"PlanSpec"> | string
    specName?: StringFilter<"PlanSpec"> | string
    specValue?: StringFilter<"PlanSpec"> | string
    createdAt?: DateTimeFilter<"PlanSpec"> | Date | string
    updatedAt?: DateTimeFilter<"PlanSpec"> | Date | string
  }

  export type PlanDescriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: PlanDescriptionWhereUniqueInput
    update: XOR<PlanDescriptionUpdateWithoutPlanInput, PlanDescriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<PlanDescriptionCreateWithoutPlanInput, PlanDescriptionUncheckedCreateWithoutPlanInput>
  }

  export type PlanDescriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: PlanDescriptionWhereUniqueInput
    data: XOR<PlanDescriptionUpdateWithoutPlanInput, PlanDescriptionUncheckedUpdateWithoutPlanInput>
  }

  export type PlanDescriptionUpdateManyWithWhereWithoutPlanInput = {
    where: PlanDescriptionScalarWhereInput
    data: XOR<PlanDescriptionUpdateManyMutationInput, PlanDescriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanDescriptionScalarWhereInput = {
    AND?: PlanDescriptionScalarWhereInput | PlanDescriptionScalarWhereInput[]
    OR?: PlanDescriptionScalarWhereInput[]
    NOT?: PlanDescriptionScalarWhereInput | PlanDescriptionScalarWhereInput[]
    id?: UuidFilter<"PlanDescription"> | string
    planId?: UuidFilter<"PlanDescription"> | string
    content?: StringFilter<"PlanDescription"> | string
    createdAt?: DateTimeFilter<"PlanDescription"> | Date | string
    updatedAt?: DateTimeFilter<"PlanDescription"> | Date | string
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
    create: XOR<SubscriptionCreateWithoutPlanInput, SubscriptionUncheckedCreateWithoutPlanInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutPlanInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutPlanInput, SubscriptionUncheckedUpdateWithoutPlanInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutPlanInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutPlanInput>
  }

  export type PlanCreateWithoutOffersInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specs?: PlanSpecCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutOffersInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    specs?: PlanSpecUncheckedCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutOffersInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutOffersInput, PlanUncheckedCreateWithoutOffersInput>
  }

  export type PlanUpsertWithoutOffersInput = {
    update: XOR<PlanUpdateWithoutOffersInput, PlanUncheckedUpdateWithoutOffersInput>
    create: XOR<PlanCreateWithoutOffersInput, PlanUncheckedCreateWithoutOffersInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutOffersInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutOffersInput, PlanUncheckedUpdateWithoutOffersInput>
  }

  export type PlanUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specs?: PlanSpecUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutOffersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    specs?: PlanSpecUncheckedUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateWithoutSpecsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutSpecsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferUncheckedCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutSpecsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSpecsInput, PlanUncheckedCreateWithoutSpecsInput>
  }

  export type PlanUpsertWithoutSpecsInput = {
    update: XOR<PlanUpdateWithoutSpecsInput, PlanUncheckedUpdateWithoutSpecsInput>
    create: XOR<PlanCreateWithoutSpecsInput, PlanUncheckedCreateWithoutSpecsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSpecsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSpecsInput, PlanUncheckedUpdateWithoutSpecsInput>
  }

  export type PlanUpdateWithoutSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutSpecsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUncheckedUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type PlanCreateWithoutDescriptionsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferCreateNestedManyWithoutPlanInput
    specs?: PlanSpecCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutDescriptionsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferUncheckedCreateNestedManyWithoutPlanInput
    specs?: PlanSpecUncheckedCreateNestedManyWithoutPlanInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutDescriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutDescriptionsInput, PlanUncheckedCreateWithoutDescriptionsInput>
  }

  export type PlanUpsertWithoutDescriptionsInput = {
    update: XOR<PlanUpdateWithoutDescriptionsInput, PlanUncheckedUpdateWithoutDescriptionsInput>
    create: XOR<PlanCreateWithoutDescriptionsInput, PlanUncheckedCreateWithoutDescriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutDescriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutDescriptionsInput, PlanUncheckedUpdateWithoutDescriptionsInput>
  }

  export type PlanUpdateWithoutDescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutDescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUncheckedUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUncheckedUpdateManyWithoutPlanNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type AdminCreateWithoutSubscriptionsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutSubscriptionsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutSubscriptionsInput, AdminUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PlanCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferCreateNestedManyWithoutPlanInput
    specs?: PlanSpecCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionCreateNestedManyWithoutPlanInput
  }

  export type PlanUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    duration: string
    price: number
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    offers?: PlanOfferUncheckedCreateNestedManyWithoutPlanInput
    specs?: PlanSpecUncheckedCreateNestedManyWithoutPlanInput
    descriptions?: PlanDescriptionUncheckedCreateNestedManyWithoutPlanInput
  }

  export type PlanCreateOrConnectWithoutSubscriptionsInput = {
    where: PlanWhereUniqueInput
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
  }

  export type SubscriptionPaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionPaymentWhereUniqueInput
    create: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionPaymentCreateManySubscriptionInputEnvelope = {
    data: SubscriptionPaymentCreateManySubscriptionInput | SubscriptionPaymentCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type SubscriptionEventCreateWithoutSubscriptionInput = {
    id?: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionEventUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionEventCreateOrConnectWithoutSubscriptionInput = {
    where: SubscriptionEventWhereUniqueInput
    create: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionEventCreateManySubscriptionInputEnvelope = {
    data: SubscriptionEventCreateManySubscriptionInput | SubscriptionEventCreateManySubscriptionInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutSubscriptionsInput = {
    update: XOR<AdminUpdateWithoutSubscriptionsInput, AdminUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<AdminCreateWithoutSubscriptionsInput, AdminUncheckedCreateWithoutSubscriptionsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutSubscriptionsInput, AdminUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type AdminUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type PlanUpsertWithoutSubscriptionsInput = {
    update: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<PlanCreateWithoutSubscriptionsInput, PlanUncheckedCreateWithoutSubscriptionsInput>
    where?: PlanWhereInput
  }

  export type PlanUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: PlanWhereInput
    data: XOR<PlanUpdateWithoutSubscriptionsInput, PlanUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PlanUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUpdateManyWithoutPlanNestedInput
  }

  export type PlanUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    offers?: PlanOfferUncheckedUpdateManyWithoutPlanNestedInput
    specs?: PlanSpecUncheckedUpdateManyWithoutPlanNestedInput
    descriptions?: PlanDescriptionUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type SubscriptionPaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionPaymentWhereUniqueInput
    update: XOR<SubscriptionPaymentUpdateWithoutSubscriptionInput, SubscriptionPaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionPaymentCreateWithoutSubscriptionInput, SubscriptionPaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionPaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionPaymentWhereUniqueInput
    data: XOR<SubscriptionPaymentUpdateWithoutSubscriptionInput, SubscriptionPaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionPaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriptionPaymentScalarWhereInput
    data: XOR<SubscriptionPaymentUpdateManyMutationInput, SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionPaymentScalarWhereInput = {
    AND?: SubscriptionPaymentScalarWhereInput | SubscriptionPaymentScalarWhereInput[]
    OR?: SubscriptionPaymentScalarWhereInput[]
    NOT?: SubscriptionPaymentScalarWhereInput | SubscriptionPaymentScalarWhereInput[]
    id?: UuidFilter<"SubscriptionPayment"> | string
    subscriptionId?: UuidFilter<"SubscriptionPayment"> | string
    amount?: FloatFilter<"SubscriptionPayment"> | number
    currency?: StringFilter<"SubscriptionPayment"> | string
    paidAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    status?: StringFilter<"SubscriptionPayment"> | string
    paymentMethod?: StringNullableFilter<"SubscriptionPayment"> | string | null
    gatewayResponse?: JsonNullableFilter<"SubscriptionPayment">
    createdAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionPayment"> | Date | string
  }

  export type SubscriptionEventUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionEventWhereUniqueInput
    update: XOR<SubscriptionEventUpdateWithoutSubscriptionInput, SubscriptionEventUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<SubscriptionEventCreateWithoutSubscriptionInput, SubscriptionEventUncheckedCreateWithoutSubscriptionInput>
  }

  export type SubscriptionEventUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: SubscriptionEventWhereUniqueInput
    data: XOR<SubscriptionEventUpdateWithoutSubscriptionInput, SubscriptionEventUncheckedUpdateWithoutSubscriptionInput>
  }

  export type SubscriptionEventUpdateManyWithWhereWithoutSubscriptionInput = {
    where: SubscriptionEventScalarWhereInput
    data: XOR<SubscriptionEventUpdateManyMutationInput, SubscriptionEventUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type SubscriptionEventScalarWhereInput = {
    AND?: SubscriptionEventScalarWhereInput | SubscriptionEventScalarWhereInput[]
    OR?: SubscriptionEventScalarWhereInput[]
    NOT?: SubscriptionEventScalarWhereInput | SubscriptionEventScalarWhereInput[]
    id?: UuidFilter<"SubscriptionEvent"> | string
    subscriptionId?: UuidFilter<"SubscriptionEvent"> | string
    eventType?: StringFilter<"SubscriptionEvent"> | string
    eventAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    metadata?: JsonNullableFilter<"SubscriptionEvent">
    createdAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
    updatedAt?: DateTimeFilter<"SubscriptionEvent"> | Date | string
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    events?: SubscriptionEventCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    adminId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: SubscriptionEventUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    events?: SubscriptionEventUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: SubscriptionEventUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateWithoutEventsInput = {
    id?: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutSubscriptionsInput
    plan: PlanCreateNestedOneWithoutSubscriptionsInput
    payments?: SubscriptionPaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutEventsInput = {
    id?: string
    adminId: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: SubscriptionPaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutEventsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutEventsInput, SubscriptionUncheckedCreateWithoutEventsInput>
  }

  export type SubscriptionUpsertWithoutEventsInput = {
    update: XOR<SubscriptionUpdateWithoutEventsInput, SubscriptionUncheckedUpdateWithoutEventsInput>
    create: XOR<SubscriptionCreateWithoutEventsInput, SubscriptionUncheckedCreateWithoutEventsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutEventsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutEventsInput, SubscriptionUncheckedUpdateWithoutEventsInput>
  }

  export type SubscriptionUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutSubscriptionsNestedInput
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: SubscriptionPaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type AdminCreateWithoutProductsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutProductsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutProductsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutProductsInput, AdminUncheckedCreateWithoutProductsInput>
  }

  export type CustomerProductHistoryCreateWithoutProductInput = {
    id?: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProductInput
    admin: AdminCreateNestedOneWithoutProductHistoriesInput
    renewals?: ProductRenewalHistoryCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    customerId: string
    adminId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    renewals?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryCreateOrConnectWithoutProductInput = {
    where: CustomerProductHistoryWhereUniqueInput
    create: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductHistoryCreateManyProductInputEnvelope = {
    data: CustomerProductHistoryCreateManyProductInput | CustomerProductHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductRenewalHistoryCreateWithoutProductInput = {
    id?: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory: CustomerProductHistoryCreateNestedOneWithoutRenewalsInput
  }

  export type ProductRenewalHistoryUncheckedCreateWithoutProductInput = {
    id?: string
    customerProductHistoryId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryCreateOrConnectWithoutProductInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    create: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductRenewalHistoryCreateManyProductInputEnvelope = {
    data: ProductRenewalHistoryCreateManyProductInput | ProductRenewalHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutProductsInput = {
    update: XOR<AdminUpdateWithoutProductsInput, AdminUncheckedUpdateWithoutProductsInput>
    create: XOR<AdminCreateWithoutProductsInput, AdminUncheckedCreateWithoutProductsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutProductsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutProductsInput, AdminUncheckedUpdateWithoutProductsInput>
  }

  export type AdminUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type CustomerProductHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: CustomerProductHistoryWhereUniqueInput
    update: XOR<CustomerProductHistoryUpdateWithoutProductInput, CustomerProductHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerProductHistoryCreateWithoutProductInput, CustomerProductHistoryUncheckedCreateWithoutProductInput>
  }

  export type CustomerProductHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: CustomerProductHistoryWhereUniqueInput
    data: XOR<CustomerProductHistoryUpdateWithoutProductInput, CustomerProductHistoryUncheckedUpdateWithoutProductInput>
  }

  export type CustomerProductHistoryUpdateManyWithWhereWithoutProductInput = {
    where: CustomerProductHistoryScalarWhereInput
    data: XOR<CustomerProductHistoryUpdateManyMutationInput, CustomerProductHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductRenewalHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    update: XOR<ProductRenewalHistoryUpdateWithoutProductInput, ProductRenewalHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<ProductRenewalHistoryCreateWithoutProductInput, ProductRenewalHistoryUncheckedCreateWithoutProductInput>
  }

  export type ProductRenewalHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    data: XOR<ProductRenewalHistoryUpdateWithoutProductInput, ProductRenewalHistoryUncheckedUpdateWithoutProductInput>
  }

  export type ProductRenewalHistoryUpdateManyWithWhereWithoutProductInput = {
    where: ProductRenewalHistoryScalarWhereInput
    data: XOR<ProductRenewalHistoryUpdateManyMutationInput, ProductRenewalHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductRenewalHistoryScalarWhereInput = {
    AND?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
    OR?: ProductRenewalHistoryScalarWhereInput[]
    NOT?: ProductRenewalHistoryScalarWhereInput | ProductRenewalHistoryScalarWhereInput[]
    id?: UuidFilter<"ProductRenewalHistory"> | string
    customerProductHistoryId?: UuidFilter<"ProductRenewalHistory"> | string
    productId?: UuidFilter<"ProductRenewalHistory"> | string
    purchaseDate?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    renewalDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"ProductRenewalHistory"> | Date | string | null
    createdAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
    updatedAt?: DateTimeFilter<"ProductRenewalHistory"> | Date | string
  }

  export type CustomerProductHistoryCreateWithoutRenewalsInput = {
    id?: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutProductInput
    admin: AdminCreateNestedOneWithoutProductHistoriesInput
    product: ProductCreateNestedOneWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUncheckedCreateWithoutRenewalsInput = {
    id?: string
    customerId: string
    adminId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductHistoryCreateOrConnectWithoutRenewalsInput = {
    where: CustomerProductHistoryWhereUniqueInput
    create: XOR<CustomerProductHistoryCreateWithoutRenewalsInput, CustomerProductHistoryUncheckedCreateWithoutRenewalsInput>
  }

  export type ProductCreateWithoutRenewalHistoryInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutProductsInput
    customerProductHistory?: CustomerProductHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRenewalHistoryInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    adminId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRenewalHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRenewalHistoryInput, ProductUncheckedCreateWithoutRenewalHistoryInput>
  }

  export type CustomerProductHistoryUpsertWithoutRenewalsInput = {
    update: XOR<CustomerProductHistoryUpdateWithoutRenewalsInput, CustomerProductHistoryUncheckedUpdateWithoutRenewalsInput>
    create: XOR<CustomerProductHistoryCreateWithoutRenewalsInput, CustomerProductHistoryUncheckedCreateWithoutRenewalsInput>
    where?: CustomerProductHistoryWhereInput
  }

  export type CustomerProductHistoryUpdateToOneWithWhereWithoutRenewalsInput = {
    where?: CustomerProductHistoryWhereInput
    data: XOR<CustomerProductHistoryUpdateWithoutRenewalsInput, CustomerProductHistoryUncheckedUpdateWithoutRenewalsInput>
  }

  export type CustomerProductHistoryUpdateWithoutRenewalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProductNestedInput
    admin?: AdminUpdateOneRequiredWithoutProductHistoriesNestedInput
    product?: ProductUpdateOneRequiredWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateWithoutRenewalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpsertWithoutRenewalHistoryInput = {
    update: XOR<ProductUpdateWithoutRenewalHistoryInput, ProductUncheckedUpdateWithoutRenewalHistoryInput>
    create: XOR<ProductCreateWithoutRenewalHistoryInput, ProductUncheckedCreateWithoutRenewalHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRenewalHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRenewalHistoryInput, ProductUncheckedUpdateWithoutRenewalHistoryInput>
  }

  export type ProductUpdateWithoutRenewalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutProductsNestedInput
    customerProductHistory?: CustomerProductHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRenewalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type AdminCreateWithoutCustomersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCustomersInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCustomersInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCustomersInput, AdminUncheckedCreateWithoutCustomersInput>
  }

  export type PartnerCreateWithoutCustomersInput = {
    id?: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutPartnersInput
  }

  export type PartnerUncheckedCreateWithoutCustomersInput = {
    id?: string
    adminId: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCreateOrConnectWithoutCustomersInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutCustomersInput, PartnerUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerProductHistoryCreateWithoutCustomerInput = {
    id?: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutProductHistoriesInput
    product: ProductCreateNestedOneWithoutCustomerProductHistoryInput
    renewals?: ProductRenewalHistoryCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryUncheckedCreateWithoutCustomerInput = {
    id?: string
    adminId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    renewals?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutCustomerProductHistoryInput
  }

  export type CustomerProductHistoryCreateOrConnectWithoutCustomerInput = {
    where: CustomerProductHistoryWhereUniqueInput
    create: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductHistoryCreateManyCustomerInputEnvelope = {
    data: CustomerProductHistoryCreateManyCustomerInput | CustomerProductHistoryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type AdminUpsertWithoutCustomersInput = {
    update: XOR<AdminUpdateWithoutCustomersInput, AdminUncheckedUpdateWithoutCustomersInput>
    create: XOR<AdminCreateWithoutCustomersInput, AdminUncheckedCreateWithoutCustomersInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCustomersInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCustomersInput, AdminUncheckedUpdateWithoutCustomersInput>
  }

  export type AdminUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type PartnerUpsertWithoutCustomersInput = {
    update: XOR<PartnerUpdateWithoutCustomersInput, PartnerUncheckedUpdateWithoutCustomersInput>
    create: XOR<PartnerCreateWithoutCustomersInput, PartnerUncheckedCreateWithoutCustomersInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutCustomersInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutCustomersInput, PartnerUncheckedUpdateWithoutCustomersInput>
  }

  export type PartnerUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutPartnersNestedInput
  }

  export type PartnerUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductHistoryWhereUniqueInput
    update: XOR<CustomerProductHistoryUpdateWithoutCustomerInput, CustomerProductHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerProductHistoryCreateWithoutCustomerInput, CustomerProductHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerProductHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerProductHistoryWhereUniqueInput
    data: XOR<CustomerProductHistoryUpdateWithoutCustomerInput, CustomerProductHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerProductHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerProductHistoryScalarWhereInput
    data: XOR<CustomerProductHistoryUpdateManyMutationInput, CustomerProductHistoryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutProductInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutCustomersInput
    partner?: PartnerCreateNestedOneWithoutCustomersInput
  }

  export type CustomerUncheckedCreateWithoutProductInput = {
    id?: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    partnerId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateOrConnectWithoutProductInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutProductInput, CustomerUncheckedCreateWithoutProductInput>
  }

  export type AdminCreateWithoutProductHistoriesInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutProductHistoriesInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    customFields?: AdminCustomFieldUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutProductHistoriesInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutProductHistoriesInput, AdminUncheckedCreateWithoutProductHistoriesInput>
  }

  export type ProductCreateWithoutCustomerProductHistoryInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin: AdminCreateNestedOneWithoutProductsInput
    renewalHistory?: ProductRenewalHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCustomerProductHistoryInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    adminId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    renewalHistory?: ProductRenewalHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCustomerProductHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCustomerProductHistoryInput, ProductUncheckedCreateWithoutCustomerProductHistoryInput>
  }

  export type ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput = {
    id?: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutRenewalHistoryInput
  }

  export type ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput = {
    id?: string
    productId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryCreateOrConnectWithoutCustomerProductHistoryInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    create: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput>
  }

  export type ProductRenewalHistoryCreateManyCustomerProductHistoryInputEnvelope = {
    data: ProductRenewalHistoryCreateManyCustomerProductHistoryInput | ProductRenewalHistoryCreateManyCustomerProductHistoryInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutProductInput = {
    update: XOR<CustomerUpdateWithoutProductInput, CustomerUncheckedUpdateWithoutProductInput>
    create: XOR<CustomerCreateWithoutProductInput, CustomerUncheckedCreateWithoutProductInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutProductInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutProductInput, CustomerUncheckedUpdateWithoutProductInput>
  }

  export type CustomerUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutCustomersNestedInput
    partner?: PartnerUpdateOneWithoutCustomersNestedInput
  }

  export type CustomerUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUpsertWithoutProductHistoriesInput = {
    update: XOR<AdminUpdateWithoutProductHistoriesInput, AdminUncheckedUpdateWithoutProductHistoriesInput>
    create: XOR<AdminCreateWithoutProductHistoriesInput, AdminUncheckedCreateWithoutProductHistoriesInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutProductHistoriesInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutProductHistoriesInput, AdminUncheckedUpdateWithoutProductHistoriesInput>
  }

  export type AdminUpdateWithoutProductHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutProductHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    customFields?: AdminCustomFieldUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type ProductUpsertWithoutCustomerProductHistoryInput = {
    update: XOR<ProductUpdateWithoutCustomerProductHistoryInput, ProductUncheckedUpdateWithoutCustomerProductHistoryInput>
    create: XOR<ProductCreateWithoutCustomerProductHistoryInput, ProductUncheckedCreateWithoutCustomerProductHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCustomerProductHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCustomerProductHistoryInput, ProductUncheckedUpdateWithoutCustomerProductHistoryInput>
  }

  export type ProductUpdateWithoutCustomerProductHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutProductsNestedInput
    renewalHistory?: ProductRenewalHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCustomerProductHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    adminId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalHistory?: ProductRenewalHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductRenewalHistoryUpsertWithWhereUniqueWithoutCustomerProductHistoryInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    update: XOR<ProductRenewalHistoryUpdateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedUpdateWithoutCustomerProductHistoryInput>
    create: XOR<ProductRenewalHistoryCreateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedCreateWithoutCustomerProductHistoryInput>
  }

  export type ProductRenewalHistoryUpdateWithWhereUniqueWithoutCustomerProductHistoryInput = {
    where: ProductRenewalHistoryWhereUniqueInput
    data: XOR<ProductRenewalHistoryUpdateWithoutCustomerProductHistoryInput, ProductRenewalHistoryUncheckedUpdateWithoutCustomerProductHistoryInput>
  }

  export type ProductRenewalHistoryUpdateManyWithWhereWithoutCustomerProductHistoryInput = {
    where: ProductRenewalHistoryScalarWhereInput
    data: XOR<ProductRenewalHistoryUpdateManyMutationInput, ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryInput>
  }

  export type AdminCreateWithoutCustomFieldsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberCreateNestedManyWithoutAdminInput
    partners?: PartnerCreateNestedManyWithoutAdminInput
    customers?: CustomerCreateNestedManyWithoutAdminInput
    products?: ProductCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryCreateNestedManyWithoutAdminInput
  }

  export type AdminUncheckedCreateWithoutCustomFieldsInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    companyName: string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teamMembers?: TeamMemberUncheckedCreateNestedManyWithoutAdminInput
    partners?: PartnerUncheckedCreateNestedManyWithoutAdminInput
    customers?: CustomerUncheckedCreateNestedManyWithoutAdminInput
    products?: ProductUncheckedCreateNestedManyWithoutAdminInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutAdminInput
    loginCreds?: LoginCredentialUncheckedCreateNestedManyWithoutAdminInput
    productHistories?: CustomerProductHistoryUncheckedCreateNestedManyWithoutAdminInput
  }

  export type AdminCreateOrConnectWithoutCustomFieldsInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutCustomFieldsInput, AdminUncheckedCreateWithoutCustomFieldsInput>
  }

  export type AdminUpsertWithoutCustomFieldsInput = {
    update: XOR<AdminUpdateWithoutCustomFieldsInput, AdminUncheckedUpdateWithoutCustomFieldsInput>
    create: XOR<AdminCreateWithoutCustomFieldsInput, AdminUncheckedCreateWithoutCustomFieldsInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutCustomFieldsInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutCustomFieldsInput, AdminUncheckedUpdateWithoutCustomFieldsInput>
  }

  export type AdminUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUpdateManyWithoutAdminNestedInput
    partners?: PartnerUpdateManyWithoutAdminNestedInput
    customers?: CustomerUpdateManyWithoutAdminNestedInput
    products?: ProductUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUpdateManyWithoutAdminNestedInput
  }

  export type AdminUncheckedUpdateWithoutCustomFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    address?: NullableJsonNullValueInput | InputJsonValue
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamMembers?: TeamMemberUncheckedUpdateManyWithoutAdminNestedInput
    partners?: PartnerUncheckedUpdateManyWithoutAdminNestedInput
    customers?: CustomerUncheckedUpdateManyWithoutAdminNestedInput
    products?: ProductUncheckedUpdateManyWithoutAdminNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutAdminNestedInput
    loginCreds?: LoginCredentialUncheckedUpdateManyWithoutAdminNestedInput
    productHistories?: CustomerProductHistoryUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type LoginCredentialCreateWithoutLoginAuditsInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    admin?: AdminCreateNestedOneWithoutLoginCredsInput
    superadmin?: SuperAdminCreateNestedOneWithoutLoginCredsInput
  }

  export type LoginCredentialUncheckedCreateWithoutLoginAuditsInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId?: string | null
  }

  export type LoginCredentialCreateOrConnectWithoutLoginAuditsInput = {
    where: LoginCredentialWhereUniqueInput
    create: XOR<LoginCredentialCreateWithoutLoginAuditsInput, LoginCredentialUncheckedCreateWithoutLoginAuditsInput>
  }

  export type LoginCredentialUpsertWithoutLoginAuditsInput = {
    update: XOR<LoginCredentialUpdateWithoutLoginAuditsInput, LoginCredentialUncheckedUpdateWithoutLoginAuditsInput>
    create: XOR<LoginCredentialCreateWithoutLoginAuditsInput, LoginCredentialUncheckedCreateWithoutLoginAuditsInput>
    where?: LoginCredentialWhereInput
  }

  export type LoginCredentialUpdateToOneWithWhereWithoutLoginAuditsInput = {
    where?: LoginCredentialWhereInput
    data: XOR<LoginCredentialUpdateWithoutLoginAuditsInput, LoginCredentialUncheckedUpdateWithoutLoginAuditsInput>
  }

  export type LoginCredentialUpdateWithoutLoginAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutLoginCredsNestedInput
    superadmin?: SuperAdminUpdateOneWithoutLoginCredsNestedInput
  }

  export type LoginCredentialUncheckedUpdateWithoutLoginAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LoginCredentialCreateManySuperadminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    adminId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginCredentialUpdateWithoutSuperadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneWithoutLoginCredsNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialUncheckedUpdateWithoutSuperadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialUncheckedUpdateManyWithoutSuperadminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    adminId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyAdminInput = {
    id?: string
    role?: $Enums.Role
    firstName: string
    lastName: string
    email: string
    passwordHash: string
    department?: string | null
    position?: string | null
    status?: boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PartnerCreateManyAdminInput = {
    id?: string
    role?: $Enums.Role
    companyName: string
    firstName: string
    lastName: string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email: string
    passwordHash: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerCreateManyAdminInput = {
    id?: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    partnerId?: string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCustomFieldCreateManyAdminInput = {
    id?: string
    fieldName: string
    fieldType: string
    isRequired?: boolean
    options?: AdminCustomFieldCreateoptionsInput | string[]
    isMultiSelect?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyAdminInput = {
    id?: string
    productName: string
    productCategory: JsonNullValueInput | InputJsonValue
    productPrice: string
    description?: string | null
    productLink?: string | null
    tags?: ProductCreatetagsInput | string[]
    specifications: JsonNullValueInput | InputJsonValue
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyAdminInput = {
    id?: string
    planId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LoginCredentialCreateManyAdminInput = {
    id?: string
    role: $Enums.Role
    email: string
    passwordHash: string
    userProfileId: string
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    superAdminId?: string | null
  }

  export type CustomerProductHistoryCreateManyAdminInput = {
    id?: string
    customerId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    companyName?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableJsonNullValueInput | InputJsonValue
    address?: NullableJsonNullValueInput | InputJsonValue
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutCustomersNestedInput
    product?: CustomerProductHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CustomerProductHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCustomFieldUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldName?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    options?: AdminCustomFieldUpdateoptionsInput | string[]
    isMultiSelect?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUpdateManyWithoutProductNestedInput
    renewalHistory?: ProductRenewalHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUncheckedUpdateManyWithoutProductNestedInput
    renewalHistory?: ProductRenewalHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    productName?: StringFieldUpdateOperationsInput | string
    productCategory?: JsonNullValueInput | InputJsonValue
    productPrice?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    productLink?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ProductUpdatetagsInput | string[]
    specifications?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: PlanUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: SubscriptionPaymentUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginCredentialUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superadmin?: SuperAdminUpdateOneWithoutLoginCredsNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: NullableStringFieldUpdateOperationsInput | string | null
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutLoginCredentialNestedInput
  }

  export type LoginCredentialUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    userProfileId?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    superAdminId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CustomerProductHistoryUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProductNestedInput
    product?: ProductUpdateOneRequiredWithoutCustomerProductHistoryNestedInput
    renewals?: ProductRenewalHistoryUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renewals?: ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyPartnerInput = {
    id?: string
    adminId: string
    companyName: string
    contactPerson: string
    mobileNumber: string
    email: string
    serialNo: string
    prime?: boolean
    blacklisted?: boolean
    remark?: string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address: JsonNullValueInput | InputJsonValue
    joiningDate: Date | string
    hasReference?: boolean
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutCustomersNestedInput
    product?: CustomerProductHistoryUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: CustomerProductHistoryUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactPerson?: StringFieldUpdateOperationsInput | string
    mobileNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    serialNo?: StringFieldUpdateOperationsInput | string
    prime?: BoolFieldUpdateOperationsInput | boolean
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    adminCustomFields?: NullableJsonNullValueInput | InputJsonValue
    address?: JsonNullValueInput | InputJsonValue
    joiningDate?: DateTimeFieldUpdateOperationsInput | Date | string
    hasReference?: BoolFieldUpdateOperationsInput | boolean
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditCreateManyLoginCredentialInput = {
    id?: string
    attemptTime?: Date | string
    success: boolean
    ipAddress: string
    userAgent: string
    createdAt?: Date | string
  }

  export type LoginAuditUpdateWithoutLoginCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateWithoutLoginCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateManyWithoutLoginCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptTime?: DateTimeFieldUpdateOperationsInput | Date | string
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferCreateManyPlanInput = {
    id?: string
    offerType: $Enums.OfferType
    value?: number | null
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanSpecCreateManyPlanInput = {
    id?: string
    specName: string
    specValue: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanDescriptionCreateManyPlanInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateManyPlanInput = {
    id?: string
    adminId: string
    status: $Enums.SubscriptionStatus
    startsAt: Date | string
    endsAt?: Date | string | null
    renewedAt?: Date | string | null
    cancelledAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanOfferUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanOfferUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    offerType?: EnumOfferTypeFieldUpdateOperationsInput | $Enums.OfferType
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanSpecUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    specName?: StringFieldUpdateOperationsInput | string
    specValue?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanDescriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: SubscriptionPaymentUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
    events?: SubscriptionEventUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startsAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentCreateManySubscriptionInput = {
    id?: string
    amount: number
    currency: string
    paidAt: Date | string
    status: string
    paymentMethod?: string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionEventCreateManySubscriptionInput = {
    id?: string
    eventType: string
    eventAt: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionPaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionPaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    gatewayResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionEventUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    eventAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductHistoryCreateManyProductInput = {
    id?: string
    customerId: string
    adminId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryCreateManyProductInput = {
    id?: string
    customerProductHistoryId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutProductNestedInput
    admin?: AdminUpdateOneRequiredWithoutProductHistoriesNestedInput
    renewals?: ProductRenewalHistoryUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renewals?: ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerProductHistory?: CustomerProductHistoryUpdateOneRequiredWithoutRenewalsNestedInput
  }

  export type ProductRenewalHistoryUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProductHistoryId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerProductHistoryId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerProductHistoryCreateManyCustomerInput = {
    id?: string
    adminId: string
    productId: string
    purchaseDate: Date | string
    renewal?: boolean
    renewPeriod?: $Enums.renewPeriod
    expiryDate?: Date | string | null
    renewalDate?: Date | string | null
    status?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerProductHistoryUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: AdminUpdateOneRequiredWithoutProductHistoriesNestedInput
    product?: ProductUpdateOneRequiredWithoutCustomerProductHistoryNestedInput
    renewals?: ProductRenewalHistoryUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    renewals?: ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryNestedInput
  }

  export type CustomerProductHistoryUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewal?: BoolFieldUpdateOperationsInput | boolean
    renewPeriod?: EnumrenewPeriodFieldUpdateOperationsInput | $Enums.renewPeriod
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryCreateManyCustomerProductHistoryInput = {
    id?: string
    productId: string
    purchaseDate: Date | string
    renewalDate?: Date | string | null
    expiryDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductRenewalHistoryUpdateWithoutCustomerProductHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutRenewalHistoryNestedInput
  }

  export type ProductRenewalHistoryUncheckedUpdateWithoutCustomerProductHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductRenewalHistoryUncheckedUpdateManyWithoutCustomerProductHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    renewalDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}